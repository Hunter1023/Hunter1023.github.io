<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"hunter1023.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":3,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Tough times never last, but tough people do.">
<meta property="og:type" content="website">
<meta property="og:title" content="Talk is cheap">
<meta property="og:url" content="https://hunter1023.github.io/page/7/index.html">
<meta property="og:site_name" content="Talk is cheap">
<meta property="og:description" content="Tough times never last, but tough people do.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Hunter">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://hunter1023.github.io/page/7/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/7/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Talk is cheap</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Talk is cheap</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hunter</p>
  <div class="site-description" itemprop="description">Tough times never last, but tough people do.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">98</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">175</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hunter1023.github.io/2021/06/16/SSMS%E4%B8%8D%E8%83%BD%E5%9C%A8%E4%B8%80%E4%B8%AA%E7%AA%97%E5%8F%A3%E4%B8%AD%E6%89%93%E5%BC%80%E5%A4%9A%E4%B8%AA-sql%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hunter">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talk is cheap">
      <meta itemprop="description" content="Tough times never last, but tough people do.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Talk is cheap">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/16/SSMS%E4%B8%8D%E8%83%BD%E5%9C%A8%E4%B8%80%E4%B8%AA%E7%AA%97%E5%8F%A3%E4%B8%AD%E6%89%93%E5%BC%80%E5%A4%9A%E4%B8%AA-sql%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">SSMS不能在一个窗口中打开多个.sql文件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-17 01:54:37" itemprop="dateCreated datePublished" datetime="2021-06-17T01:54:37+08:00">2021-06-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-23 23:29:13" itemprop="dateModified" datetime="2025-01-23T23:29:13+08:00">2025-01-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在经过种种不可考的、操作当时觉得并无不妥的操作后，SSMS(Sql Server Management Studio)突然在某一天开始，<strong>无法在其窗口中打开多个.sql文件</strong>，即<strong>双击sql文件后，会另外启动一个新的SSMS程序</strong>，<strong>而不是在当前的SSMS界面中打开文件</strong>。更准确的描述是<strong>无法在单独的SSMS实例中打开多个sql文件</strong>。</p>
<p><del>没有什么故障是卸载重装解决不了的，如果有，那就再装一次！</del>痛苦的时光从此开始，<strong>没想到重装之后不但没有解决上述问题，甚至连将SSMS作为sql文件的打开方式都变得困难且异常起来！<strong>而且，SQL Server作为一个中文环境下相对冷门的数据库，居然</strong>找不到任何靠谱的网上解答</strong>！在此要感谢最近被迫阅读英文论文的自己，导致对去英语环境下查找解决之法没有以前那么抗拒。</p>
<p>先说结论：<strong>感谢歪果网友，让我（我相信还有很多同仁！）得到了救赎！</strong></p>
<p>上述问题以及恶化的情况在如下操作后，能够一并解决：</p>
<ol>
<li><p><strong>不需要</strong>因为SSMS的问题，把SQL Server也卸载重装。</p>
</li>
<li><p>卸载SSMS</p>
</li>
<li><p>(<strong>微软的产品，恶心人的地方似乎都在注册表</strong>)</p>
<p> 打开<strong>注册表编辑器</strong>（Win + R，输入<code>regedit</code>，确定）</p>
</li>
<li><p><strong>删除</strong>如下条目：</p>
<ol>
<li>HKEY_CLASSES_ROOT\.sql</li>
<li>HKEY_CLASSES_ROOT\Applications\Ssms.exe</li>
<li>HKEY_CLASSES_ROOT\sql_auto_file</li>
<li>HKEY_CURRENT_USER\Software\Microsoft\SQL Server Management Studio</li>
<li>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\ApplicationAssociationToasts 下，<strong>包含SSMS字符的所有记录(而不是删除这个路径下的所有内容)</strong></li>
<li>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts.sql</li>
<li>HKEY_USERS.DEFAULT\Software\Microsoft\SQL Server Management Studio</li>
</ol>
</li>
<li><p>重启电脑</p>
</li>
<li><p>重新安装SSMS</p>
</li>
</ol>
<p>完结，撒花。</p>
<hr>
<p>参考：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/7123365/how-to-open-multiple-sql-files-in-only-one-ssms-instance">database - How to open multiple .sql files in only one ssms instance - Stack Overflow</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hunter1023.github.io/2021/06/15/SQLserver%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%9AT-SQL%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hunter">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talk is cheap">
      <meta itemprop="description" content="Tough times never last, but tough people do.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Talk is cheap">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/15/SQLserver%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%9AT-SQL%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">SQLserver技术内幕：T-SQL语言基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-15 08:38:03" itemprop="dateCreated datePublished" datetime="2021-06-15T08:38:03+08:00">2021-06-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-23 23:29:13" itemprop="dateModified" datetime="2025-01-23T23:29:13+08:00">2025-01-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="T-SQL-查询和编程基础"><a href="#T-SQL-查询和编程基础" class="headerlink" title="T-SQL 查询和编程基础"></a>T-SQL 查询和编程基础</h2><h3 id="数据生命周期"><a href="#数据生命周期" class="headerlink" title="数据生命周期"></a>数据生命周期</h3><h4 id="联机事务处理-OLTP，OnLine-Transactional-Processing"><a href="#联机事务处理-OLTP，OnLine-Transactional-Processing" class="headerlink" title="联机事务处理 (OLTP，OnLine Transactional Processing)"></a>联机事务处理 (OLTP，OnLine Transactional Processing)</h4><p>OLTP系统的<strong>重点</strong>是<strong>数据输入</strong>，而不是生成报表。主要处理的事务包括插入、更新和删除数据。关系模型的目标主要定位于OLTP系统，一个规范化的模型可以为数据输入和数据一致性提供更好的性能。在<strong>规范化</strong>的环境中，<strong>每个数据表用于表示一个实体，并将数据冗余保持在最低限度</strong>。当要修改一个实体事实时，只要在一个地方进行修改，使修改操作得以优化，同时也减少了发生错误的机会。</p>
<p>但<strong>OLTP环境不适合生成报表</strong>，因为规范化的数据模型通常涉及许多表，表间关系非常复杂，导致查询复杂、性能低下。</p>
<hr>
<h4 id="数据仓库-Data-Warehouse"><a href="#数据仓库-Data-Warehouse" class="headerlink" title="数据仓库 (Data Warehouse)"></a>数据仓库 (Data Warehouse)</h4><p>数据仓库是专门针对<strong>数据检索</strong>和<strong>生成报表</strong>而设计的环境。当这样的环境服务于整个企业，就称之为数据仓库。主要为了支持数据检索，而对数据仓库中的数据模型进行设计和优化。<strong>模型有意保持了一定的冗余，允许通过更少的表和更简单的关系，得到比OLTP环境更加简单和有效的查询</strong>。</p>
<p>数据仓库最简单的设计是<strong>star schema</strong>，它包括<strong>多个维度表(dimension table)和一个事实表(fact table)</strong>。<strong>每个维度代表一个如何分析数据的主题。</strong></p>
<p>例如，在处理订单和销售的系统中，可能要按照客户、产品、雇员、时间等不同的维度对数据进行分析。在star schema中，<strong>每个维度实现为一个具有冗余数据的表</strong>。例如，一个产品维度应该实现为一个ProductDim表，而不是规范化的三个表：Products、ProductSubCategories和ProductCategories。如果<strong>规范化一个维度表，生成表示该维度的多个表</strong>，得到的就是所谓的<strong>雪花形维度(snowflake dimension)</strong>，包含雪花形维度的模式就称为<strong>雪花模式(snowflake schema)</strong>。</p>
<p><strong>事实表存储用户感兴趣的事实和度量(measure)</strong>，比如与维度主键的每个组合相关的数量和值。例如，对于客户、产品、雇员，以及日期的每个组合，在事实表中将有一行相关的数量和值。<strong>数据仓库中的数据通常会预先聚合到某个特定级别的粒度(如日期)</strong>，而<strong>在OLTP环境中的数据通常按照事务级别来记录</strong>。</p>
<p><strong>ETL（Extract Transform and Load）</strong>：从源系统(OLTP以及其它系统)<strong>抽取</strong>数据，对数据进行<strong>处理</strong>，并将数据<strong>加载到数据仓库</strong>的工具。SQL Server提供了叫做Microsoft SQL Server Intergration Services(<strong>SSIS</strong>)的工具来处理ETL请求。</p>
<hr>
<h4 id="联机分析处理技术-OLAP-OnLine-Analytical-Processing"><a href="#联机分析处理技术-OLAP-OnLine-Analytical-Processing" class="headerlink" title="联机分析处理技术(OLAP, OnLine Analytical Processing)"></a>联机分析处理技术(OLAP, OnLine Analytical Processing)</h4><p>OLAP系统支持对聚合后的数据进行<strong>动态的在线分析</strong>，这通常涉及<strong>频繁地请求不同级别的聚合</strong>。后者又必须对数据进行<strong>切片(slicing)<strong>和</strong>切块(dicing)</strong>。如果对于每个这样的请求都要扫描和聚合大量数据，代价高，响应时间久，因此<strong>可以预先计算好不同级别的聚合</strong>，如时间维度、产品维度。</p>
<p>预先计算不同级别聚合的方法：</p>
<ol>
<li>在关系数据仓库中计算和存储不同级别的聚合。这需要编写一套复杂的过程来处理聚合的初始化和增量更新。</li>
<li>适用专门为OLAP需求而设计的特殊产品——Microsoft SQL Server Analysis Services（<strong>SSAS</strong>）。SSAS是<strong>独立于SQL Server服务的一种服务(或引擎)</strong>，它可以<strong>计算不同级别的聚合</strong>，并将其<strong>保存在一种经过优化的多维结构(多维数据集，cube)<strong>中。用于</strong>管理和查询SSAS数据方块</strong>的语言称为<strong>多维表达式</strong>(<strong>MDX, Multidimensional Expressions</strong>)。</li>
</ol>
<hr>
<h4 id="数据挖掘-DM-Data-Mining"><a href="#数据挖掘-DM-Data-Mining" class="headerlink" title="数据挖掘(DM, Data Mining)"></a>数据挖掘(DM, Data Mining)</h4><p>在动态分析处理中，为了找到有用的信息，用户必须<strong>不断地从一种聚合视图定位到另一种视图</strong>(进行<strong>数据切片和切块</strong>)。<strong>数据挖掘算法</strong>可以梳理数据，从中筛选出有用的信息。</p>
<p><strong>SSAS支持用数据挖掘算法(聚类分析、决策树等)来解决这些需求</strong>。用于<strong>管理和查询数据挖掘模型的语言</strong>是<strong>数据挖掘扩展插件语句</strong>(<strong>DMX, Data Mining Extensions</strong>)。</p>
<p><img src="https://i.loli.net/2021/06/16/VYkyw7CdstlTjUq.png" alt="数据生命周期"></p>
<hr>
<h3 id="SQL-Server-体系结构"><a href="#SQL-Server-体系结构" class="headerlink" title="SQL Server 体系结构"></a>SQL Server 体系结构</h3><h4 id="SQL-Server-实例"><a href="#SQL-Server-实例" class="headerlink" title="SQL Server 实例"></a>SQL Server 实例</h4><p><strong>SQL Server实例</strong>是指安装的一个<strong>SQL Server数据库引擎&#x2F;服务</strong>。一台计算机上可以安装多个实例。</p>
<hr>
<h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>每个SQL Server实例可以包含多个数据库。安装程序创建的<strong>系统数据库</strong>包括：</p>
<ol>
<li>master</li>
</ol>
<p>  保存SQL Server实例范围内的源数据信息、服务器配置、实例中所有数据库的信息，以及初始化信息。</p>
<ol start="2">
<li><p>model </p>
<p> model数据库是<strong>创建新数据库的模板</strong>。每个新创建的数据库最初都是model的一个副本(copy)。如果想在所有新创建的数据库中都<strong>包含特定的对象</strong>(比如数据类型)，或者想在所有新创建的数据库中都以特定的方式来配置某些数据库属性，就可以先把这些对象或配置属性放在model数据库中。</p>
<p> <strong>对model数据库做出的修改不会影响已有的数据库，只影响之后新创建的数据库</strong></p>
</li>
<li><p>tempdb</p>
<p> tempdb数据库是SQL Server<strong>保存临时数据</strong>的地方，包括工作表(work table)、排序空间(sort space)、行版本控制(row versioning)信息等。<strong>SQL Server允许用户创建临时表，其存储位置就是tempdb。</strong></p>
<p> <strong>每次重新启动SQL Server实例时，会删除这个数据库的内容，并将其重新创建为model的一个副本</strong>。</p>
</li>
<li><p>msdb</p>
<p> msdb是<strong>SQL Server Agent保存其数据</strong>的地方。SQL Server Agent负责<strong>自动化处理</strong>，包括<strong>记录有关作业(job)、计划(schedule)和警报等实体的信息</strong>。SQL Server Agent也是<strong>负责复制</strong>的服务。msdb还用于保存一些有关其他SQL Server功能的信息，例如Database Mail和Service Broker。</p>
</li>
</ol>
<p>可以在<strong>数据库级上定义</strong>一个称为<strong>collation（排序规则）<strong>的属性，由它确定数据库中字符数据使用的排序规则信息（<strong>包括支持的语言、区分大小写和排序顺序</strong>）。如果在创建数据库时不指定collation属性，将使用</strong>实例默认的排序规则</strong>设置。</p>
<p>如下图，数据库在物理上由<strong>数据文件</strong>和<strong>事务日志文件</strong>组成。当创建数据库时，能够定义每个文件的各种属性，包括<strong>文件名、保存位置</strong>，以及<strong>文件自动扩展的增量</strong>。</p>
<p>每个数据库必须<strong>至少有一个数据文件和一个日志文件</strong>。</p>
<ul>
<li>数据文件(.mdf, .ndf)：保存数据库对象数据；</li>
<li>日志文件(.ldf, log data file)：保存SQL Server为了<strong>维护事务而需要的信息</strong>；</li>
</ul>
<p>SQL Server可以并行写多个数据文件，但<strong>只能顺序写日志文件</strong>，因此<strong>使用多个日志文件也不能提升系统的性能</strong>。多个数据文件在逻辑上按照<strong>文件组（filegroup）的形式</strong>进行分组管理。对象数据可能会保存在<strong>属于目标文件组</strong>的多个文件中。数据库<strong>至少要有一个主文件组</strong>。PRIMARY文件组包含主数据文件（<strong>.mdf</strong>, Master Data File）和数据库的系统目录（catalog），可以选择性地为PRIMARY增加多个辅助数据文件(<strong>.ndf</strong>, secondary data file)。<strong>用户定义的文件组只能包含辅助数据文件</strong>。</p>
<p>可以<strong>指定默认文件组</strong>，当对象创建语句没有明确指定目标文件组时，就将其创建在默认文件组中。</p>
<p><img src="https://i.loli.net/2021/06/17/MQ5EuVK2q4ZPhms.png" alt="数据布局"></p>
<hr>
<h4 id="架构-Schema-和对象"><a href="#架构-Schema-和对象" class="headerlink" title="架构 (Schema) 和对象"></a>架构 (Schema) 和对象</h4><p>如下图所示，一个数据库包含多个架构，每个架构包含多个对象。可以将架构（Schema）看作是<strong>各种对象的容器</strong>，这些对象可以是表（table）、视图（view）、存储过程（store procedure）等。</p>
<p><img src="https://i.loli.net/2021/06/17/Ddl54MWCvLm6tsB.png" alt="数据库架构和对象"></p>
<p>可以在架构级别上控制对象的访问权限。</p>
<p>另外架构也是一个命名空间，用作对象名称的前缀。<strong>如果在引用对象时省略架构名称，SQL Server会自行分析</strong>，导致可能得到的对象不是原本想要的。</p>
<hr>
<h3 id="创建表和定义数据完整性"><a href="#创建表和定义数据完整性" class="headerlink" title="创建表和定义数据完整性"></a>创建表和定义数据完整性</h3><p><strong>表属于架构，架构属于数据库</strong>。</p>
<p>在SQL Server环境中创建一个名为testdb的数据库：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">IF</span> DB_ID<span class="token punctuation">(</span><span class="token string">'testdb'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token boolean">NULL</span>
<span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> testdb<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>DB_ID函数接受一个<strong>数据库名称</strong>作为参数，返回它的<strong>内部数据库ID</strong>，如果<strong>指定的数据库不存在，将返回NULL</strong>。<br>在这个简单的CREATE DATABASE语句中，<strong>采用了默认的文件设置（例如区域和初始大小）</strong>。<strong>在产品环境中，通常应该显式指定所有需要的数据库和文件的设置</strong>。</p>
<p>上述例子中使用的架构是dbo，在<strong>每个数据库中都会自动创建dbo架构，并作为默认架构</strong>。</p>
<hr>
<h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><p>以下代码创建一个名为Employees的表：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> testdb<span class="token punctuation">;</span>

<span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'dbo.Employees'</span><span class="token punctuation">,</span> <span class="token string">'U'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Employees<span class="token punctuation">;</span>

<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Employees
<span class="token punctuation">(</span>
	empId	<span class="token keyword">INT</span>	<span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
	firstName	<span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span>	<span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
	lastName	<span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span>	<span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
	hireDate	<span class="token keyword">DATE</span>	<span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
	mgrId	<span class="token keyword">INT</span>	<span class="token boolean">NULL</span><span class="token punctuation">,</span> <span class="token comment">-- 经理ID，允许有雇员没有经理，如CEO</span>
	ssn	<span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>	<span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span> <span class="token comment">-- social security number，社会保险号</span>
	salary	MONEY	<span class="token operator">NOT</span> <span class="token boolean">NULL</span>	
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>USE语句将当前的数据库上下文切换为testdb，它能<strong>确保后续操作会在目标数据库中进行</strong>。<br>IF语句调用OBJECT_ID函数，检查当前数据库中是否已经存在Employees表。<strong>OBJECT_ID函数</strong>接受一个<strong>对象名称</strong>和<strong>类型</strong>作为参数，<strong>U代表用户定义的表</strong>。可填写的类型见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/nimorl/p/4867422.html">SQL SERVER 中的 object_id()函数</a>。<strong>如果匹配给定参数的对象存在，该函数就返回内部的对象ID</strong>，否则返回NULL。</p>
<p>对于表的<strong>每个属性</strong>，需要指定它的属性名称、数据类型和<strong>是否允许NULL值</strong>。如果<strong>不显式指定一个列是否允许NULL值，SQL Server则采用默认值</strong>，<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BE%8E%E5%9B%BD%E5%9B%BD%E5%AE%B6%E6%A0%87%E5%87%86%E5%AD%A6%E4%BC%9A/1351184?fromtitle=ANSI&fromid=14955#viewPageContent">ANSI</a>规定<strong>默认为NULL</strong>。<strong>除非有明显的原因必须要支持NULL，各属性最好都定义为NOT NULL</strong>。</p>
<hr>
<h4 id="定义数据完整性"><a href="#定义数据完整性" class="headerlink" title="定义数据完整性"></a>定义数据完整性</h4><ul>
<li><strong>声明式</strong>(declarative)数据完整性：<strong>作为表定义的一部分</strong>而实施的数据完整性。</li>
<li><strong>过程式</strong>(procedural)数据完整性：<strong>用代码来实施</strong>的数据完整性。</li>
</ul>
<p>为属性选择数据类型和是否与允许NULL值，甚至数据模型本身，都是声明式数据完整性约束的例子。当用<strong>CREATE TABLE</strong>语句创建表时，可以同时定义这些约束；或者在表已创建的情况下，用<strong>ALTER TABLE</strong>语句增加这些约束。</p>
<p><strong>除了DEFAULT约束以外，其他所有约束都可以定义为组合约束</strong>(即基于一个或多个属性的约束)。</p>
<hr>
<h5 id="主键约束-Primary-Key-Constraints"><a href="#主键约束-Primary-Key-Constraints" class="headerlink" title="主键约束 (Primary Key Constraints)"></a>主键约束 (Primary Key Constraints)</h5><p>主键约束用于实施<strong>行的唯一约束</strong>，同时<strong>不允许约束属性取NULL值</strong>，表内的<strong>每行数据可以被唯一确定</strong>。<strong>每个表只能定义一个主键</strong>。</p>
<p>以上述创建的Employees表为例，在empId上定义一个主键约束：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Employees
<span class="token keyword">ADD</span> <span class="token keyword">CONSTRAINT</span> PK_Employees
<span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>empId<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>为了实施逻辑主键约束的唯一约束，SQL Server<strong>在幕后创建一个唯一索引(unique index)</strong>。也可以<strong>用索引来加速查询的处理，避免对整个表进行不必要的扫描</strong>。</p>
<hr>
<h5 id="唯一约束-nique-Constraints"><a href="#唯一约束-nique-Constraints" class="headerlink" title="唯一约束 (nique Constraints)"></a>唯一约束 (nique Constraints)</h5><p>唯一约束用来<strong>保证数据行的一个列(或一组列)数据的唯一</strong>，可以在数据库中<strong>实现关系模型的替换键（alternate key）<strong>的概念。与主键不同，<strong>同一个表中可以定义多个唯一约束</strong>，唯一约束也</strong>不限于只定义在NOT NULL列上</strong>。SQL Server支持<strong>只允许在唯一约束列中有一个列可以为NULL值</strong>。</p>
<p>以下代码在Employees表中定义了ssn列上的一个唯一约束：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Employees
<span class="token keyword">ADD</span> <span class="token keyword">CONSTRAINT</span> UNQ_Employees_ssn <span class="token comment">-- 增加约束</span>
<span class="token keyword">UNIQUE</span><span class="token punctuation">(</span>ssn<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>和主键约束一样，SQL Server也在幕后为唯一约束创建一个唯一索引</strong>。</p>
<hr>
<h5 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h5><p>外键约束用于实施<strong>引用完整性</strong>。这种约束在引用表（referencing table）的一组属性上进行定义，并<strong>指向被引用表（referenced table）中的一组候选键（主键或唯一约束）</strong>。<strong>引用表和被引用表可能是同一个表</strong>。外键的目的是为了将外键列允许的值域<strong>限制为被引用列中现有的值</strong>。</p>
<p>以下代码创建了一个名为Orders的表，其主键定义在orderid列上：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'dbo.Orders'</span><span class="token punctuation">,</span> <span class="token string">'U'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Orders<span class="token punctuation">;</span>

<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Orders
<span class="token punctuation">(</span>
	orderId	<span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    empId	<span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    custId	<span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>	<span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    orderTs	<span class="token keyword">DATETIME</span>	<span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    qty	<span class="token keyword">INT</span>	<span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    <span class="token keyword">CONSTRAINT</span> PK_Orders <span class="token comment">-- 定义约束</span>
    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>OrderID<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接下来在Orders表的empId列上定义一个外键约束，让它指向Employees表的empId列：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Orders
<span class="token keyword">ADD</span> <span class="token keyword">CONSTRAINT</span> FK_Orders_Employees
<span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>empId<span class="token punctuation">)</span>
<span class="token keyword">REFERENCES</span> dbo<span class="token punctuation">.</span>Employees<span class="token punctuation">(</span>empId<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p><strong>引用表和被引用表可能是同一个表</strong>。</p>
</blockquote>
<p>限制Employees表的mgrId列的值域为<strong>同一个表中已存在的那些empId列的值</strong>，可以增加如下外键约束：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Employees
<span class="token keyword">ADD</span> <span class="token keyword">CONSTRAINT</span> FK_Employees_Employees
<span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>mgrId<span class="token punctuation">)</span> <span class="token comment">-- 依然允许NULL值</span>
<span class="token keyword">REFERENCES</span> dbo<span class="token punctuation">.</span>Employees<span class="token punctuation">(</span>empId<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>注意：即使被引用的候选列不存在NULL值，在外键列中也允许NULL值</strong>。</p>
<p>以上定义的外键，当试图删除或更新<strong>被引用的</strong>相关数据时，<strong>如果在引用表中存在相关的行，则操作不能执行</strong>。这种情况可以通过定义具有<strong>级联操作</strong>的外键来解决，可在外键定义中将<strong>ON DELETE</strong>和<strong>ON UPDATE</strong>选项定义为<strong>CASCADE</strong>、<strong>SET DEFAULT</strong>和<strong>SET NULL</strong>之类的操作。</p>
<ul>
<li><strong>CASCADE</strong>：操作被<strong>级联到引用表中相关的列</strong></li>
<li>SET DEFAULT &#x2F; SET NULL：将引用表中相关行的外键属性<strong>设置为列的默认值</strong>或<strong>NULL</strong></li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Employees
<span class="token keyword">DROP</span> <span class="token keyword">CONSTRAINT</span> FK_Employees_Employees

<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Employees
<span class="token keyword">ADD</span> <span class="token keyword">CONSTRAINT</span> FK_Employees_Employees
<span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>mgrId<span class="token punctuation">)</span> <span class="token comment">-- 依然允许NULL值</span>
<span class="token keyword">REFERENCES</span> dbo<span class="token punctuation">.</span>Employees<span class="token punctuation">(</span>empId<span class="token punctuation">)</span>
<span class="token keyword">ON</span> <span class="token keyword">DELETE</span> <span class="token keyword">CASCADE</span>
<span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">SET</span> <span class="token keyword">DEFAULT</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h5 id="检查约束-Check"><a href="#检查约束-Check" class="headerlink" title="检查约束 (Check)"></a>检查约束 (Check)</h5><p>检查约束用于定义在表中输入或修改一行数据<strong>之前</strong>必须满足的一个谓词。</p>
<p>以下的检查约束可以保证Employees表的salary列只支持正数：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Employees
<span class="token keyword">ADD</span> <span class="token keyword">CONSTRAINT</span> CHK_Employees_salary
<span class="token keyword">CHECK</span><span class="token punctuation">(</span>salary <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>当谓词计算结果为TRUE或<strong>UNKNOWN</strong>时，RDBMS<strong>接受对数据行的修改</strong>，即<strong>NULL值会被接受</strong>。</p>
<hr>
<h5 id="默认约束-Default"><a href="#默认约束-Default" class="headerlink" title="默认约束 (Default)"></a>默认约束 (Default)</h5><p>默认约束与特定的属性关联。当插入一行数据时，如果没有为属性显式指定明确的值，就可以<strong>用一个表达式作为其默认值</strong>。</p>
<p>例如，以下代码为orderTs属性定义了一个默认约束（表示订单时间的时间戳）：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Orders
<span class="token keyword">ADD</span> <span class="token keyword">CONSTRAINT</span> DFT_Orders_orderTs
<span class="token keyword">DEFAULT</span><span class="token punctuation">(</span><span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">)</span> <span class="token keyword">FOR</span> orderTs<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>CURRENT_TIMESTAMP函数<strong>返回当前的日期和时间值</strong>。</p>
<hr>
<h2 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h2><p>先执行示例数据库脚本，构建一个示例数据库。</p>
<hr>
<h3 id="SELECT-语句的元素"><a href="#SELECT-语句的元素" class="headerlink" title="SELECT 语句的元素"></a>SELECT 语句的元素</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> TSQLFundamentals2008<span class="token punctuation">;</span>

<span class="token keyword">select</span> empid<span class="token punctuation">,</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>orderdate<span class="token punctuation">)</span> <span class="token keyword">AS</span> orderYear<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> numOrders
<span class="token keyword">from</span> Sales<span class="token punctuation">.</span>Orders
<span class="token keyword">where</span> custid <span class="token operator">=</span> <span class="token number">71</span>
<span class="token keyword">group</span> <span class="token keyword">by</span> empid<span class="token punctuation">,</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>orderdate<span class="token punctuation">)</span>
<span class="token keyword">having</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span>
<span class="token keyword">order</span> <span class="token keyword">by</span> empid<span class="token punctuation">,</span> orderYear<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>各子句在逻辑上按以下顺序进行处理：</p>
<ol>
<li>FROM</li>
<li>WHERE</li>
<li>GROUP BY</li>
<li>HAVING</li>
<li>SELECT</li>
<li>ORDER BY</li>
</ol>
<p>因此，上述代码<strong>实际的处理顺序</strong>如下：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">from</span> Sales<span class="token punctuation">.</span>Orders <span class="token comment">-- 查询数据行</span>
<span class="token keyword">where</span> custid <span class="token operator">=</span> <span class="token number">71</span> <span class="token comment">-- 保留客户ID = 71 的记录</span>
<span class="token keyword">group</span> <span class="token keyword">by</span> empid<span class="token punctuation">,</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>orderdate<span class="token punctuation">)</span> <span class="token comment">-- 按雇员ID和订单年份进行分组</span>
<span class="token keyword">having</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token comment">-- 保留具有多个订单的分组</span>
<span class="token keyword">select</span> empid<span class="token punctuation">,</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>orderdate<span class="token punctuation">)</span> <span class="token keyword">AS</span> orderYear<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> numOrders <span class="token comment">-- 返回指定行</span>
<span class="token keyword">order</span> <span class="token keyword">by</span> empid<span class="token punctuation">,</span> orderYear <span class="token comment">-- 按指定顺序对输出结果进行排序</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>分隔标识符名称</strong>：</p>
<p>如果标识符是非常规的（例如名称中<strong>嵌入了空格或其他特殊字符</strong>、<strong>以数字开头</strong>、或是SQL Server的<strong>保留字</strong>），就必须分隔这样的标识符。ANSI SQL分隔标识符的标准格式是<strong>使用双引号（例如，“Order Details”）</strong>。SQL Server的特殊格式是使用方括号（[Order Details]）。</p>
<hr>
<h4 id="WHERE-子句"><a href="#WHERE-子句" class="headerlink" title="WHERE 子句"></a>WHERE 子句</h4><p>WHERE子句<strong>对查询性能有重要影响</strong>。在过滤表达式的基础上，<strong>SQL Server会计算使用什么索引来访问请求的数据</strong>。通过<strong>使用索引</strong>，<strong>有时可以大幅减少</strong>SQL Server在获取请求的数据时<strong>付出的代价</strong>。</p>
<p>要实可记住T-SQL使用的是<strong>三值谓词逻辑（TRUE, FALSE, UNKNOWN）</strong>。如果WHERE阶段要返回结果为TRUE的行，UNKNOWN也不会被返回。</p>
<hr>
<h4 id="GROUP-BY-子句"><a href="#GROUP-BY-子句" class="headerlink" title="GROUP BY 子句"></a>GROUP BY 子句</h4><p>所有的聚合函数都会忽略NULL值，除了<strong>COUNT(*)</strong>。</p>
<p>例如，假设一个组有5行，其qty列的值分别为30、10、NULL、10、10。<strong>COUNT(*)返回5，COUNT(qty)返回4</strong>，<strong>COUNT(DISTINCT qty)返回2</strong>；</p>
<hr>
<h4 id="SELECT-子句"><a href="#SELECT-子句" class="headerlink" title="SELECT 子句"></a>SELECT 子句</h4><p>当表达式中进行了一定的处理（例如，YEAR(orderDate)），或者没有基于原始表的列（如调用CURRENT_TIMESTAMP函数），这时如果不为表达式起一个别名，查询的结果集中就不能拥有列名。<strong>在某些情况下，T-SQL允许查询返回没有名称的结果集列，但关系模型不允许这样</strong>。因此强烈推荐将诸如YEAR(orderDate)之类的表达式<strong>起一个别名</strong>。<br>除了<code>&lt;表达式&gt; AS &lt;别名&gt;</code>这种格式，T-SQL还支持<code>&lt;别名&gt; = &lt;表达式&gt;</code>，和<code>&lt;表达式&gt; &lt;别名&gt;</code>这两种格式，<strong>后者非常不明确，避免使用这种定义别名的方式</strong>。<br>由于SELECT字句是在FROM、WHERE、GROUP BY，以及<strong>HAVING子句之后处理</strong>。这意味着<strong>在SELECT子句中为表达式分配的别名，在SELECT子句之前处理的那些子句中并不存在</strong>。<br>以下就是在WHERE子句中使用这种<strong>无效引用</strong>的一个例子：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> orderId<span class="token punctuation">,</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>orderDate<span class="token punctuation">)</span> <span class="token keyword">AS</span> orderYear
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders
<span class="token keyword">WHERE</span> orderYear <span class="token operator">></span> <span class="token number">2006</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>解决这一问题的一种方法就是在WHERE子句和SELECT子句中<strong>重复使用表达式YEAR(orderDate)，SQL Server能够标识在查询中重复使用的同一表达式</strong>，因此，<strong>表达式其实只会被计算一次</strong>。<br>除了很少数的例外，<strong>在绝大多数情况下，使用星号*是一种糟糕的编程习惯</strong>。建议<strong>即使需要被查询表的所有列，也应该显式地指定它们</strong>。虽然使用星号时，为了解析列名需要付出一些额外的代价，但<strong>重要的问题在于查询过程中无法察觉到的代价，前者的代价反而显得微不足道</strong>。<br>在SELECT子句中<strong>不能引用当前SELECT子句中创建的别名列</strong>，例如：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> orderId<span class="token punctuation">,</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>orderDate<span class="token punctuation">)</span> <span class="token keyword">AS</span> orderYear<span class="token punctuation">,</span> orderYear <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">AS</span> nextYear
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如前所述，解决这一问题的方法就是<strong>重复使用表达式</strong>（虽然繁琐，但这就是SQL…）。</p>
<hr>
<h4 id="ORDER-BY-子句"><a href="#ORDER-BY-子句" class="headerlink" title="ORDER BY 子句"></a>ORDER BY 子句</h4><p><strong>带有ORDER BY 子句的查询</strong>会产生一种ANSI称之为<strong>游标（cursor）的结果</strong>（一种<strong>非关系结果，其中的行有固定的顺序</strong>）。<br>在SQL中的某些语言元素和运算预期<strong>只对查询的表结果进行处理，而不能处理游标</strong>，例如<strong>表表达式</strong>和<strong>集合运算</strong>。</p>
<p>下例中的查询，按照雇员ID和顶顶那年份对输出结果进行排序：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> empid<span class="token punctuation">,</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>orderDate<span class="token punctuation">)</span> <span class="token keyword">AS</span> orderYear<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> numOrders
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders
<span class="token keyword">WHERE</span> custId <span class="token operator">=</span> <span class="token number">71</span>
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> empid<span class="token punctuation">,</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>orderDate<span class="token punctuation">)</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> empId<span class="token punctuation">,</span> orderYear<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可见，<strong>ORDER BY 子句成功引用了SELECT子句中的别名列</strong>orderYear——可知<strong>ORDER BY子句是在SELECT阶段之后被处理的</strong>。<br>SQL和T-SQL都支持在ORDER BY子句中<strong>指定表示该列名称或别名在SELECT列表中所处位置的非负整数</strong>。<br>上述代码的<code>GROUP BY empId, orderYear</code>也可以写成<code>GROUP BY 1, 2</code>，<strong>但这是一种糟糕的方式</strong>。首先，在关系模型中，属性本身没有顺序位置，要通过名称来引用它们。其次，<strong>当修改SELECT子句时，可能会忘记对ORRDER BY 子句中的引用位置做相应的修改</strong>。<br><strong>T-SQL支持在ORDER BY子句中指定没有在SELECT子句中出现过的元素</strong>，例如，如下查询按照雇佣日期对雇员行进行排序，但最后并没有返回hireDate列：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> empId<span class="token punctuation">,</span> firstName<span class="token punctuation">,</span> lastName<span class="token punctuation">,</span> country
<span class="token keyword">FROM</span> HR<span class="token punctuation">.</span>Employees
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> hireDate<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><strong>当指定了DISTINCT以后，ORDER BY子句就只能选取在SELECT列中出现的元素</strong>。因为当指定DISTINCT时，一个结果行可能代表多个原始行，因此无法判断应该使用ORDER BY列表值中多个可能值中的哪一个。</p>
<hr>
<h4 id="TOP-选项"><a href="#TOP-选项" class="headerlink" title="TOP 选项"></a>TOP 选项</h4><p>TOP选项是<strong>T-SQL特有</strong>的，用于限制查询返回的<strong>行数</strong>或<strong>百分比</strong>。当在查询中<strong>指定了ORDER BY子句</strong>时，TOP将<strong>依赖该子句来定义行的逻辑优先顺序</strong>。例如，从Orders表返回最近的5个订单的代码如下：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">TOP</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> orderId<span class="token punctuation">,</span> orderDate<span class="token punctuation">,</span> custId<span class="token punctuation">,</span> empId
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> orderDate <span class="token keyword">DESC</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>从逻辑查询处理的角度来看，TOP选项是<strong>作为SELECT阶段的一部分</strong>而处理，<strong>紧接着DISTINCT子句处理之后</strong>。当查询中指定了TOP以后，ORDER BY子句就起到了<strong>双重作用</strong>。首先，作为SELECT处理阶段一部分的TOP选项要<strong>依靠ORDER BY子句先为各个行定义它们的逻辑优先顺序</strong>，在此基础上再去过滤其他请求。其次，作为SELECT处理阶段之后的ORDER BY阶段，与为了展示数据而行进行排序的ORDER BY子句完全一样。<br>当使用TOP时，同一ORDER BY子句既担当了<strong>为TOP决定行的逻辑优先顺序的角色</strong>，也担当了展示数据的常规角色，最终生成的结果由表变成了具有固定顺序的游标。<br>在TOP选项中可以使用<strong>PERCENT关键字</strong>，SQL Server会<strong>按照百分比</strong>来计算应该返回的满足条件的行数（<strong>向上取整</strong>）。例如，以下查询请求最近更新过的前1%（<strong>向上取整</strong>）个订单：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">TOP</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">PERCENT</span> orderId<span class="token punctuation">,</span> orderDate<span class="token punctuation">,</span> custId<span class="token punctuation">,</span> empId
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> orderDate <span class="token keyword">DESC</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>由于orderDate 的<strong>取值不是唯一</strong>的，具有相同订单日期的行之间的优先关系没有定义，<strong>这会让查询结果具有不确定性，多个查询结果都可以认为是正确的。SQL Server只是根据物理上最先访问到了哪行，就选择相应的行。<strong>如果想让查询结果是确定的，就要</strong>让ORDER BY列表能唯一地决定一行</strong>。<br>除了在ORDER BY列表增加额外的属性，还可以请求返回所有<strong>与TOP n行中最后一行具有相同结果的行</strong>，为此必须<strong>增加一个WITH TIES选项</strong>。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">TOP</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token keyword">WITH</span> TIES orderId<span class="token punctuation">,</span> orderDate<span class="token punctuation">,</span> custId<span class="token punctuation">,</span> empId
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> orderDate <span class="token keyword">DESC</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<hr>
<h4 id="OVER-子句"><a href="#OVER-子句" class="headerlink" title="OVER 子句"></a>OVER 子句</h4><p>OVER子句用于<strong>为行定义一个窗口（window），以便进行特定的运算</strong>，可以把行的窗口简单地认为是<strong>运算将要操作的一个行的集合</strong>。<strong>聚合函数</strong>和<strong>排名函数</strong>都是可以支持OVER子句的运算类型，由于OVER子句为这些函数提供了一个行的窗口，所以这些函数也称之为<strong>开窗函数（window function）</strong>。<br>聚合函数传统上一直以GROUP BY查询作为操作的上下文，聚合开窗函数使用OVER子句提供的窗口作为上下文，<strong>对窗口中的一组值进行操作</strong>。这样就能<strong>在不进行分组的情况下，在同一行中同时返回基础行的列和聚合列</strong>。<br>带有空的圆括号的OVER子句会提供<strong>所有行</strong>进行计算，这里的<strong>所有行是在FROM、WHERE、GROUP BY以及HAVING处理阶段完成后仍然可用的行</strong>。注意：<strong>只有在SELECT和ORDER BY处理阶段才允许使用OVER子句</strong>。<br>如果<strong>想对行进行限制或分区，可以使用PARTITION BY子句</strong>。例如，想返回<strong>当前客户</strong>（<strong>和当前行具有相同</strong>custId(某属性)的所有行）的总价格，则可以指定<code>SUM(val) OVER(PARTITION BY custId)</code>。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> orderId<span class="token punctuation">,</span> custId<span class="token punctuation">,</span> val<span class="token punctuation">,</span>
	<span class="token function">SUM</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token keyword">OVER</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> TTLvalue<span class="token punctuation">,</span>
	<span class="token function">SUM</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token keyword">OVER</span><span class="token punctuation">(</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> custId<span class="token punctuation">)</span> <span class="token keyword">AS</span> custTTLvalue
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>OrderValues<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>OVER子句还可以<strong>在表达式中混合使用基本列和聚合值列</strong>。例如，以下查询为OrderValues的每一行<strong>计算当前价格占总价格的百分比</strong>，以及<strong>当前价格占客户总价格的百分比</strong>：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> orderId<span class="token punctuation">,</span> custId<span class="token punctuation">,</span> val<span class="token punctuation">,</span>
	<span class="token number">100.</span> <span class="token operator">*</span> val <span class="token operator">/</span> <span class="token function">SUM</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token keyword">OVER</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> pctAll<span class="token punctuation">,</span>
	<span class="token number">100.</span> <span class="token operator">*</span> val <span class="token operator">/</span> <span class="token function">SUM</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token keyword">OVER</span><span class="token punctuation">(</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> custId<span class="token punctuation">)</span> <span class="token keyword">AS</span> pctCust
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>OrderValues<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>表达式中使用的是<strong>十进制实数100.</strong>，这样可以<strong>隐式地将整数值val和SUM(val)转换成十进制实数值</strong>。<br>OVER子句也支持四种<strong>排名函数</strong>：</p>
<ul>
<li>ROW_NUMBER 行号</li>
<li>RANK 排名</li>
<li>DENSE_RANK 密集排名</li>
<li>NTILE</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> orderId<span class="token punctuation">,</span> custId<span class="token punctuation">,</span> val<span class="token punctuation">,</span>
	ROW_NUMBER<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span><span class="token punctuation">(</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> val<span class="token punctuation">)</span> <span class="token keyword">AS</span> rowNum<span class="token punctuation">,</span>
	RANK<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span><span class="token punctuation">(</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> val<span class="token punctuation">)</span> <span class="token keyword">AS</span> rank<span class="token punctuation">,</span>
	DENSE_RANK<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span><span class="token punctuation">(</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> val<span class="token punctuation">)</span> <span class="token keyword">AS</span> dense_rank<span class="token punctuation">,</span>
	NTILE<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span><span class="token punctuation">(</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> val<span class="token punctuation">)</span> <span class="token keyword">AS</span> ntile
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>OrderValues
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> val<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>ROW_NUMBER</strong>函数用于为查询的结果集中的各行<strong>分配递增的序列号</strong>，<strong>即使行的排序值相同，也会生成唯一的行号值，如果ORDER BY不能唯一确定行的顺序，查询可能会返回多个正确的结果</strong>。如果<strong>想对排序值中的相同值以同样的方式处理</strong>，可以考虑使用<strong>RANK或DENSE_RANK函数</strong>。</p>
<p>RANK和DENSE_RANK与ROW_NUMBER类似，但它们<strong>为具有相同逻辑排序值的所有行生成同样的排名</strong>。RANK和DENSE_RANK的区别是：RANK表示之前<strong>有多少个具有更低的排序值的行</strong>，而DENSE_RANK则表示之前<strong>有多少个更低的排序值</strong>（这正是该函数被称为<strong>密集</strong>排名的原因）。</p>
<p><strong>NTILE</strong>函数可以把结果中的行<strong>关联到组（title，相当于由行组成的</strong>指定数目的组**）<strong>，并为每一行分配一个所属的组的编号。NTILE函数</strong>接受一个表示组的数量的参数，并要在OVER子句中指定逻辑顺序**。上述的查询例子有830行，请求将其分成10组，因此组的大小就是83。</p>
<p>NTILE函数在逻辑上需要依赖于ROW_NUMBER函数，整个过程是先根据对val的排序结果，为每一行分配行号；再基于前面计算好的组的大小83行，将第1行到第83行分配到第1组，以此类推。<strong>如果组数无法整除行数，余数会被一一分配到前面的每个组</strong>。例如，<strong>假设有102行，请求分成5组，那么前两组将有21行</strong>。</p>
<p><strong>OVER子句中指定的ORDER BY逻辑与数据展示没什么关系，不会改变查询结果表最终的任何内容</strong>。如果在SELECT处理阶段指定了开窗函数，开窗计算会<strong>在DISTINCT子句之前</strong>进行处理（TOP选项是紧接着DISTINCT处理之后）。<br>总结目前位置讨论过的所有子句的逻辑处理顺序：</p>
<ol>
<li>FROM</li>
<li>WHERE</li>
<li>GROUP BY</li>
<li>HAVING</li>
<li>SELECT<ul>
<li>OVER</li>
<li>DISTINCT</li>
<li>TOP</li>
</ul>
</li>
<li>ORDER BY</li>
</ol>
<hr>
<h3 id="谓词和运算符"><a href="#谓词和运算符" class="headerlink" title="谓词和运算符"></a>谓词和运算符</h3><p>T-SQL支持的谓词包括IN、BETWEEN以及LIKE等。</p>
<ul>
<li>BETWEEN这个谓词用于检查一个值是否在指定的范围内，<strong>包括两个指定的边界值</strong>。</li>
<li>LIKE这个谓词用于检查一个字符串是否与指定的模式匹配。例如，如下查询返回lastName以字符D开头的所有雇员：  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> empId<span class="token punctuation">,</span> firstName<span class="token punctuation">,</span> lastName
<span class="token keyword">FROM</span> HR<span class="token punctuation">.</span>Employees
<span class="token keyword">WHERE</span> lastname <span class="token operator">LIKE</span> N<span class="token string">'D%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
  <strong>字符串’D%’前面的字母N代表National</strong>，用于表示<strong>Unicode</strong>数据类型（NCHAR或NVARCHAR），与之对应的是<strong>常规</strong>的字符数据类型（CHAR或VARCHAR）。<strong>因为lastName字段的数据类型是NVARCHAR(40)，所以就要在字符串前面加个字母N</strong>。</li>
</ul>
<hr>
<h3 id="CASE-表达式"><a href="#CASE-表达式" class="headerlink" title="CASE 表达式"></a>CASE 表达式</h3><p>CASE表达式是一个标量<strong>表达式</strong>，它<strong>基于条件逻辑来返回一个值</strong>。CASE表达式不能被用于控制活动的流程，也不能根据条件逻辑来做某些处理。相反，它<strong>只是根据条件逻辑来返回某个值</strong>。因为CASE是一个标量表达式，所以它<strong>支持任何标量表达式</strong>（如SELECT、WHERE、HAVING以及ORDER BY子句）、<strong>CHECK约束</strong>等。</p>
<p>CASE表达式有两种格式：<strong>简单表达式</strong>和<strong>搜索表达式</strong>。</p>
<hr>
<h4 id="简单表达式"><a href="#简单表达式" class="headerlink" title="简单表达式"></a>简单表达式</h4><p>CASE简单格式<strong>将一个值（或一个标量表达式）与一组可能的取值进行比较</strong>，并<strong>返回第一个匹配的结果</strong>。如果列表中没有值等于测试值，CASE表达式就返回其<strong>ELSE子句中列出的值</strong>。<strong>如果没有ELSE子句，则默认将其视为ELSE NULL</strong>。</p>
<p>例如，以下对Production.Products表的查询就在SELECT子句中使用了CASE表达式，以生成用于描述categoryId列取值的信息：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> productId<span class="token punctuation">,</span> productName<span class="token punctuation">,</span> categoryId<span class="token punctuation">,</span>
	<span class="token keyword">CASE</span> categoryId
		<span class="token keyword">WHEN</span> <span class="token number">1</span> <span class="token keyword">THEN</span> <span class="token string">'Beverages'</span>
		<span class="token keyword">WHEN</span> <span class="token number">2</span> <span class="token keyword">THEN</span> <span class="token string">'Condiments'</span>
		<span class="token keyword">WHEN</span> <span class="token number">3</span> <span class="token keyword">THEN</span> <span class="token string">'Confections'</span>
		<span class="token keyword">ELSE</span> <span class="token string">'Unknown Category'</span>
    <span class="token keyword">END</span> <span class="token keyword">AS</span> CategoryName
<span class="token keyword">FROM</span> Production<span class="token punctuation">.</span>Products<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>除非商品种类的数量非常少，而且也是静态的，否则最好的设计选择可能是应该在另一个单独的表中来维护商品种类，当需要获取种类描述时，把那个表和Products进行连接join。事实上，TSQLFundamentals2008本身提供了一个这样的Categories表。</p>
<p>作为CASE简单表达式的另一个演示，以下对Sales.OrderValues视图的查询先根据val的逻辑顺序生成3个组，再把组的编号翻译成组的描述信息（Low、Medium和High）;</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> orderId<span class="token punctuation">,</span> custId<span class="token punctuation">,</span> val<span class="token punctuation">,</span>
	<span class="token keyword">CASE</span> NTILE<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span><span class="token punctuation">(</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> val<span class="token punctuation">)</span>
		<span class="token keyword">WHEN</span> <span class="token number">1</span> <span class="token keyword">THEN</span> <span class="token string">'Low'</span>
		<span class="token keyword">WHEN</span> <span class="token number">2</span> <span class="token keyword">THEN</span> <span class="token string">'Medium'</span>
		<span class="token keyword">WHEN</span> <span class="token number">3</span> <span class="token keyword">THEN</span> <span class="token string">'High'</span>
		<span class="token keyword">ELSE</span> <span class="token string">'Unknown'</span>
	<span class="token keyword">END</span> <span class="token keyword">AS</span> titleDesc
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>OrderValues
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> val<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>CASE<strong>简单表达式只有一个测试值（或表达式），它紧跟在CASE关键字后面，与WHEN子句中的一组可能值进行比较</strong>。</p>
<hr>
<h4 id="搜索表达式"><a href="#搜索表达式" class="headerlink" title="搜索表达式"></a>搜索表达式</h4><p>CASE 搜索表达式<strong>更灵活</strong>，它可以在WHEN子句中<strong>指定谓词或逻辑表达式</strong>，而不限于只进行相等性比较。CASE搜索表达式返回结果为TRUE的第一个WHEN逻辑表达式所关联的THEN子句中指定的值。如果没有任何WHEN表达式结果为TRUE，CASE表达式就返回ELSE子句中出现的值（<strong>如果没有指定ELSE子句，则返回NULL</strong>）。</p>
<p>例如，以下查询根据商品的价格是否小于1000.00、在1000.00到3000.00之间、或者大于3000.00而生成相应的价格描述：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> orderId<span class="token punctuation">,</span> custId<span class="token punctuation">,</span> val<span class="token punctuation">,</span>
	<span class="token keyword">CASE</span> 
		<span class="token keyword">WHEN</span> val <span class="token operator">&lt;</span> <span class="token number">1000.00</span>	<span class="token keyword">THEN</span> <span class="token string">'Less then 1000'</span>
		<span class="token keyword">WHEN</span> val <span class="token operator">BETWEEN</span> <span class="token number">1000.00</span> <span class="token operator">AND</span> <span class="token number">3000.00</span> <span class="token keyword">THEN</span> <span class="token string">'Between 1000 and 3000'</span>
		<span class="token keyword">WHEN</span> val <span class="token operator">></span> <span class="token number">3000.00</span>
		<span class="token keyword">ELSE</span> <span class="token string">'Unknown'</span>
	<span class="token keyword">END</span> <span class="token keyword">AS</span> valueCategory
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>OrderValues<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>每个CASE简单表达式都可以转换成CASE搜索表达式，但并非所有情况都有必要使用CASE搜索表达式</strong>。</p>
<hr>
<h3 id="NULL值"><a href="#NULL值" class="headerlink" title="NULL值"></a>NULL值</h3><p>如果逻辑表达式只涉及已经存在的值，那么最终的计算结果就是TRUE&#x2F;FALSE。但是<strong>当逻辑表达式涉及缺少的值时，其计算结果就是UNKNOWN</strong>。例如考虑谓词salary &gt; 0：<strong>当salary是NULL时，表达式的计算结果为UNKNOWN</strong>。</p>
<p>在不同的语言元素中，SQL对UNKNOWN的处理也有所不同。</p>
<ul>
<li>SQL<strong>对查询过滤条件处理</strong>的正确定义是：“接受TRUE”就意味着要<strong>过滤掉FALSE和UNKNOWN</strong>。</li>
<li>SQL<strong>对CHECK约束处理</strong>的正确定义是：“拒绝FALSE”就意味着<strong>接受TRUE和UNKNOWN</strong>。</li>
</ul>
<p>UNKNOWN的一个微妙之处是，<strong>当对它取反时，结果仍然是UNKNOWN</strong>。对两个NULL值进行比较的表达式<code>NULL = NULL</code>，其<strong>计算结果也是UNKNOWN</strong>。因为<strong>NULL值代表一个缺少或不可知的值，所以无法判断</strong>，因此SQL提供了两个谓词：<code>IS NULL</code>和<code>IS NOT NULL</code>来取代<code>= NULL</code>和<code>!= NULL</code>。</p>
<p>在用于比较和排序目的的不同语言元素中，SQL处理NULL的方式也有所不同。一些元素认为两个NULL值相等，另一些认为不等。</p>
<p>例如，分组和排序时，认为两个NULL值相等。至于排序时，NULL值应该排在有效值之前还是之后，ANSI SQL把它留给了具体的产品实现。<strong>T-SQL把NULL值排在了有效值之前</strong>。但可以通过<strong>在ORDER BY阶段通过CASE表达式，手工更改NULL值的排序</strong>：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token punctuation">(</span><span class="token keyword">CASE</span> <span class="token keyword">WHEN</span> xxx <span class="token operator">IS</span> <span class="token boolean">NULL</span> <span class="token keyword">THEN</span> <span class="token number">1</span> <span class="token keyword">ELSE</span> <span class="token number">0</span> <span class="token keyword">END</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>ANSI SQL有两种<strong>UNIQUE约束</strong>：</p>
<ol>
<li>将多个NULL值视为相等的</li>
<li>将多个NULL值视为不同的</li>
</ol>
<p><strong>SQL Server只实现了前者</strong>。</p>
<hr>
<h3 id="同时操作-All-At-Once-Operation"><a href="#同时操作-All-At-Once-Operation" class="headerlink" title="同时操作 (All-At-Once Operation)"></a>同时操作 (All-At-Once Operation)</h3><p>SQL支持一种所谓的<strong>同时操作</strong>的概念，认为<strong>在同一逻辑查询处理阶段中出现的所有表达式都是同时进行计算的</strong>。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> orderId<span class="token punctuation">,</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>orderDate<span class="token punctuation">)</span> <span class="token keyword">AS</span> orderYear<span class="token punctuation">,</span>
	orderYear <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">AS</span> nextYear
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>以上SELECT列表中<strong>第三个表达式对第二列orderYear这一列别名的引用是无效的</strong>，因为<strong>从逻辑上来说</strong>，SELECT列表中各表达式的计算是没有顺序的，所有表达式都在同一时刻进行计算。<br>再如下方的查询语句：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> col1<span class="token punctuation">,</span> col2
<span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>T1
<span class="token keyword">WHERE</span> col1 <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">AND</span> col2 <span class="token operator">/</span> col1 <span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果表达式<code>col1 != 0</code>的结果为FALSE，SQL Server将会按照**<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%9F%AD%E8%B7%AF%E6%B1%82%E5%80%BC/6428612?fr=aladdin">短路求值原则（short-circuit）</a><strong>，停止计算这个表达式。<br>因为ANSI SQL中有</strong>同时操作<strong>这一概念，所以</strong>SQL Server可以按它喜欢的任意顺序来自由处理WHERE子句中的表达式**。<strong>SQL Server通常是基于代价估计的标准来做决定，即通常先计算需要付出较小代价的表达式</strong>。为了尽可能避免查询执行失败，可以采用简单的数学办法避免除数为0的错误：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> col1<span class="token punctuation">,</span> col2
<span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>T1
<span class="token keyword">WHERE</span> col1 <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">and</span> col2 <span class="token operator">></span> <span class="token number">2</span> <span class="token operator">*</span> col1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<hr>
<h3 id="处理字符数据"><a href="#处理字符数据" class="headerlink" title="处理字符数据"></a>处理字符数据</h3><h4 id="排序规则-Collation"><a href="#排序规则-Collation" class="headerlink" title="排序规则 (Collation)"></a>排序规则 (Collation)</h4><p>排序规则封装了几个方面的特征，包括多语言支持（和Unicode类型有关）、排序规则、区分大小写、区分重音等。要得到系统中目前支持的所有排序规则及其描述，可以查询表函数<code>fn_helpcollations</code>，如下所示：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> name<span class="token punctuation">,</span> description
<span class="token keyword">FROM</span> sys<span class="token punctuation">.</span>fn_helpcollations<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>例如排序规则Latin1_General_CI_AS：</p>
<ul>
<li>Latin1_Genral 表示支持的语言是英语</li>
<li>排序规则名称中<strong>没有显式地出现BIN元素</strong>，则<strong>默认使用字典排序（不区分大小写）</strong></li>
<li>CI 表示<strong>不区分大小写</strong>（Case Insensitive）</li>
<li>AS 表示区分重音（Accent Sensitive）</li>
</ul>
<p>可以在4种不同的级别上定义排序规则：</p>
<ol>
<li>SQL Server实例</li>
<li>数据库</li>
<li>列</li>
<li>表达式</li>
</ol>
<p><strong>最低级的排序规则是比较有效的一种定义方式</strong>。</p>
<ul>
<li>SQL Server实例的排序规则是在安装时设置的。它决定了所有系统数据库的排序规则，同时也是用户数据库默认使用的排序规则。</li>
<li><strong>创建用户数据库</strong>时，可以使用<strong>COLLATE子句</strong>指定数据库的排序规则。数据库的排序规则决定了数据库中<strong>对象元数据的排序规则</strong>，同时也是<strong>用户表列</strong>默认使用的排序规则。<br>  如果数据库的<strong>排序规则区分大小写，则可以同时创建两个列为T1和t1的表</strong> 。</li>
<li>在<strong>定义列</strong>时，可以使用<strong>COLLATE子句</strong>显式地指定它的排序规则。</li>
<li>COLLATE子句也可以<strong>修改表达式的排序规则</strong>。<br>  例如，<strong>在不区分大小写的环境中，在查询中使用区分大小写的比较</strong>：  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> empId<span class="token punctuation">,</span> firstName<span class="token punctuation">,</span> lastName
<span class="token keyword">FROM</span> HR<span class="token punctuation">.</span>Employees
<span class="token keyword">WHERE</span> lastName <span class="token keyword">COLLATE</span> Latin1_General_CS_AS <span class="token operator">=</span> N<span class="token string">'davis'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ul>
<hr>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>SQL Server支持<strong>两种字符数据类型</strong>：<strong>普通字符</strong>和<strong>Unicode字符</strong>。普通字符数据类型包括CHAR和VARCHAR，Unicode字符数据类型包括NCHAR和NVARCHAR。<strong>普通字符使用一个byte来保存每个字符，Unicode字符需要两个byte</strong>。一个列所支持的语言由<strong>列的有效排序规则（collation）属性决定</strong>。</p>
<ul>
<li>在<strong>排序规则为Latin1_General_CS_AS等规则</strong>时：<br>  普通字符类型由于一个列只用一个byte来保存每个字符，所以就<strong>限制在这个列中只能使用英语</strong>。<br>  当使用Unicode字符类型时，<strong>可以表示所有语言</strong>，表示字符常量时，<strong>需要在单引号前指定一个字符N</strong>：<code>N&#39;Unicode字符&#39;</code>。</li>
<li>在<strong>排序规则为Chinese_PRC_CI_AS等规则</strong>时：<br>  <strong>中文也能直接保存在VARCHAR类型中，且无需通过在单引号前指定一个字符N</strong>。</li>
</ul>
<p>名称中不包含VAR元素的任何数据类型都是固定长度的（CHAR, NCAHR），SQL Server会<strong>按照为列定义的大小，在行中为该列留出固定的空间</strong>。因为当需要扩展字符串时，在行中无法进行扩展，所以<strong>固定长度的数据类型更适合以写入为主的系统</strong>。但因为这种类型的<strong>存储消耗不是最优的，所以在读取数据时可能要付出更多的代价</strong>。<br>名称中含有VAR元素的数据类型是可变长度的(VARCHAR, NVARCHAR)，SQL Server在行中会按字符串的实际长度来保存数据，<strong>外加两个额外的字节以保存数据的偏移值（o）</strong>。例如，如果将一个列定义为VARCHAR(25)，意味着它应该<strong>最多支持25个字符</strong>，在实际使用中，<strong>存储空间由实际的字符数量决定</strong>。与固定长度类型相比，<strong>可变长度类型小号的存储空间更少</strong>，所以<strong>读操作</strong>会更快。但是，<strong>更新数据时可能需要对行进行扩展，导致数据移动，超出当前页的范围，因此更新效率有所降低</strong>。<br>在定义可变长度的数据类型时，可以使用<strong>MAX说明符</strong>，而<strong>不必指定字符的最大数量</strong>。当使用MAX说明符（<code>VARCHAR(MAX)</code>）时，可以把一个值直接保存到行的内部，<strong>长度具有一定上限（默认8000字节）</strong>。<strong>大小超过该上限的值将作为大型对象（LOB, Large OBject），保存在行的外部</strong>。</p>
<hr>
<p><strong>引号分隔的标识符</strong><br>在标准SQL中，单引号<code>&#39;&#39;</code>用于分隔文字字符串，<strong>如果单引号是文字字符串的一部分，则需要两个单引号表示</strong>。如字符串abc’de，应该写成<code>abc&#39;&#39;de&#39;</code>;</p>
<p><strong>双引号<code>&quot;&quot;</code><strong>用于分隔</strong>不规则的标识符</strong>（表名或列名包含<strong>空格</strong>或<strong>以数字开头</strong>（Java标识符只能以字母、下划线<code>_</code>、<code>$</code>开头，因此，尽量多语言保持统一））。在SQL Server中，有一个QUOTED_INDENTIFIER的设置选项，用于控制双引号的含义。可以在<strong>数据库级</strong>应用这个设置选项（ALTER DATABASE命令），也可以在会话级应用这个设置选项（SET命令）。当打开这个设置时，双引号的作用符合标准SQL的规定，仅用于分隔标识符。<strong>强烈建议遵循该标准SQL规定</strong>，大多数数据库接口（包括OLEDB和ODBC）都默认将该选项设置为ON。（<strong>SQL Server还支持用方括号<code>[]</code>作为分隔符</strong>）。</p>
<hr>
<h4 id="运算符和函数"><a href="#运算符和函数" class="headerlink" title="运算符和函数"></a>运算符和函数</h4><h5 id="字符串串联运算符（加号-）"><a href="#字符串串联运算符（加号-）" class="headerlink" title="字符串串联运算符（加号+）"></a>字符串串联运算符（加号+）</h5><p>T-SQL提供了加号<code>+</code>运算符，可以<strong>将两个或多个字符串合并或串联成一个字符串</strong>。<br>例如，以下对Employees表的查询将雇员的firstName列、一个空格，以及lastName列串联，生成完整的姓名fullName列：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> empId<span class="token punctuation">,</span> firstName <span class="token operator">+</span> N<span class="token string">' '</span> <span class="token operator">+</span> lastName <span class="token keyword">AS</span> fullName
<span class="token keyword">FROM</span> HR<span class="token punctuation">.</span>Employees<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>ANSI SQL规定<strong>对NULL值执行字符串串联运算，也会产生NULL值的结果</strong>。<strong>要用空字符串来替换NULL，可以使用COALESCE函数</strong>。<strong>该函数接受一系列参数，返回其中第一个不为NULL的值</strong>。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> custId<span class="token punctuation">,</span> country<span class="token punctuation">,</span> region<span class="token punctuation">,</span> city<span class="token punctuation">,</span>
	country <span class="token operator">+</span> N<span class="token string">', '</span> <span class="token operator">+</span> <span class="token keyword">COALESCE</span><span class="token punctuation">(</span>region<span class="token punctuation">,</span> N<span class="token string">''</span><span class="token punctuation">)</span> <span class="token operator">+</span> N<span class="token string">','</span> <span class="token operator">+</span> city <span class="token keyword">AS</span> location
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Customers<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<hr>
<h5 id="SUBSTRING-函数"><a href="#SUBSTRING-函数" class="headerlink" title="SUBSTRING 函数"></a>SUBSTRING 函数</h5><p>SUBSTRING函数用于从字符串中提取子串。<br><code>SUBSTRING(string, start, length)</code><br>该函数提取<strong>从指定位置开始，指定长度</strong>的子字符串。例如如下代码返回字符串<code>abc</code>：<br><code>SELECT SUBSTRING(&#39;abcde&#39;, 1, 3);</code></p>
<p>如果第二个参数和第三个参数的和<strong>超过了输入字符串的长度</strong>，则返回<strong>从起始位置开始直到字符串结尾</strong>的子字符串，不会引发错误。</p>
<hr>
<h5 id="LEFT-和-RIGHT-函数"><a href="#LEFT-和-RIGHT-函数" class="headerlink" title="LEFT 和 RIGHT 函数"></a>LEFT 和 RIGHT 函数</h5><p>LEFT 和 RIGHT 函数是<strong>SUBSTRING 函数的简略形式</strong>，它们分别返回字符串中<strong>从左边或右边开始，指定长度</strong>的子字符串。<br><code>LEFT(string, length), RIGHT(string, length)</code><br>例如如下代码返回字符串’cde’：</p>
<p><code>SELECT RIGHT(&#39;abcde&#39;, 3);</code></p>
<hr>
<h5 id="LEN-和-DATALENGTH-函数"><a href="#LEN-和-DATALENGTH-函数" class="headerlink" title="LEN 和 DATALENGTH 函数"></a>LEN 和 DATALENGTH 函数</h5><p>LEN函数返回字符串的长度，该函数返回的是<strong>字符数，而不一定是其字节数</strong>。如果<strong>要得到字节数</strong>，则应该使用DATALENGTH函数。<br>LEN和DATALENGTH函数的另一个区别是：前者<strong>不包含尾随空格（开头或中间的空格都会被计算）</strong>，而后者包含。</p>
<ul>
<li>在<strong>排序规则为Chinese_PRC_CI_AS等规则</strong>时，用DATALENGTH函数获取VARCHAR类型的字符数据时，<strong>会根据字符实际属于普通字符还是Unicode字符来返回字节数</strong>。</li>
</ul>
<hr>
<h5 id="CHARINDEX-函数"><a href="#CHARINDEX-函数" class="headerlink" title="CHARINDEX 函数"></a>CHARINDEX 函数</h5><p>CHARINDEX 函数返回<strong>字符串中某个子串第一次出现的起始位置</strong>。<br><code>CHARINDEX(substring, string [, start_pos])</code><br>该函数<strong>在第二个参数中搜索第一个参数，并返回其起始位置</strong>。<strong>可以选择性地指定第三个参数，以便告诉这个函数从字符串的什么位置开始搜索，如果未指定，则从字符串的第一个字符开始搜索</strong>。<br><strong>如果在string中找不到substring，则CHARINDEX返回0</strong>。例如，以下代码在’Itzik Ben-Gan’中查找第一个空格的位置，结果将返回6：</p>
<p><code>SELECT CHARINDEX(&#39; &#39;, &#39;Itzik Ben-Gan&#39;);</code></p>
<hr>
<h5 id="PATINDEX-函数"><a href="#PATINDEX-函数" class="headerlink" title="PATINDEX 函数"></a>PATINDEX 函数</h5><p>PATINDEX函数返回<strong>字符串中某个模式第一次出现的起始位置</strong>。<br><code>PATINDEX(pattern, string)</code><br><strong>参数pattern使用的模式与T-SQL中LIKE谓词使用的模式类似</strong>，目前还没有解释在T-SQL中如何表示模式，先用以下例子演示怎么在字符串中找到<strong>第一次出现数字的位置</strong>：<br><code>SELECT PATINDEX(&#39;%[0-9]%&#39;, &#39;abcd123efgh&#39;);</code></p>
<p>这段代码返回的结果是5。</p>
<hr>
<h5 id="REPLACE-函数"><a href="#REPLACE-函数" class="headerlink" title="REPLACE 函数"></a>REPLACE 函数</h5><p>REPLACE函数将字符串中出现的<strong>所有某个子串替换为另一个字符串</strong>。<br><code>REPLACE(string, substring1, substring2)</code></p>
<p>可以使用REPLACE函数来<strong>计算字符串中某个字符出现的次数</strong>。为此，先将字符串中所有的那个字符串<strong>替换为空字符串</strong>，再<strong>计算字符串的原始长度和新长度的差值</strong>。例如，以下查询返回每个雇员的lastName列中字符’e’出现的次数：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> empId<span class="token punctuation">,</span> lastName<span class="token punctuation">,</span>
	<span class="token function">LEN</span><span class="token punctuation">(</span>lastName<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">LEN</span><span class="token punctuation">(</span><span class="token keyword">REPLACE</span><span class="token punctuation">(</span>lastName<span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> numOccur
<span class="token keyword">FROM</span> HR<span class="token punctuation">.</span>Employees<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<hr>
<h5 id="REPLICATE-函数"><a href="#REPLICATE-函数" class="headerlink" title="REPLICATE 函数"></a>REPLICATE 函数</h5><p>REPLICATE函数<strong>以指定的次数复制字符串值</strong>。<br><code>REPLICATE(string, n)</code><br>例如，以下代码将字符串’abc’复制3次，返回字符串’abcabcabc’：<br><code>SELECT REPLICATE(&#39;abc&#39;, 3);</code><br>下面这个例子显示了<strong>REPLICATE函数、RIGHT函数和字符串串联的用法</strong>：<br>对Production.Suppliers的查询为每个供应商的整数ID生成一个10位数的字符串表示（**不足10位时，前面补0）：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> supplierId<span class="token punctuation">,</span>
	<span class="token keyword">RIGHT</span><span class="token punctuation">(</span>REPLICATE<span class="token punctuation">(</span><span class="token string">'0'</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token operator">+</span> CAST<span class="token punctuation">(</span>supplierId <span class="token keyword">AS</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> strSupplierId
<span class="token keyword">FROM</span> Production<span class="token punctuation">.</span>Suppliers<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/slove_cao/article/details/1915971">CAST 和 CONVERT 函数的区别</a></p>
<hr>
<h5 id="STUFF-函数"><a href="#STUFF-函数" class="headerlink" title="STUFF 函数"></a>STUFF 函数</h5><p>STUFF函数可以先<strong>删除字符串中指定长度的子串</strong>，<strong>再插入一个新的字符串</strong>作为替换。<br><code>STUFF(string, pos, delete_length, insertString)</code><br>从参数pos指定的位置开始删除delete_length长度的字符，然后将insertString参数指定的字符串插入到pos指定的位置。例如，以下代码对字符串’xyz’进行处理，删除掉其中的第二个字符，再插入字符串’abc’：<br><code>SELECT STUFF(&#39;xyz&#39;, 2, 1, &#39;abc&#39;);</code></p>
<p>这段代码的输出是’xabcz’。</p>
<hr>
<h5 id="UPPER-和-LOWER-函数"><a href="#UPPER-和-LOWER-函数" class="headerlink" title="UPPER 和 LOWER 函数"></a>UPPER 和 LOWER 函数</h5><h5 id="RTRIM-和-LTRIM-函数"><a href="#RTRIM-和-LTRIM-函数" class="headerlink" title="RTRIM 和 LTRIM 函数"></a>RTRIM 和 LTRIM 函数</h5><p>RTRIM 和 LTRIM 函数用于删除字符串中的<strong>尾随空格</strong>或<strong>前导空格</strong>。</p>
<p><code>RTRIM(string), LTRIM(string)</code></p>
<hr>
<h4 id="LIKE-谓词"><a href="#LIKE-谓词" class="headerlink" title="LIKE 谓词"></a>LIKE 谓词</h4><p>T-SQL提供了LIKE谓词，用于<strong>检查字符串是否能够匹配指定的模式</strong>。</p>
<h5 id="通配符-wildCard"><a href="#通配符-wildCard" class="headerlink" title="通配符 wildCard"></a>通配符 wildCard</h5><ul>
<li><code>%</code>（百分号）通配符</li>
<li><code>_</code>（下划线）通配符</li>
<li><strong><code>[&lt;字符列&gt;]</code>通配符</strong><br>  方括号中包含<strong>一列字符</strong>（例如’[ABC]’），表示<strong>必须匹配列指定字符中的一个字符</strong>。<br>  例如，以下查询返回lastName<strong>以字符A、B、C开头的所有雇员</strong>：  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> empId<span class="token punctuation">,</span> lastName
<span class="token keyword">FROM</span> HR<span class="token punctuation">.</span>Employees
<span class="token keyword">WHERE</span> lastName <span class="token operator">LIKE</span> N<span class="token string">'[ABC]%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li><strong><code>[&lt;字符&gt;-&lt;字符&gt;]</code>通配符</strong><br>  方括号中包含<strong>一个字符范围</strong>（例如’[A-E]’），表示<strong>必须匹配指定范围内的一个字符</strong>。<br>  例如，以下查询返回lastName<strong>以字符A到E开头的所有雇员</strong>：  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> empId<span class="token punctuation">,</span> lastName
<span class="token keyword">FROM</span> HR<span class="token punctuation">.</span>Employees
<span class="token keyword">WHERE</span> lastName <span class="token operator">LIKE</span> N<span class="token string">'[A-E]%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li><strong><code>[^&lt;字符列或范围&gt;]</code>通配符</strong><br>  方括号中包含一个<strong>插入符<code>^</code>，跟着一个字符列或范围</strong>（例如’[^A-E]’），表示<strong>不属于</strong>指定字符列或范围内的任意单个字符。<br>  例如，以下查询返回lastName<strong>不是以字符A到E开头的所有雇员</strong>：  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> empId<span class="token punctuation">,</span> lastName
<span class="token keyword">FROM</span> HR<span class="token punctuation">.</span>Employees
<span class="token keyword">WHERE</span> lastName <span class="token operator">LIKE</span> N<span class="token string">'[^A-E]%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li><strong>ESCAPE（转义）字符</strong><br>如果想搜索<strong>包含特殊通配符的字符串</strong>（如<code>%</code>、<code>_</code>、<code>[</code>、<code>]</code>），则必须使用<strong>转义字符</strong>。<strong>指定一个确保不会在数据中出现的字符作为转义字符，把它放在待查找的字符串前面，并紧接着模式字符串，在ESCAPE关键字后面指定该转义字符</strong>。例如，要检查一个名为col1的列中<strong>是否包含下划线</strong>，可以使用<code>col1 LIKE &#39;%!_%&#39; ESCAPE &#39;!&#39;</code>。<br>另外，对于<strong>通配符<code>%</code>、<code>_</code>、<code>[</code></strong>，可以把它们<strong>放在方括号内而不必使用转义字符</strong>。例如：<code>col1 LIKE &#39;%[_]%&#39;</code>。</li>
</ul>
<hr>
<h3 id="处理日期和时间数据"><a href="#处理日期和时间数据" class="headerlink" title="处理日期和时间数据"></a>处理日期和时间数据</h3><h4 id="日期和时间数据类型"><a href="#日期和时间数据类型" class="headerlink" title="日期和时间数据类型"></a>日期和时间数据类型</h4><p>在SQL Server 2008之前，SQL Server支持两种表示时间的数据类型：<strong>DATETIME 和 SMALLDATETIME。这两种类型都包括了日期和时间组成部分，而且这两部分是不能分开的</strong>。SQL Server 2008引入了单独的DATE和TIME数据类型：</p>
<ul>
<li>DATETIME2——比DATETIME具有<strong>更大的日期范围和更好的精度</strong></li>
<li>DATETIMEOFFSET：具有一个<strong>时区</strong>组成部分</li>
</ul>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>存储大小（B）</th>
<th>日期范围</th>
<th>准确度</th>
<th>推荐格式</th>
</tr>
</thead>
<tbody><tr>
<td>DATETIME</td>
<td>8</td>
<td>1753-01-01 到 9999-12-31</td>
<td>3.33毫秒</td>
<td>‘YYYYMMDD hh:mm:ss.nnn’</td>
</tr>
<tr>
<td>SMALLDATETIME</td>
<td>4</td>
<td>1900-01-01 到 2079-06-06</td>
<td>1分钟</td>
<td>‘YYYYMMDD hh:mm’</td>
</tr>
<tr>
<td>DATE</td>
<td>3</td>
<td>0001-01-01 到 9999-12-31</td>
<td>1天</td>
<td>‘YYYY-MM-DD’</td>
</tr>
<tr>
<td>TIME</td>
<td>3 到 5</td>
<td>00:00:00.0000000 到 23:59.59.9999999</td>
<td>100纳秒</td>
<td>‘hh:mm:ss.nnnnnnn’</td>
</tr>
<tr>
<td>DATETIME2</td>
<td>6 到 8</td>
<td>0001-01-01 00:00:00.0000000 到 9999-12-31 23:59:59.9999999</td>
<td></td>
<td>100纳秒</td>
</tr>
<tr>
<td>DATETIMEOFFSET</td>
<td>8 到 10</td>
<td>0001-01-01 00:00:00.0000000 到 9999-12-31 23:59:59.9999999</td>
<td>100纳秒</td>
<td>‘YYYY-MM-DD hh:mm:ss.nnnnnnn [+</td>
</tr>
</tbody></table>
<p>TIME、DATETIME2以及DATETIMEOFFSET的存储空间大小依赖于所选择的精度。可以通过0-7之间的整数来指定精度，分别代表<strong>不同小数位数的秒值的精度</strong>。例如<code>TIME(0)</code>，<strong>SQL Server默认将精度设置为7</strong>。</p>
<hr>
<h4 id="字符串文字"><a href="#字符串文字" class="headerlink" title="字符串文字"></a>字符串文字</h4><p><strong>SQL Server并没有提供表达日期和时间字符串的具体方法</strong>，它<strong>允许你指定不同类型的字符串文字，再将其（显式或隐式地）转换为相应的日期和时间数据类型</strong>：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> orderId<span class="token punctuation">,</span> custId<span class="token punctuation">,</span> empId<span class="token punctuation">,</span> orderDate
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders
<span class="token keyword">WHERE</span> orderDate <span class="token operator">=</span> <span class="token string">'20070212'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>隐式转换规则并不总是这么简单，其实<strong>在过滤器条件和其他表达式中应用的规则是不同的</strong>，当前处于讨论的目的，先让事情简单些。<br>强烈建议<strong>按照语言无关的方式</strong>来编写日期和时间字符串文字，这样SQL Server才能以相同的方式加以解释，而不受语言相关设置的影响。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>语言中立的格式</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>DATETIME</td>
<td>‘YYYYMMDD hh:mm:ss.nnn’ ‘YYYY-MM-DDThh:mm:ss.nnn’ <br />‘YYYYMMDD’</td>
<td>‘20090212 12:30:15.123’ <br />‘2009-02-12t12:30:15.123’ <br />‘20090212’</td>
</tr>
<tr>
<td>SMALLDATETIME</td>
<td>‘YYYYMMDD hh:mm’<br />‘YYYY-MM-DDThh:mm’<br />‘YYYYMMDD’</td>
<td>‘20090212 12:30’ <br />‘2009-02-12T12:30’ <br />‘20090212’</td>
</tr>
<tr>
<td>DATE</td>
<td>‘YYYYMMDD’<br />‘YYYY-MM-DD’</td>
<td>‘20090212’<br />‘2009-02-12’</td>
</tr>
<tr>
<td>DATETIME2</td>
<td>‘YYYYMMDD hh:mm:ss.nnnnnnnnn’<br />‘YYYY-MM-DD hh:mm:ss.nnnnnnnnn’<br />‘YYYY-MM-DDThh:mm:ss.nnnnnnnnn’<br />‘YYYYMMDD’<br />‘YYYY-MM-DD’</td>
<td>‘20090212 12:30:15.1234567’ <br />‘2009-02-12 12:30:15.1234567’ <br />‘2009-02-12T12:30:15.1234567’ <br />‘20090212 ‘<br />‘2009-02-12’</td>
</tr>
<tr>
<td>DATETIMEOFFSET</td>
<td>‘YYYYMMDD hh:mm:ss.nnnnnnnnn [+|-]hh:mm’<br /> ‘YYYYMMDD’<br /> ‘YYYY-MM-DD’</td>
<td>‘20090212 12:30:15.1234567 +02:00’ <br />‘2009-02-12 12:30:15.1234567 +02:00’ <br />‘20090212 ‘<br />‘2009-02-12’</td>
</tr>
<tr>
<td>TIME</td>
<td>‘hh:mm:ss.nnnnnnn’</td>
<td>‘12:30:15.1234567’</td>
</tr>
</tbody></table>
<p> 有两点要注意，对于所有<strong>包括日期和时间组成部分</strong>的类型，<strong>如果不在字符串文字中指定时间，SQL Server会默认将时间设置为午夜</strong>。如果不指定时区，SQL Server将采用00:00。<br>此外，要<strong>重点注意’YYYY-MM-DD’和’YYYY-MM-DD hh:mm…’格式</strong>，当转换到<strong>DATETIME</strong>或<strong>SMALLDATETIME</strong>类型时，它们是<strong>语言相关</strong>的；当转换到<strong>DATE、DATETIME2以及DATETIMEOFFSET</strong>时，它们是<strong>语言无关</strong>的。<br>例如，以下代码中，语言设置对于以’YYYYMMDD’格式表示的字符串文字如何转换为DATETIME类型的数据没有影响：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SET</span> <span class="token keyword">LANGUAGE</span> British<span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> CAST<span class="token punctuation">(</span><span class="token string">'20070212'</span> <span class="token keyword">AS</span> <span class="token keyword">DATETIME</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">SET</span> <span class="token keyword">LANGUAGE</span> us_english<span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> CAST<span class="token punctuation">(</span><span class="token string">'20070212'</span> <span class="token keyword">AS</span> <span class="token keyword">DATETIME</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>优先使用类似’YYYYMMDD’这样语言无关的格式，再怎么强调也不为过</strong>。<br>如果你<strong>坚持要用与语言相关的格式来表示日期和时间字符串文字</strong>，则可以使用<strong>CONVERT函数</strong>，在它的第3个参数中<strong>指定一个表示正在使用的样式的数字，显式地将字符串文字转换成想要的数据类型</strong>。样式数字和各自代表的格式见：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wangjiming/p/7352256.html">【Sqlserver系列】CAST和CONVERT</a>。<br>例如，想指定字符串文字’02&#x2F;12&#x2F;2007’的格式为mm&#x2F;dd&#x2F;yyyy，可以使用样式号101，如果想采用dd&#x2F;mm&#x2F;yyyy的格式，可以使用样式号103：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">CONVERT</span><span class="token punctuation">(</span><span class="token keyword">DATETIME</span><span class="token punctuation">,</span> <span class="token string">'02/12/2007'</span><span class="token punctuation">,</span> <span class="token number">101</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">-- 按指定格式解读，转换成YYYY-MM-DD hh:mm...的格式</span>
<span class="token keyword">SELECT</span> <span class="token keyword">CONVERT</span><span class="token punctuation">(</span><span class="token keyword">DATETIME</span><span class="token punctuation">,</span> <span class="token string">'02/12/2007'</span><span class="token punctuation">,</span> <span class="token number">103</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<hr>
<h4 id="单独使用日期和时间"><a href="#单独使用日期和时间" class="headerlink" title="单独使用日期和时间"></a>单独使用日期和时间</h4><p>SQL Server 2008引入了<strong>可以单独使用日期和时间部分的数据类型</strong>，但在前面的讨论中还没有区分这两部分。如果要在SQL Server 2008之前的版本中只是用日期或时间，只能选用同时包含这两种组成部分的DATETIME或SMALLDATETIME数据类型之一。在要实现日期和时间逻辑的地方，也可以使用整数或字符串之类的数据类型，但此处不讨论这种用法。如果选用DATETIME或SMALLDATETIME类型，当<strong>只使用日期数据时</strong>，保存数据的时间将是<strong>午夜零点</strong>；当<strong>只使用时间数据时</strong>，保存数据的日期值将是<strong>基础日期1900年1月1日</strong>。<br>例如Sales.Orders表的orderdate列是DATETIME类型的，<strong>但由于实际只使用日期部分，所以所有值的时间都存储成午夜了</strong>。当需要筛选特定日期的订单时，<strong>可以不使用范围过滤条件，只用等号运算符即可</strong>：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> orderId<span class="token punctuation">,</span> custId<span class="token punctuation">,</span> empId<span class="token punctuation">,</span> orderDate
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders
<span class="token keyword">WHERE</span> orderDate <span class="token operator">=</span> <span class="token string">'20070212'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>如果想在SQL Server 2008之前的版本中只使用时间，则可以用基础日期1900年1月1日来存储所有时间值。当SQL Server把<strong>只包含时间值的字符串文字转换成DATETIME或SMALLDATETIME类型时，它会默认使用基础日期</strong>。<br>如果输入值既包括日期也包括时间，当只想使用日期时，就把时间部分设置成午夜；如果只想使用时间，就把日期部分设置成基础日期。在后面的<strong>日期和时间函数</strong>一节中，将会介绍实现这种效果的一种简单方法。</p>
<hr>
<h4 id="过滤日期范围"><a href="#过滤日期范围" class="headerlink" title="过滤日期范围"></a>过滤日期范围</h4><p>如果要过滤日期范围（比如，整年或整月），比较自然的方法就是使用YEAR和MONTH之类的函数。不过<strong>要小心一点</strong>，在<strong>大多数情况下</strong>，对<strong>过滤条件中的列</strong>应用了一定的处理后，就<strong>不能以有效的方式来使用索引了</strong>，相关主题超出了当前的讨论范围。但就目前而言，只要记住以下通用原则：<strong>为了潜在地有效利用索引，就需要对谓词进行调整，而不对过滤条件中的列进行处理</strong>。<br>例如：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> orderId<span class="token punctuation">,</span> custId<span class="token punctuation">,</span> empId<span class="token punctuation">,</span> orderDate
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders
<span class="token keyword">WHERE</span> orderDate <span class="token operator">>=</span> <span class="token string">'20070101'</span> <span class="token operator">AND</span> orderDate <span class="token operator">&lt;</span> <span class="token string">'20080101'</span><span class="token punctuation">;</span> <span class="token comment">-- 筛选2007年的所有订单</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>类似地，<strong>不应该使用函数来过滤某个月生成的订单</strong>，如下所示：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> orderId<span class="token punctuation">,</span> custId<span class="token punctuation">,</span> empId<span class="token punctuation">,</span> orderDate
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders
<span class="token keyword">WHERE</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>orderDate<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2007</span> <span class="token operator">AND</span> <span class="token keyword">MONTH</span><span class="token punctuation">(</span>orderDate<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>而<strong>应该使用一个范围过滤条件</strong>：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> orderId<span class="token punctuation">,</span> custId<span class="token punctuation">,</span> empId<span class="token punctuation">,</span> orderDate
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders
<span class="token keyword">WHERE</span> orderDate <span class="token operator">>=</span> <span class="token string">'20070201'</span> <span class="token operator">AND</span> orderDate <span class="token operator">&lt;</span> <span class="token string">'20070301'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<hr>
<h4 id="日期和时间函数"><a href="#日期和时间函数" class="headerlink" title="日期和时间函数"></a>日期和时间函数</h4><p>以下不带参数的函数可以返回SQL Server实例所在系统的当前日期和时间：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>返回类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>GETDATE</td>
<td>DATETIME</td>
<td>当前日期<strong>和时间</strong></td>
</tr>
<tr>
<td>CURRENT_TIMESTAMP</td>
<td>DATETIME</td>
<td>与GETDATE相同，<strong>而且是ANSI SQL</strong></td>
</tr>
<tr>
<td>GETUTCDATE</td>
<td>DATETIME</td>
<td>以UTC格式表示的当前日期和时间</td>
</tr>
<tr>
<td>SYSDATETIME</td>
<td>DATETIME2</td>
<td>当前日期和时间</td>
</tr>
<tr>
<td>SYSUTCDATETIME</td>
<td>DATETIME2</td>
<td>以UTC格式表示的当前日期和时间</td>
</tr>
<tr>
<td>SYSDATETIMEOFFSET</td>
<td>DATETIMEOFFSET</td>
<td>当前日期和时间，包含时区偏移量</td>
</tr>
</tbody></table>
<p><strong>除了ANSI函数CURRENT_TIMESTAMP之外，不需要参数的函数在调用时都必须多加一对空的圆括号<code>()</code></strong>。此外，因为<strong>CURRENT_TIMESTAMP和GETDATE返回的内容相同，但前者是标准SQL，所以推荐优先选用CURRENT_TIMESTAMP</strong>。<br>以下代码演示了取得当前日期和时间函数的用法：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> 
	GETDATE<span class="token punctuation">(</span><span class="token punctuation">)</span>		<span class="token keyword">AS</span> <span class="token string">"GETDATE"</span><span class="token punctuation">,</span>
	<span class="token keyword">CURRENT_TIMESTAMP</span>	<span class="token keyword">AS</span> <span class="token string">"CURRENT_TIMESTAMP"</span><span class="token punctuation">,</span>
	GETUTCDATE<span class="token punctuation">(</span><span class="token punctuation">)</span>		<span class="token keyword">AS</span> <span class="token string">"GETUTCDATE"</span><span class="token punctuation">,</span>
	SYSDATETIME<span class="token punctuation">(</span><span class="token punctuation">)</span>		<span class="token keyword">AS</span> <span class="token string">"SYSDATETIME"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h5 id="CAST-和-CONVERT-函数"><a href="#CAST-和-CONVERT-函数" class="headerlink" title="CAST 和 CONVERT 函数"></a>CAST 和 CONVERT 函数</h5><p>CAST 和 CONVERT 函数用于转换值的数据类型。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CAST<span class="token punctuation">(</span><span class="token keyword">value</span> <span class="token keyword">AS</span> dataType<span class="token punctuation">)</span>
<span class="token keyword">CONVERT</span><span class="token punctuation">(</span>dataType<span class="token punctuation">,</span> <span class="token keyword">value</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> style_number<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p> 这两个函数都可以<strong>将输入的值转换为指定的数据类型</strong>。在一些情况下，还能用CONVERT提供的第三个参数来指定转换的样式（<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wangjiming/p/7352256.html">【Sqlserver系列】CAST和CONVERT</a>）。<br> 接下来用几个例子来演示如何用CAST和CONVERT函数来处理日期和时间数据类型。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> CAST<span class="token punctuation">(</span><span class="token string">'20090212'</span> <span class="token keyword">AS</span> <span class="token keyword">DATE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> CAST<span class="token punctuation">(</span>SYSDATETIME<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token keyword">DATE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> CAST<span class="token punctuation">(</span>SYSDATETIME<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token keyword">TIME</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">-- 使用样式值112('YYYYMMDD')，把当前日期和时间值转换为CHAR(8)，再转换回DATETIME类型时，得到的当前日期的时间部分将是零点</span>
<span class="token keyword">SELECT</span> CAST<span class="token punctuation">(</span><span class="token keyword">CONVERT</span><span class="token punctuation">(</span><span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">,</span> <span class="token number">112</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token keyword">DATETIME</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

<span class="token comment">-- 使用样式值114('hh:mm:ss.nnn')，把当前日期和时间值转换为CHAR(12)，再转换回DATETIME类型时，得到的当前时间的日期部分将是基础日期</span>
<span class="token keyword">SELECT</span> CAST<span class="token punctuation">(</span><span class="token keyword">CONVERT</span><span class="token punctuation">(</span><span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">,</span> <span class="token number">114</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token keyword">DATETIME</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h5 id="DATEADD-函数"><a href="#DATEADD-函数" class="headerlink" title="DATEADD 函数"></a>DATEADD 函数</h5><p>DATEADD 函数可以将指定日期的部分作为单位，为输入的日期和时间值<strong>增加指定的数量（可以增加负数）</strong>。<br><code>DATEADD(part, number, dt_val)</code></p>
<table>
<thead>
<tr>
<th>part</th>
<th>缩写</th>
</tr>
</thead>
<tbody><tr>
<td>year</td>
<td>yy, yyyy</td>
</tr>
<tr>
<td>quarter</td>
<td>qq, q</td>
</tr>
<tr>
<td>month</td>
<td>mm, m</td>
</tr>
<tr>
<td>dayofyear</td>
<td>dy, y</td>
</tr>
<tr>
<td>day</td>
<td>dd, d</td>
</tr>
<tr>
<td>week</td>
<td>wk, ww</td>
</tr>
<tr>
<td>weekday</td>
<td>dw, w</td>
</tr>
<tr>
<td>hour</td>
<td>hh</td>
</tr>
<tr>
<td>minute</td>
<td>mi, n</td>
</tr>
<tr>
<td>second</td>
<td>ss, s</td>
</tr>
<tr>
<td>millisecond</td>
<td>ms</td>
</tr>
<tr>
<td>microsecond</td>
<td>mcs</td>
</tr>
<tr>
<td>nanosecond</td>
<td>ns</td>
</tr>
</tbody></table>
<p>该函数返回值的类型<strong>与输入的日期和时间值的类型相同</strong>。如果输入的是一个<strong>字符串文字</strong>，输出的则是<strong>DATETIME</strong>。</p>
<p>例如：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> DATEADD<span class="token punctuation">(</span><span class="token keyword">year</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'20090212'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>返回的结果为<strong>DATETIME格式</strong>：<code>2010-02-12 00:00:00.000</code></p>
<hr>
<h5 id="DATEDIFF函数"><a href="#DATEDIFF函数" class="headerlink" title="DATEDIFF函数"></a>DATEDIFF函数</h5><p>DATEDIFF返回<strong>后一个日期和时间值 - 前一个日期和时间值的指定部分的计数</strong>。</p>
<p><code>DATEDIFF(part, dt_vall, dt_val2)</code></p>
<p>例如，以下代码返回两个值之间相差的天数</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> DATEDIFF<span class="token punctuation">(</span>dd<span class="token punctuation">,</span> <span class="token string">'20080212'</span><span class="token punctuation">,</span> <span class="token string">'20090212'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">-- 返回的输出是366</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在SQL Server 2008之前的版本中，可以用以下代码<strong>将当前系统日期和时间值中的时间部分设置为午夜</strong>：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> DATEADD<span class="token punctuation">(</span>dd<span class="token punctuation">,</span> DATEDIFF<span class="token punctuation">(</span>dd<span class="token punctuation">,</span> <span class="token string">'20010101'</span><span class="token punctuation">,</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'20010101'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这段代码首先用DATEDIFF函数计算一个<strong>锚点日期的午夜值</strong>与当前日期和时间之间<strong>相差的总天数</strong>。接着，再用DATEADD函数为锚点日期增加上一步得到的天数。这样就可以得到当前系统日期在午夜的时间值。</p>
<p>有趣的是，如果在这个表达式中用month取代day来作为计数单位，并确保<strong>使用的锚点日期是某个月（任意年份和月份）的第一天</strong>，最后得到的结果将是<strong>当前月份的第一天</strong>：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> DATEADD<span class="token punctuation">(</span>mm<span class="token punctuation">,</span> DATEDIFF<span class="token punctuation">(</span>mm<span class="token punctuation">,</span> <span class="token string">'20010101'</span><span class="token punctuation">,</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'20010101'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>类似地，用year作为计数单位，并用<strong>某年的第一天作为锚点</strong>日期，最后得到的将是<strong>当前年的第一天</strong>。如果想要得到<strong>当前月或当前年的最后一天，只要简单地把锚点日期修改为月或年的最后一天（注意要选择月份最后一天为31天的日期，这样才能正确得到任意月份的最后一天）</strong>。例如：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> DATEADD<span class="token punctuation">(</span>mm<span class="token punctuation">,</span> DATEDIFF<span class="token punctuation">(</span>mm<span class="token punctuation">,</span> <span class="token string">'19991231'</span><span class="token punctuation">,</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'19991231'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<hr>
<h5 id="DATEPART-函数"><a href="#DATEPART-函数" class="headerlink" title="DATEPART 函数"></a>DATEPART 函数</h5><p>DATEPART函数返回一个表示给定日期和时间值的<strong>指定部分</strong>的<strong>整数</strong>。</p>
<p>以下代码返回输入值的月份部分：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> DATEPART<span class="token punctuation">(</span>mm<span class="token punctuation">,</span> <span class="token string">'20210626'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">-- 返回整数2，而不是02</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<hr>
<h5 id="YEAR、MONTH-和-DAY-函数"><a href="#YEAR、MONTH-和-DAY-函数" class="headerlink" title="YEAR、MONTH 和 DAY 函数"></a>YEAR、MONTH 和 DAY 函数</h5><p>YEAR、MONTH 和 DAY 函数<strong>是DATEPART函数的简略版本</strong>。</p>
<ul>
<li><code>YEAR(dt_val)</code></li>
<li><code>MONTH(dt_val)</code></li>
<li><code>DAY(dt_val)</code></li>
</ul>
<hr>
<h5 id="DATENAME-函数"><a href="#DATENAME-函数" class="headerlink" title="DATENAME 函数"></a>DATENAME 函数</h5><p>DATENAME 函数返回一个表示给定日期和时间值的<strong>指定部分</strong>的<strong>字符串（这是依赖语言的）</strong>。</p>
<p><code>DATENAME(part, dt_val)</code></p>
<p><strong>如果请求的部分没有名称，只是一个数字值（比如年份），则DATENAME函数将它的数字值作为字符串而返回</strong>。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> DATENAME<span class="token punctuation">(</span>mm<span class="token punctuation">,</span> <span class="token string">'20210626'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">-- 如果当前会话的语言是某种英语（us_english, British），函数调用的返回值将是'February'，默认的中文环境下会返回数字值**06**</span>
<span class="token keyword">SELECT</span> DATENAME<span class="token punctuation">(</span>yy<span class="token punctuation">,</span> <span class="token string">'20210626'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">-- 返回2021</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<hr>
<h5 id="ISDATE函数"><a href="#ISDATE函数" class="headerlink" title="ISDATE函数"></a>ISDATE函数</h5><p>ISDATE接受一个字符串作为输入，<strong>如果能把这个字符串转换为日期和时间数据类型的值，则返回1；否则返回0</strong>。</p>
<p><code>ISDATE(string)</code></p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> ISDATE<span class="token punctuation">(</span><span class="token string">'20210627'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">-- 返回1</span>
<span class="token keyword">SELECT</span> ISDATE<span class="token punctuation">(</span><span class="token string">'20210229'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">-- 返回0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<hr>
<h3 id="查询元数据"><a href="#查询元数据" class="headerlink" title="查询元数据"></a>查询元数据</h3><p>SQL Server提供了用于<strong>获取数据库对象的元数据信息</strong>的工具，比如数据库中<strong>有什么表，表中有什么列</strong>等。这些工具包括<strong>目录视图（catalog view）、信息架构视图（information schema view）、系统存储过程和函数</strong>。这里不准备介绍很多细节，而只是针对每个元数据工具给出几个例子，能有一个感性的认识，帮助学习。</p>
<hr>
<h4 id="目录视图"><a href="#目录视图" class="headerlink" title="目录视图"></a>目录视图</h4><p>目录视图提供了关于数据库中<strong>各对象的非常详细的信息</strong>，包括SQL Server特定的信息。例如，如果想<strong>列出数据库中的各个表，以及它们的架构名称</strong>，按如下操作去查询<code>sys.tables</code>视图：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> TSQLFundamentals2008<span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> SCHEMA_NAME<span class="token punctuation">(</span>schema_id<span class="token punctuation">)</span> <span class="token keyword">AS</span> table_schema_name<span class="token punctuation">,</span> name <span class="token keyword">AS</span> table_name
<span class="token keyword">FROM</span> sys<span class="token punctuation">.</span><span class="token keyword">tables</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>此处用<strong>SCHEMA_NAME函数把架构ID转换成它的名称</strong>。</p>
<p>要得到有关<strong>某个表的列信息，可以查询sys.columns表</strong>。例如，以下代码返回Sales.Orders表中的列信息，包括<strong>列名、数据类型（用TYPE_NAME函数把系统类型ID转换成类型名称）、最大长度、排序规则名称，以及是否允许为NULL</strong>。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> name <span class="token keyword">AS</span> column_name<span class="token punctuation">,</span> TYPE_NAME<span class="token punctuation">(</span>system_type_id<span class="token punctuation">)</span> <span class="token keyword">AS</span> column_type<span class="token punctuation">,</span>
	   max_length<span class="token punctuation">,</span> collation_name<span class="token punctuation">,</span> is_nullable
<span class="token keyword">FROM</span> sys<span class="token punctuation">.</span><span class="token keyword">columns</span>
<span class="token keyword">WHERE</span> object_id <span class="token operator">=</span> OBJECT_ID<span class="token punctuation">(</span>N<span class="token string">'Sales.Orders'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>在SSMS中，使用<code>ALT</code>+<code>F1</code>的快捷键，<strong>可以获得更详细的数据库对象信息</strong>。</p>
<hr>
<h4 id="信息架构视图"><a href="#信息架构视图" class="headerlink" title="信息架构视图"></a>信息架构视图</h4><p>信息架构视图是<strong>位于INFORMATION_SCHEMA架构内的一组视图</strong>，它们<strong>以一种ANSI SQL标准的方式来提供元数据信息</strong>。</p>
<p>例如，以下对<strong>INFORMATION_SCHEMA.TABLES视图</strong>的查询可以列出<strong>当前数据库中的用户表，以及它们的架构名称</strong>：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> TABLE_SCHEMA<span class="token punctuation">,</span> TABLE_NAME
<span class="token keyword">FROM</span> INFORMATION_SCHEMA<span class="token punctuation">.</span><span class="token keyword">TABLES</span>
<span class="token keyword">WHERE</span> TABLE_TYPE <span class="token operator">=</span> <span class="token string">'BASE TABLE'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>以下对INFORMATION_SCHEMA.COLUMNS视图的查询提供了有关Sales.Orders表中各个列的绝大多数的可用信息：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> COLUMN_NAME<span class="token punctuation">,</span> DATA_TYPE<span class="token punctuation">,</span> CHARATER_MAXIMUM_LENGTH<span class="token punctuation">,</span>
	   COLLATION_NAME<span class="token punctuation">,</span> IS_NULLABLE
<span class="token keyword">FROM</span> INFORMATION_SCHEMA<span class="token punctuation">.</span><span class="token keyword">COLUMNS</span>
<span class="token keyword">WHERE</span> TABLE_SCHEMA <span class="token operator">=</span> <span class="token string">'Sales'</span>
	  <span class="token operator">AND</span> TABLE_NAME <span class="token operator">=</span> <span class="token string">'Orders'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这两个示例，达到了和<strong>上文目录视图示例相同的结果</strong>。</p>
<hr>
<h4 id="系统存储过程和函数"><a href="#系统存储过程和函数" class="headerlink" title="系统存储过程和函数"></a>系统存储过程和函数</h4><p>系统存储过程和函数是<strong>在其内部查询系统目录</strong>，并返回更加**”摘要化“<strong>的</strong>元数据信息**。</p>
<ul>
<li><p><strong>sp_tables</strong>存储过程返回可以在当前数据库中查询的<strong>对象（比如表和视图）列表</strong>：</p>
  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">EXEC</span> sys<span class="token punctuation">.</span>sp_tables<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p><strong>sp_help</strong>存储过程接受一个<strong>对象名称</strong>作为输入，返回与之相关的多个结果集，包含了<strong>有关对象的一般信息，以及关于列、索引、约束等对象的信息</strong>。</p>
  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">EXEC</span> sys<span class="token punctuation">.</span>sp_help <span class="token variable">@objname</span> <span class="token operator">=</span> <span class="token string">'Sales.Orders'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>  在SSMS中，使用<code>ALT</code>+<code>F1</code>的快捷键，<strong>获得相同结果</strong>。</p>
</li>
<li><p><strong>sp_columns</strong>存储过程返回对象中<strong>有关列的信息</strong>。</p>
  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">EXEC</span> sys<span class="token punctuation">.</span>sp_columns <span class="token variable">@table_name</span> <span class="token operator">=</span> <span class="token string">'Orders'</span><span class="token punctuation">,</span> <span class="token variable">@table_owner</span> <span class="token operator">=</span> <span class="token string">'Sales'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p><strong>sp_helpconstraint</strong>存储过程返回对象中<strong>关于约束的信息</strong>。</p>
  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">EXEC</span> sys<span class="token punctuation">.</span>sp_helpconstraint <span class="token variable">@objname</span> <span class="token operator">=</span> <span class="token string">'Sales.Orders'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<p>还有一组函数可以返回<strong>关于数据库实体（如SQL Server实例、数据库、对象、列等等）的各属性的信息</strong>。</p>
<ul>
<li><p><strong>SERVERPROPERTY</strong>函数返回<strong>当前数据库实例的指定属性信息</strong>。</p>
<p>  例如，以下代码返回当前数据库实例的版本级别（RTM、SP1、SP2等）：</p>
  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> SERVERPROPERTY<span class="token punctuation">(</span><span class="token string">'ProductLevel'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p><strong>DATABASEPROPERTYEX</strong>函数返回<strong>指定数据库的特定属性的信息</strong>。</p>
<p>  例如，以下代码返回TSQLFundamentals2008数据库的<strong>排序规则</strong>的当前设置：</p>
  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> DATABASEPROPERTYEX<span class="token punctuation">(</span><span class="token string">'TSQLFundamentals2008'</span><span class="token punctuation">,</span> <span class="token string">'collation'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<hr>
<h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><p>SQL Server 2008<strong>支持4种表运算符</strong>：</p>
<ol>
<li>JOIN</li>
<li>APPLY（第5章）</li>
<li>PIVOT（第7章）</li>
<li>UNPIVOT（第7章）</li>
</ol>
<p>JOIN是ANSI标准，而<strong>APPLY、PIVOT和UNPIVOT是T-SQL对标准的扩展</strong>，每种表运算符都以表作为输入，对表进行处理，经过一系列的逻辑查询处理阶段，最终返回一个结果表。</p>
<p>连接有3种基本类型：交叉连接、内连接和外连接。</p>
<p>交叉连接只有1个步骤：笛卡尔积；</p>
<p>内连接有2个步骤：笛卡尔积、过滤；</p>
<p>外连接有3个步骤：笛卡尔积、过滤、添加外部行。</p>
<p>逻辑查询处理描述了对于给定的任意查询，为了生成正确的结果而需要经历的一系列常规的逻辑步骤，而<strong>物理查询处理</strong>描述的则是RDBMS引擎<strong>如何实际处理查询</strong>。<strong>连接运算的一些逻辑查询处理步骤可能听起来并不高效，但可以对其物理实现进行优化</strong>。逻辑查询处理各步骤对输入表进行的操作是<strong>基于关系代数</strong>的，而数据库引擎没有必要严格遵守逻辑查询处理的步骤，只要可以保证最终生成的结果与逻辑查询处理描述的相同。<strong>出于优化的目的，SQL Server关系引擎经常会采用很多处理捷径</strong>。</p>
<hr>
<h3 id="交叉连接-CROSS-JOIN"><a href="#交叉连接-CROSS-JOIN" class="headerlink" title="交叉连接 (CROSS JOIN)"></a>交叉连接 (CROSS JOIN)</h3><p>在逻辑上，交叉连接是一种最简单的连接，它只实现了一个逻辑查询步骤：笛卡尔积。如果一个表有$m$行，另一个表有$n$行，将得到$m\times n$行的结果集。</p>
<p>下面的查询是对数据库TSQLFundamentals2008中的Customers表和Employees表进行交叉连接查询，返回结果集中的custId和empId列：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> TSQLFundamentals2008<span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> C<span class="token punctuation">.</span>custId<span class="token punctuation">,</span> E<span class="token punctuation">.</span>empId
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Customers <span class="token keyword">AS</span> C
	<span class="token keyword">CROSS</span> <span class="token keyword">JOIN</span> HR<span class="token punctuation">.</span>Employees <span class="token keyword">AS</span> E<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>交叉连接生成的结果集是一个虚拟表，虚拟表中的各列直接源于参与连接的两个表。<strong>使用列名称前缀的目的是为了明确标识这些列</strong>，当没有具有歧义的列名时，列名前缀是可选的，<strong>但是为了明确起见，总是使用列名前缀是个好的习惯</strong>。</p>
<p><strong>旧的交叉连接语法只需简单地在表名之间加个逗号</strong>，这两种语法在逻辑和性能上都没有区别，<strong>但CROSS JOIN语法能使代码结构更清晰</strong>。</p>
<hr>
<h4 id="自交叉连接"><a href="#自交叉连接" class="headerlink" title="自交叉连接"></a>自交叉连接</h4><p>所有基本连接类型（交叉连接、内连接以及外连接）都支持自连接。</p>
<hr>
<h4 id="生成数字表"><a href="#生成数字表" class="headerlink" title="生成数字表"></a>生成数字表</h4><p>用交叉连接<strong>生成由一列整数组成地结果集非常方便，这样的数字序列在许多情况下都是非常有用的工具</strong>。</p>
<p>首先新建一个名为Digits的表，它只有一个名为digit的列，为表添加10行数据（从0到9）：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> tempdb<span class="token punctuation">;</span>
<span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'dbo.Digits'</span><span class="token punctuation">,</span> <span class="token string">'U'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Digits<span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Digits
<span class="token punctuation">(</span>
    digit <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>Digits<span class="token punctuation">(</span>digit<span class="token punctuation">)</span>
	<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>假设现在要<strong>写一个查询，生成从1到1000的整数序列</strong>。可以对Digits表的三个实例进行交叉连接，每个实例分别代表10的不同次幂（1, 10, 100）。为了生成真实的数字，把每个实例的数字乘以它所代表的10的幂，再把结果加起来，<strong>最后加1</strong>。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token punctuation">(</span>D3<span class="token punctuation">.</span>digit <span class="token operator">*</span> <span class="token number">100</span> <span class="token operator">+</span> D2<span class="token punctuation">.</span>digit <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> D<span class="token punctuation">.</span>digit <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> n
<span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>Digits <span class="token keyword">AS</span> D1
	<span class="token keyword">CROSS</span> <span class="token keyword">JOIN</span> dbo<span class="token punctuation">.</span>Digits <span class="token keyword">AS</span> D2
	dbo<span class="token punctuation">.</span>Digits <span class="token keyword">AS</span> D3
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> n<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h3 id="内连接-INNER-JOIN"><a href="#内连接-INNER-JOIN" class="headerlink" title="内连接 (INNER JOIN)"></a>内连接 (INNER JOIN)</h3><p>内连接要应用2个逻辑查询处理步骤：笛卡尔积、过滤。<strong>内连接是默认的连接方式，所以可以只单独指定JOIN关键字</strong>。</p>
<p>内连接的<strong>逻辑处理</strong>是<strong>在关系代数的基础上考虑的</strong>，首先对两个表求笛卡尔积，但后根据条件对行进行过滤。<strong>如前所述，这只是连接的逻辑处理方法，实际上数据库引擎对查询的物理处理可能会有所不同</strong>。</p>
<p>和交叉连接类似，内连接也可以通过<strong>在表名之间加个逗号</strong>来定义，但是<strong>INNER JOIN</strong>在某些方面<strong>更安全</strong>。假如你想写一条内连接查询，但<strong>不小心忘记指定连接条件，INNER JOIN的语法会报错，逗号的语法却仍然能执行</strong>。</p>
<hr>
<h3 id="特殊的连接实例"><a href="#特殊的连接实例" class="headerlink" title="特殊的连接实例"></a>特殊的连接实例</h3><h4 id="组合连接"><a href="#组合连接" class="headerlink" title="组合连接"></a>组合连接</h4><p>组合连接就是连接条件<strong>涉及连接两边的多个列的查询</strong>。<strong>当需要根据主键-外键关系来连接两个表，而且主外键关系是组合的（关系基于多个列）时，通常就要使用组合连接</strong>。</p>
<p>假设现在要对TSQLFundamentals2008数据库的OrderDetails表中<strong>列值的更新进行审核</strong>，为此新建一个名为OrderDetailsAudit的<strong>客户审核表</strong>：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> TSQLFundamentals2008<span class="token punctuation">;</span>

<span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'Sales.OrderDetailsAudit'</span><span class="token punctuation">,</span> <span class="token string">'U'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> Sales<span class="token punctuation">.</span>OrderDetailsAudit<span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Sales<span class="token punctuation">.</span>OrderDetailsAudit
<span class="token punctuation">(</span>
	lsn	<span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">IDENTITY</span><span class="token punctuation">,</span>
    orderId <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    productId <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    dt <span class="token keyword">DATETIME</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    loginName sysName <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    columnName sysName <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    oldVal SQL_VARIANT<span class="token punctuation">,</span>
    newVal SQL_VARIANT<span class="token punctuation">,</span>
    <span class="token keyword">CONSTRAINT</span> PK_OrderDetailsAudit <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>lsn<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">CONSTRAINT</span> FK_OrderDetailsAudit_OrderDetails
    	<span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>orderId<span class="token punctuation">,</span> productId<span class="token punctuation">)</span>
    	<span class="token keyword">REFERENCES</span> Sales<span class="token punctuation">.</span>OrderDetails<span class="token punctuation">(</span>orderId<span class="token punctuation">,</span> productId<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>每行审核记录保存一个日志序列号(lsn)、修改过的行的主键（orderId, productId）、修改过的列的名称（columnName）、更新前和更新后的值（oldVal, newVal）、更新发生时间（dt）、由谁进行的修改（loginName)。这个表有一个定义在orderId、productId两个列上的外键，用于引用OrderDetails表的主键（在其orderId, productId两个列上定义的主键）。</p>
<p>假设已经完成了所有必要的处理，将OrderDetails表中列值发生的变化都记录在了OrderDetailsAudit表中。现在要写一个查询，<strong>返回在OrderDetails表中qty列上发生的所有取值变化，而且在每个结果行中还要返回该列在OrderDetails表中的当前值，以及OrderDetailsAudit表中变化前后的值</strong>。这就要<strong>基于主键-外键关系对两个表进行连接如下</strong>：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> OD<span class="token punctuation">.</span>orderId<span class="token punctuation">,</span> OD<span class="token punctuation">.</span>productId<span class="token punctuation">,</span> OD<span class="token punctuation">.</span>qty<span class="token punctuation">,</span>
	ODA<span class="token punctuation">.</span>dt<span class="token punctuation">,</span> ODA<span class="token punctuation">.</span>loginName<span class="token punctuation">,</span> ODA<span class="token punctuation">.</span>oldVal<span class="token punctuation">,</span> ODA<span class="token punctuation">.</span>newVal
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>OrderDetails <span class="token keyword">AS</span> OD
	<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> Sales<span class="token punctuation">.</span>OrderDetailsAudit <span class="token keyword">AS</span> ODA
	<span class="token keyword">ON</span> OD<span class="token punctuation">.</span>orderId <span class="token operator">=</span> ODA<span class="token punctuation">.</span>orderId
	   <span class="token operator">AND</span> OD<span class="token punctuation">.</span>productId <span class="token operator">=</span> ODA<span class="token punctuation">.</span>productId
<span class="token keyword">WHERE</span> ODA<span class="token punctuation">.</span>columnName <span class="token operator">=</span> <span class="token string">'qty'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>因为关系是基于多个列的，所以连接条件也是组合的。</p>
<hr>
<h4 id="不等连接"><a href="#不等连接" class="headerlink" title="不等连接"></a>不等连接</h4><p>如果连接条件包括<strong>除等号以外的其他运算符</strong>，这样的连接叫做不等连接。</p>
<hr>
<h4 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a>多表连接</h4><p>通常，当FROM子句中<strong>包含多个表运算符</strong>时，<strong>表运算符在逻辑上是按从左到右的顺序处理的</strong>。也就是说第一个表运算符的结果表将作为第二个表运算符的输入，第二个表运算符的结果作为第三个表运算符左边的输入，以此类推。所以<strong>如果FROM子句中包含多个连接，逻辑上只有第一个连接对两个基础表进行操作，而其他连接则将前一个连接的结果作为其左边的输入</strong>。当处理交叉连接和内连接时，<strong>为了优化的目的，数据库引擎能够（经常）对连接顺序进行内部调整</strong>。</p>
<hr>
<h3 id="外连接-OUTER-JOIN"><a href="#外连接-OUTER-JOIN" class="headerlink" title="外连接 (OUTER JOIN)"></a>外连接 (OUTER JOIN)</h3><p>外连接会应用内连接所应用的两个逻辑处理步骤（笛卡尔积和ON过滤），还多一个：<strong>添加外部行</strong>。</p>
<p>在外连接中，<strong>要把一个表标记为”保留的“表，可以在表名之间使用关键字</strong>：</p>
<ul>
<li>LEFT OUTER JOIN</li>
<li>RIGHT OUTER JOIN</li>
<li>FULL OUTER JOIN</li>
</ul>
<p><strong>其中OUTER关键字是可选的</strong>。</p>
<p>LEFT关键字表示左边表的行是保留的，RIGHT关键字表示右边表的行是保留的，而<strong>FULL关键字则表示左右两边表的行都是保留的</strong>。外连接的第三个查询逻辑查询处理步骤就是要<strong>识别保留表中按照ON条件在另一个表找不到与之匹配的那些行，再把这些行添加到连接的前两个步骤生成的结果表中</strong>；对于来自连接的非保留表的那些列，<strong>追加的外部行中的这些列</strong>则<strong>用NULL作为占位符</strong>。</p>
<p>从外连接保留表的角度来看，可以认为外连接结果中的数据行包括两种：<strong>内部行</strong>和<strong>外部行</strong>。</p>
<p>使用外连接时，经常会为<strong>到底在查询的ON子句中，还是在WHERE子句指定连接条件</strong>而感到困惑。<strong>从外连接保留表中的行来考虑这个问题，ON子句中的过滤条件不是最终的</strong>。换句话说，<strong>ON子句中的条件并不能最终决定保留表中部分行是否会在结果中出现，而只是判断是否能够匹配另一边表中的某些行</strong>。所以，当需要表达一个<strong>非最终的条件</strong>时（即这个条件只决定哪些行可以匹配非保留表），<strong>就在ON子句中指定连接条件</strong>；当在生成外部行以后，要应用过滤器，而且希望过滤条件是最终的，就应该在WHERE子句中指定条件。WHERE子句是在FROM子句之后被处理的，即在处理完所有表运算符，生成了所有外部行以后。此外，与ON子句不同，对于行的过滤来说，WHERE子句是最终的。</p>
<p>以下查询根据客户的客户ID和订单的客户ID对Customer表和Orders表进行连接，并返回没有下任何订单的客户：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> C<span class="token punctuation">.</span>custId<span class="token punctuation">,</span> C<span class="token punctuation">.</span>companyName
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Customers <span class="token keyword">AS</span> C
	<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> Sales<span class="token punctuation">.</span>Orders <span class="token keyword">AS</span> O
		<span class="token keyword">ON</span> C<span class="token punctuation">.</span>custId <span class="token operator">=</span> O<span class="token punctuation">.</span>custId
<span class="token keyword">WHERE</span> O<span class="token punctuation">.</span>orderId <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span>

<span class="token comment">-- 该例子效果等同于如下代码</span>
<span class="token keyword">SELECT</span> C<span class="token punctuation">.</span>custId<span class="token punctuation">,</span> C<span class="token punctuation">.</span>companyName
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Customers <span class="token keyword">AS</span> C
	<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> Sales<span class="token punctuation">.</span>Orders <span class="token keyword">AS</span> O
		<span class="token keyword">ON</span> C<span class="token punctuation">.</span>custId <span class="token operator">=</span> O<span class="token punctuation">.</span>custId<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>选择连接的非预留表中的哪个列作为过滤器也很重要</strong>，应该<strong>选择只在外部行才取值为NULL的某个列</strong>。为此，<strong>有3种情形可以考虑安全地使用</strong>：</p>
<ol>
<li>主键列（不能为NULL）</li>
<li>连接列（如果为NULL，在ON过滤阶段就会被过滤掉）</li>
<li>定义为NOT NULL的列</li>
</ol>
<hr>
<h4 id="外连接的高级主题"><a href="#外连接的高级主题" class="headerlink" title="外连接的高级主题"></a>外连接的高级主题</h4><h5 id="包含缺少值的数据"><a href="#包含缺少值的数据" class="headerlink" title="包含缺少值的数据"></a>包含缺少值的数据</h5><p>在查询数据时，可以用外连接来识别和包含缺少的值（即NULL值）。例如，假设现在需要查询TSQLFundamentals2008数据库Orders表的所有订单，要确保对于2006年1月1日到2008年12月31日之间的<strong>每个日期至少在输出结果中出现一行</strong>。</p>
<p>为了解决这个问题，可以<strong>先写一条查询语句返回要求的日期范围内的所有日期序列</strong>。再对这个日期集和Orders表执行一个左连接操作。这样就可以在结果中包含没有订单的日期。</p>
<p>那么，<strong>如何生成指定范围的日期序列</strong>？可以使用一个<strong>由数字组成的辅助表</strong>。新建一个名为Nums的表，其中包含一个名为n的列，并将这个列的值初始化为整数序列（1, 2, 3, …）。<strong>由数字组成的辅助表是一个功能非常强大的通用工具，最终能帮助我们解决很多问题</strong>。只需要在数据库中<strong>创建一次</strong>这样的表，然后用足够数量的数字来填充这个表。</p>
<p>如下代码，在dbo架构中创建Nums表，并为其填充100_000行数据：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SET</span> NOCOUNT <span class="token keyword">ON</span><span class="token punctuation">;</span>
<span class="token keyword">USE</span> TSQLFundamentals2008<span class="token punctuation">;</span>
<span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'dbo.Nums'</span><span class="token punctuation">,</span> <span class="token string">'U'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
	<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Nums<span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Nums
<span class="token punctuation">(</span>
	n <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token comment">-- 在创建表时，添加主键的方式</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">DECLARE</span> <span class="token variable">@i</span> <span class="token keyword">INT</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">BEGIN</span> <span class="token keyword">TRAN</span> <span class="token comment">-- 事务</span>
	<span class="token keyword">WHILE</span> <span class="token variable">@i</span> <span class="token operator">&lt;=</span> <span class="token number">100000</span>
	<span class="token keyword">BEGIN</span>
		<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>Nums <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token variable">@i</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">SET</span> <span class="token variable">@i</span> <span class="token operator">=</span> <span class="token variable">@i</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">END</span>
<span class="token keyword">COMMIT</span> <span class="token keyword">TRAN</span>
<span class="token keyword">SET</span> NOCOUNT <span class="token keyword">OFF</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>作为解决方案的第一步，要<strong>生成指定范围内的所有日期序列</strong>。为此，可以先查询Nums表，<strong>筛选出与请求日期范围内的天数一样多个整数</strong>；再<strong>用DATEDIFF函数计算与每个整数对应的日期</strong>：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> DATEADD<span class="token punctuation">(</span>dd<span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'20060101'</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> orderDate <span class="token comment">-- 转化为日期</span>
<span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>Nums
<span class="token keyword">WHERE</span> n <span class="token operator">&lt;=</span> DATEDIFF<span class="token punctuation">(</span>dd<span class="token punctuation">,</span> <span class="token string">'20060101'</span><span class="token punctuation">,</span> <span class="token string">'20090101'</span><span class="token punctuation">)</span> <span class="token comment">-- 所需天数</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> orderDate<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>最终一条龙的写法：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> DATEADD<span class="token punctuation">(</span>dd<span class="token punctuation">,</span> Nums<span class="token punctuation">.</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'20060101'</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> orderDate<span class="token punctuation">,</span>
	   O<span class="token punctuation">.</span>orderId<span class="token punctuation">,</span> O<span class="token punctuation">.</span>custId<span class="token punctuation">,</span> O<span class="token punctuation">.</span>empId
<span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>Nums
	<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> Sales<span class="token punctuation">.</span>Ordes <span class="token keyword">AS</span> O
		<span class="token keyword">ON</span> DATEADD<span class="token punctuation">(</span>dd<span class="token punctuation">,</span> NUms<span class="token punctuation">.</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'20060101'</span><span class="token punctuation">)</span> <span class="token operator">=</span> O<span class="token punctuation">.</span>orderDate
<span class="token keyword">WHERE</span> Nums<span class="token punctuation">.</span>n <span class="token operator">&lt;=</span> DATEDIFF<span class="token punctuation">(</span>dd<span class="token punctuation">,</span> <span class="token string">'20060101'</span><span class="token punctuation">,</span> <span class="token string">'20090101'</span><span class="token punctuation">)</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> orderDate<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h5 id="在多表连接中使用外连接"><a href="#在多表连接中使用外连接" class="headerlink" title="在多表连接中使用外连接"></a>在多表连接中使用外连接</h5><p>回想<strong>第二章单表查询</strong>中<strong>同时操作（all-at-once operation）<strong>的概念（<strong>在同一逻辑查询处理阶段中出现的所有表达式都是同时进行计算的</strong>）。这个概念</strong>对FROM子句处理阶段中表运算符的处理并不适用</strong>。一些有趣的逻辑错误通常与<strong>外连接的逻辑处理顺序</strong>有关。例如，考虑以下查询语句：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> C<span class="token punctuation">.</span>custId<span class="token punctuation">,</span> O<span class="token punctuation">.</span>orderId<span class="token punctuation">,</span> OD<span class="token punctuation">.</span>productId<span class="token punctuation">,</span> OD<span class="token punctuation">.</span>qty
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Customers <span class="token keyword">AS</span> C
	<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> Sales<span class="token punctuation">.</span>Orders <span class="token keyword">AS</span> O
		<span class="token keyword">ON</span> C<span class="token punctuation">.</span>custId <span class="token operator">=</span> O<span class="token punctuation">.</span>custId
	<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> Sales<span class="token punctuation">.</span>OrderDetails <span class="token keyword">AS</span> OD
		<span class="token keyword">ON</span> O<span class="token punctuation">.</span>orderId <span class="token operator">=</span> OD<span class="token punctuation">.</span>orderId<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>第一个连接是外连接，返回客户和他们的订单，<strong>包括没有下过订单的客户，但第二个连接会将没有下过订单的客户过滤掉</strong>。这个问题可以概括为：对于任何外连接，<strong>如果后面紧跟着一个内连接或右外连接，且连接条件对来自连接左边的NULL值和连接右边的某些值进行了比较，会抵消掉外连接的外部行</strong>。</p>
<p>如果想在输出结果中返回没有订单的客户，有基中变通的方法能够绕过这个问题：</p>
<ol>
<li><p>在第二个连接中也使用左外连接：</p>
 <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> C<span class="token punctuation">.</span>custId<span class="token punctuation">,</span> O<span class="token punctuation">.</span>orderId<span class="token punctuation">,</span> OD<span class="token punctuation">.</span>productId<span class="token punctuation">,</span> OD<span class="token punctuation">.</span>qty
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Customer <span class="token keyword">AS</span> C
	<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> Sales<span class="token punctuation">.</span>Orders <span class="token keyword">AS</span> O
		<span class="token keyword">ON</span> C<span class="token punctuation">.</span>custId <span class="token operator">=</span> O<span class="token punctuation">.</span>custId
	<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> Sales<span class="token punctuation">.</span>OrderDetails <span class="token keyword">AS</span> OD
		<span class="token keyword">ON</span> O<span class="token punctuation">.</span>orderId <span class="token operator">=</span> OD<span class="token punctuation">.</span>orderId<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>先用内连接来连接Orders表和OrderDetails表，然后用<strong>右外连接</strong>来连接Customers表：</p>
 <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> C<span class="token punctuation">.</span>custId<span class="token punctuation">,</span> O<span class="token punctuation">.</span>orderId<span class="token punctuation">,</span> OD<span class="token punctuation">.</span>productId<span class="token punctuation">,</span> OD<span class="token punctuation">.</span>qty
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders <span class="token keyword">AS</span> O
	<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> Sales<span class="token punctuation">.</span>OrderDetails <span class="token keyword">AS</span> OD
		<span class="token keyword">ON</span> O<span class="token punctuation">.</span>custId <span class="token operator">=</span> OD<span class="token punctuation">.</span>custId
	<span class="token keyword">RIGHT</span> <span class="token keyword">JOIN</span> Sales<span class="token punctuation">.</span>Customer <span class="token keyword">AS</span> C
		<span class="token keyword">ON</span> O<span class="token punctuation">.</span>orderId <span class="token operator">=</span> C<span class="token punctuation">.</span>orderId<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>把Orders表和OrderDetails表之间的内联用一对圆括号括起来，使其成为一个独立的逻辑处理语句</strong>：</p>
 <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> C<span class="token punctuation">.</span>custId<span class="token punctuation">,</span> O<span class="token punctuation">.</span>orderId<span class="token punctuation">,</span> OD<span class="token punctuation">.</span>productId<span class="token punctuation">,</span> OD<span class="token punctuation">.</span>qty
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Customer <span class="token keyword">AS</span> C
	<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> 
	<span class="token punctuation">(</span>Sales<span class="token punctuation">.</span>Orders <span class="token keyword">AS</span> O
     	<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> Sales<span class="token punctuation">.</span>OrderDetails <span class="token keyword">AS</span> OD
			<span class="token keyword">ON</span> O<span class="token punctuation">.</span>orderId <span class="token operator">=</span> OD<span class="token punctuation">.</span>orderId<span class="token punctuation">)</span>
    <span class="token keyword">ON</span> C<span class="token punctuation">.</span>custId <span class="token operator">=</span> O<span class="token punctuation">.</span>custId<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<hr>
<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p><strong>SQL支持在查询语句中编写查询，或者嵌套其他查询</strong>。最外层查询的结果集会<strong>返回给调用者</strong>，称为<strong>外部査询</strong>。内部查询的结果是<strong>供外部查询使用</strong>的，也称为<strong>子查询</strong>。内部查询可以取代基于常量或变量的表达式，并在运行时进行计算。与在表达式中使用常量不同的是，子查询的结果可能是变化的，因为被查询的表可能会发生变化。<strong>通过使用子查询，可以避免在查询解决方案中把操作分成多个步骤，不必在变量中保存中间查询结果</strong>。</p>
<p>子查询可以分成<strong>独立子查询</strong>（self-contained subquery）和<strong>相关子查询</strong>（correlated subquery）两类。独立子查询不依赖于它所属的外部查询，而<strong>相关子查询则必须依赖它所属的外部查询</strong>。子查询可以返回<strong>一个单独的值（标量）、多个值或整个表结果</strong>。</p>
<p>本章重点介绍返回单个值和多个值的子查询，后面的章节介绍返回整个表的子查询。</p>
<hr>
<h3 id="独立子查询"><a href="#独立子查询" class="headerlink" title="独立子查询"></a>独立子查询</h3><p>独立子查询<strong>调试起来非常方便</strong>，因为<strong>总可以把子查询代码独立出来单独运行，并确保它能够正确实现默认的功能</strong>。在逻辑上，独立子查询在执行外部查询之前只要先执行一次，接着外部查询再使用子查询的结果继续进行查询。</p>
<hr>
<h4 id="独立标量子查询"><a href="#独立标量子查询" class="headerlink" title="独立标量子查询"></a>独立标量子查询</h4><p>标量子查询是返回单个值的子查询，而不管它是不是独立子查询。标量子查询<strong>可以出现在外部查询中期望使用单个值的任何地方（WHERE、SELECT等等）</strong>。</p>
<p>例如，假设现在要查询TSQLFundamentals2008数据库中的Orders表，返回订单ID最大的订单信息。</p>
<ul>
<li><p>方法一：<strong>通过一个变量</strong>，保存从Orders表中取回的最大订单ID。接着筛选出订单ID等于变量值的订单。</p>
  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> TSQLFundamentals2008<span class="token punctuation">;</span>

<span class="token keyword">DECLARE</span> <span class="token variable">@maxId</span> <span class="token keyword">INT</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">MAX</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span>
                     	<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders<span class="token punctuation">)</span><span class="token punctuation">;</span>
                     	
<span class="token keyword">SELECT</span> orderId<span class="token punctuation">,</span> orderDate<span class="token punctuation">,</span> empId<span class="token punctuation">,</span> custId
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders
<span class="token keyword">WHERE</span> orderId <span class="token operator">=</span> <span class="token variable">@maxId</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>方法二：由一个<strong>标量子查询</strong>返回最大的订单ID。</p>
  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> orderId<span class="token punctuation">,</span> orderDate<span class="token punctuation">,</span> empId<span class="token punctuation">,</span> custId
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders
<span class="token keyword">WHERE</span> orderId <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">MAX</span><span class="token punctuation">(</span>O<span class="token punctuation">.</span>orderId<span class="token punctuation">)</span>
                 <span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders <span class="token keyword">AS</span> O<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<p>有效的标量子查询，它的返回值<strong>不能超过一个</strong>。如果标量子查询返回了多个值，在运行时可能会失败。<strong>如果标量子查询没有返回任何值，其结果就转换为NULL</strong>。</p>
<hr>
<h4 id="独立多值子查询"><a href="#独立多值子查询" class="headerlink" title="独立多值子查询"></a>独立多值子查询</h4><p>一些谓词（例如<strong>IN</strong>谓词）可以处理<strong>多值子查询</strong>。</p>
<p>可能会遇到很多<strong>既可以用子查询，又可以用连接来解决的问题</strong>。<strong>没有什么可靠的经验法则可以断定子查询和连接之间的优劣</strong>。**在一些情况下，数据库引擎对这两种查询的解释是一样的；另一些情况下，对二者的解释则是不同的。**对于给定的任务，<strong>可以先用直观的形式写出能解决问题的查询语句；如果对它运行的性能不满意，调整方法之一就是尝试重构查询</strong>。</p>
<p>例如，以下查询语句返回<strong>没有下过任何订单</strong>的客户：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> custId<span class="token punctuation">,</span> companyName
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Customers
<span class="token keyword">WHERE</span> custId <span class="token operator">NOT</span> <span class="token operator">IN</span>
	<span class="token punctuation">(</span><span class="token keyword">SELECT</span> O<span class="token punctuation">.</span>custId
     <span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders <span class="token keyword">AS</span> O<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>你可能会问，<strong>在子查询中指定一个DISTINCT子句是否会有助于提高性能？因为相同的客户ID在Orders表中可能出现多次</strong>。<strong>数据库引擎足够聪明，它知道应该删除重复的值，而不必非要显式地要求它这么做。所以这个问题不必我们过多费心</strong>。</p>
<hr>
<h3 id="相关子查询"><a href="#相关子查询" class="headerlink" title="相关子查询"></a>相关子查询</h3><p>相关子查询需要<strong>依赖外部查询，而不能独立地调用</strong>。<strong>在逻辑上，子查询会为每个外部行单独计算一次</strong>。</p>
<p>例如以下查询，会为每个客户返回其订单ID最大的订单：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> TSQLFundamentals2008<span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> custId<span class="token punctuation">,</span> orderId<span class="token punctuation">,</span> orderDate<span class="token punctuation">,</span> empId
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders <span class="token keyword">AS</span> O1
<span class="token keyword">WHERE</span> orderId <span class="token operator">=</span> 
	<span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">MAX</span><span class="token punctuation">(</span>O2<span class="token punctuation">.</span>orderId<span class="token punctuation">)</span>
     <span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders <span class="token keyword">AS</span> O2
     <span class="token keyword">WHERE</span> O2<span class="token punctuation">.</span>custId <span class="token operator">=</span> O1<span class="token punctuation">.</span>custId<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>相关子查询通常比独立子查询难理解。<strong>为了更好地理解，一种有用的方法是将注意力集中在外部表的某一行，再来理解针对改行所进行的逻辑处理</strong>。</p>
<p>相关子查询要依赖于外部查询，这使得它比独立子查询更难调试。为了调试相关子查询，要用一个常量来替换外部行的关联，在确保代码正确以后，再把常量替换为外部行的关联。再举一个相关子查询的例子。假设现在要查询Sales.OrderValues视图，<strong>为每个订单返回当前订单金额占客户订单总额的百分比</strong>。</p>
<p>第二章单表查询中，提供了使用<strong>OVER子句</strong>的方案：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> orderId<span class="token punctuation">,</span> custId<span class="token punctuation">,</span> val<span class="token punctuation">,</span>
	<span class="token number">100.</span> <span class="token operator">*</span> val <span class="token operator">/</span> <span class="token function">SUM</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token keyword">OVER</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> pctAll<span class="token punctuation">,</span>
	<span class="token number">100.</span> <span class="token operator">*</span> val <span class="token operator">/</span> <span class="token function">SUM</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token keyword">OVER</span><span class="token punctuation">(</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> custId<span class="token punctuation">)</span> <span class="token keyword">AS</span> pctCust
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>OrderValues<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里介绍使用子查询来解决这个问题。<strong>尝试用几种不同的方案来解决同一问题总是个好主意，因为不同解决方案通常再复杂性和性能上都有所不同</strong>。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> orderId<span class="token punctuation">,</span> custId<span class="token punctuation">,</span> val<span class="token punctuation">,</span>
	CAST<span class="token punctuation">(</span><span class="token number">100.</span> <span class="token operator">*</span> val <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">SUM</span><span class="token punctuation">(</span>O2<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
                       <span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>OrderValues <span class="token keyword">AS</span> O2
                       <span class="token keyword">WHERE</span> O2<span class="token punctuation">.</span>custId <span class="token operator">=</span> O1<span class="token punctuation">.</span>custId<span class="token punctuation">)</span>
         <span class="token keyword">AS</span> <span class="token keyword">NUMERIC</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> pct
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>OrderValues <span class="token keyword">AS</span> O1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>查询中用CAST函数将表达式的数据类型转换为精度为5（<strong>数字的总位数</strong>）、<strong>小数点后保留两位数字</strong>的数值类型。</p>
<hr>
<h4 id="EXISTS-谓词"><a href="#EXISTS-谓词" class="headerlink" title="EXISTS 谓词"></a>EXISTS 谓词</h4><p>支持一个名为EXISTS的谓词，<strong>它的输入是一个子查询</strong>；如果子查询<strong>能够返回任何行</strong>，该谓词则返回TRUE，否则返回FALSE。</p>
<p>例如，以下查询返回<strong>下过订单</strong>的西班牙客户：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> custId<span class="token punctuation">,</span> companyName
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Customers <span class="token keyword">AS</span> C
<span class="token keyword">WHERE</span> country <span class="token operator">=</span> <span class="token string">'Spain'</span>
	<span class="token operator">AND</span> <span class="token keyword">EXISTS</span>
		<span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders <span class="token keyword">AS</span> O
         <span class="token keyword">WHERE</span> O<span class="token punctuation">.</span>custId <span class="token operator">=</span> C<span class="token punctuation">.</span>custId<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用EXISTS谓词的一个好处是可以用类似英语的语言来<strong>直观地表达查询</strong>。EXISTS谓词是如何进行<strong>自身优化</strong>的呢？<strong>即使SQL Server引擎什么也没找到时，也足以决定子查询是否应该返回了，而无须处理所有满足条件的行</strong>。可以把这种处理方式看作是一种<strong>短路（short-circuit）</strong>，它能够<strong>提高处理效率</strong>。</p>
<p>与大多数其他情况不同，<strong>对于EXISTS谓词的使用，在其子查询的SELECT列表中使用星号在逻辑上并不是不好的实践方式</strong>。EXISTS谓词<strong>只关心是否存在匹配行，而不考虑SELECT列表中指定的列，好像整个SELECT子句是多余的一样</strong>。SQL Server数据库引擎为了优化，<strong>会忽略子查询的SELECT列表</strong>。所以按照性能优化来说，指定通配符（*）并没有什么负面影响。不过，使用列通配符时，其<strong>解析处理还是会涉及少量的开销</strong>，因为要把（*)扩展为列名的完整列表，以确保你有权访问所有列。<strong>可以使用常量来代替星号</strong>，但<strong>这种解析开销通常微不足道，不值得为节省这点开销而牺牲代码的可读性</strong>。</p>
<p>最后，EXISTS谓词另一个要注意的有趣方面是：与T-SQL中大多数谓词不同，EXISTS谓词使用的是<strong>二值逻辑</strong>，因为<strong>不知道查询是否有返回行的情况是不存在的</strong>。</p>
<hr>
<h3 id="高级子查询"><a href="#高级子查询" class="headerlink" title="高级子查询"></a>高级子查询</h3><h4 id="返回前一个或后一个记录"><a href="#返回前一个或后一个记录" class="headerlink" title="返回前一个或后一个记录"></a>返回前一个或后一个记录</h4><p>假设现在要对TSQLFundamentals2008数据库中的Orders表进行查询，对于每个订单，返回当前订单的信息和<strong>它的前一个订单的ID</strong>，一个这样的逻辑等式的例子是<strong>小于当前值的最大值</strong>：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> orderId<span class="token punctuation">,</span> orderDate<span class="token punctuation">,</span> empId<span class="token punctuation">,</span> custId
	<span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">MAX</span><span class="token punctuation">(</span>O2<span class="token punctuation">.</span>orderId<span class="token punctuation">)</span>
     <span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders <span class="token keyword">AS</span> O2
     <span class="token keyword">WHERE</span> O2<span class="token punctuation">.</span>orderId <span class="token operator">&lt;</span> O1<span class="token punctuation">.</span>orderId<span class="token punctuation">)</span> <span class="token keyword">AS</span> preOrderId
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders <span class="token keyword">AS</span> O1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>类似地，可以用<strong>大于当前值地最小值</strong>来表述<strong>下一个</strong>的概念。</p>
<hr>
<h4 id="连续聚合-Running-Aggregate"><a href="#连续聚合-Running-Aggregate" class="headerlink" title="连续聚合 (Running Aggregate)"></a>连续聚合 (Running Aggregate)</h4><p>连续聚合是一种<strong>对累积数据（通常按时间顺序）执行的聚合</strong>。本节用Sales.OrderTotalsByYear视图来演示计算连续聚合的技术，这个视图包含每年的总订货量。</p>
<p>假设现在有一个任务，需要返回每年的订单年份、订货量，以及连续几年的总订货量：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> orderYear<span class="token punctuation">,</span> qty<span class="token punctuation">,</span>
	<span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">SUM</span><span class="token punctuation">(</span>O2<span class="token punctuation">.</span>qty<span class="token punctuation">)</span>
     <span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>OrderTotalByYear <span class="token keyword">AS</span> O2
     <span class="token keyword">WHERE</span> O2<span class="token punctuation">.</span>orderYear <span class="token operator">&lt;=</span> O1<span class="token punctuation">.</span>orderYear<span class="token punctuation">)</span> <span class="token keyword">AS</span> runQty
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>OrderTotalsByYear <span class="token keyword">AS</span> O1
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> orderYear<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h4 id="行为不当-Misbehaving-的子查询"><a href="#行为不当-Misbehaving-的子查询" class="headerlink" title="行为不当 (Misbehaving) 的子查询"></a>行为不当 (Misbehaving) 的子查询</h4><p>这部分将介绍几种<strong>子查询的运行结果可能与期望的结果恰好相反的情况</strong>，以及为了避免在代码中发生于这些情况有关的逻辑缺陷而<strong>应该遵循的最佳实践</strong>。</p>
<h5 id="NULL的问题"><a href="#NULL的问题" class="headerlink" title="NULL的问题"></a>NULL的问题</h5><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> custId<span class="token punctuation">,</span> companyName
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Customers <span class="token keyword">AS</span> C
<span class="token keyword">WHERE</span> custId <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> O<span class="token punctuation">.</span>custId
                     <span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders <span class="token keyword">AS</span> O<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>如果Sales.Orders表中有一行客户ID为NULL的订单</strong>，将会<strong>返回一个空的结果集</strong>。UNKNOWN的一个微妙之处是，<strong>当对它取反时，结果仍然是UNKNOWN</strong>。如果外部表中的值没有在子查询返回的已知集合中出现，那么外部查询仍然不会返回这个值，因为无法判断这个值是否包含NULL的集合所涵盖的范围。</p>
<p>有什么可以遵循的实践原则能避免这个问题呢？</p>
<ul>
<li>首先，当一个列不应该允许为NULL时，把它定义为NOT NULL很重要。<strong>加强数据的完整性定义，比很多人想象得要重要得多</strong>。</li>
<li>其次，在所写的查询语句中，应该考虑三值逻辑可能出现的三种真值（TRUE、FALSE和UNKNOWN）。<strong>明确地考虑一下查询是否要处理NULL值，如果要处理，对NULL值的默认处理是否适合需要，当不合适时，就要对查询语句进行调整</strong>。</li>
</ul>
<p>在上述例子中，外部查询返回空集是因为与NULL的比较。<strong>如果想忽略NULL值，就应该在查询中（显式或隐式地）排除</strong>：</p>
<ul>
<li><p><strong>显式</strong>地排除NULL值：</p>
  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> custId<span class="token punctuation">,</span> companyName
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Customers <span class="token keyword">AS</span> C
<span class="token keyword">WHERE</span> custId <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> O<span class="token punctuation">.</span>custId
                     <span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders <span class="token keyword">AS</span> O
                     <span class="token keyword">WHERE</span> O<span class="token punctuation">.</span>custId <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>隐式</strong>地排除NULL值：</p>
<p>  <strong>使用NOT EXISTS谓词取代NOT IN谓词</strong>，因为EXISTS使用的是<strong>二值谓词逻辑</strong>，所以EXISTS总是返回TRUE或FALSE，而不会返回UNKNOWN。</p>
  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> custId<span class="token punctuation">,</span> companyName
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Customers <span class="token keyword">AS</span> C
WEHRE <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span>
	<span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span>
     <span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders <span class="token keyword">AS</span> O
     <span class="token keyword">WHERE</span> O<span class="token punctuation">.</span>custId <span class="token operator">=</span> C<span class="token punctuation">.</span>custId<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>  因此，<strong>使用NOT EXISTS比使用NOT IN要安全</strong>。</p>
</li>
</ul>
<hr>
<h2 id="表表达式"><a href="#表表达式" class="headerlink" title="表表达式"></a>表表达式</h2><p>表表达式是一种<strong>命名的查询表达式</strong>，代表一个有效的关系表。可以像其他表一样，在数据处理语句中使用表表达式。SQL Server支持4种类型的表表达式：</p>
<ul>
<li>派生表（derived table）</li>
<li>公用表表达式（CTE, common table expression）</li>
<li>视图</li>
<li>内联表值函数（inline TVF, inline table-valued function）</li>
</ul>
<p>表表达式并不是物理上真实存在的对象，它们是<strong>虚拟的</strong>。对于表表达式的查询<strong>在数据库引擎内部都将转换为对底层对象的查询</strong>。使用表表达式的<strong>好处通常体现在代码逻辑方面，而不是性能方面</strong>。例如，表表达式通过<strong>模块化的方法</strong>可以<strong>简化问题的解决方案</strong>，还可以<strong>规避语言上的某些限制</strong>（如对于在SELECT子句中起的别名，不能在逻辑处理顺序位于SELECT子句之前的子句中引用这些别名）。</p>
<hr>
<h3 id="派生表（表子查询）"><a href="#派生表（表子查询）" class="headerlink" title="派生表（表子查询）"></a>派生表（表子查询）</h3><p>派生表是在外部查询的<strong>FROM子句中定义</strong>的。派生表的存在范围为定义它的外部查询，只要外部查询一结束，派生表也就不存在了。</p>
<p>定义派生表的查询语句<strong>写在一对圆括号内，后面跟着AS子句和派生表的名称</strong>。要有效地定义任何类型的表表达式，<strong>表中的所有列必须由别名</strong>。</p>
<p>使用表表达式的一个好处是：在外部查询的任何子句中都可以引用在内部查询的SELECT子句中分配的列别名。这<strong>有助于规避一个限制：不能再逻辑处理顺序先于SELECT子句的其他查询子句（如WHERE或GROUP BY）中对SELECT子句分配的列别名进行引用</strong>。</p>
<p>第二章单表查询中提到过：</p>
<blockquote>
<p>在WHERE子句和SELECT子句中<strong>重复使用表达式YEAR(orderDate)，SQL Server能够标识在查询中重复使用的同一表达式</strong>，因此，<strong>表达式其实只会被计算一次</strong>。</p>
</blockquote>
<p>如果表达式很长，该怎么办呢？<strong>维护同一表达式的两个副本可能会破坏代码的可读性和可维护性，而且也更容易出错</strong>。可以利用表表达式这个工具：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> orderYear<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token keyword">DISTINCT</span> custId<span class="token punctuation">)</span> <span class="token keyword">AS</span> numCusts
<span class="token keyword">FROM</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>orderDate<span class="token punctuation">)</span> <span class="token keyword">AS</span> orderYear<span class="token punctuation">,</span> custId
      <span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders<span class="token punctuation">)</span> <span class="token keyword">AS</span> D
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> orderYear<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>如前所述，SQL Server<strong>在执行时会扩展表表达式的定义，以便直接访问底层对象</strong>。扩展后，上述查询会转换成<strong>重复使用同一表达式</strong>的形式：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>orderDate<span class="token punctuation">)</span> <span class="token keyword">AS</span> orderYear<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token keyword">DISTINCT</span> custId<span class="token punctuation">)</span> <span class="token keyword">AS</span> numCusts
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>orderDate<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>可见，<strong>使用表表达式是出于逻辑原因，而与性能无关</strong>。一般来说，<strong>表表达式既不会对性能产生正面影响，也不会产生负面影响</strong>。</p>
<p>SQL Server支持另一种格式来为列起别名，可以把这种格式看成是一种外部命名格式。在这种命名格式中，<strong>在表表达式名称后面，用一对圆括号一次性指定所有目标列的名称</strong>。如下所示：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> orderYear<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token keyword">DISTINCT</span> custId<span class="token punctuation">)</span> <span class="token keyword">AS</span> numCusts
<span class="token keyword">FROM</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>orderDate<span class="token punctuation">)</span><span class="token punctuation">,</span> custId
      <span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders<span class="token punctuation">)</span> <span class="token keyword">AS</span> D<span class="token punctuation">(</span>orderYear<span class="token punctuation">,</span> CustId<span class="token punctuation">)</span>
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> orderYear<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>通常还是<strong>建议内联别名格式</strong>，有两点原因：</p>
<ol>
<li>使用内联格式时，如果要调试代码，只要把定义表表达式的查询语句独立出来再运行，在结果中出现的列名就是原来指定的别名。如果使用外部格式，表表达式查询独立出来后，就不能在其中包含目标列名；</li>
<li>当表表达式的查询很长，采用外部命名格式可能很难分辨出列别名所属的表达式。</li>
</ol>
<hr>
<h4 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h4><p>如果必须要用一个本身就引用了某个派生表的查询去定义另一个派生表，最终得到的就是嵌套派生表。<strong>嵌套一般是编程过程中容易产生问题的一个方面，因为它趋于让代码变得复杂，降低代码的可读性</strong>。</p>
<hr>
<h4 id="派生表的多引用"><a href="#派生表的多引用" class="headerlink" title="派生表的多引用"></a>派生表的多引用</h4><p>派生表是在外部查询的<strong>FROM子句中定义</strong>的，<strong>其逻辑处理顺序并不优先于外部查询</strong>。<strong>当对外部查询的FROM子句进行处理时，派生表其实并不存在。如果要引用派生表的多个实例，必须基于同一查询去定义多个派生表</strong>。这让代码变得<strong>冗长，难以维护，而且更容易出错</strong>。</p>
<hr>
<h3 id="公用表表达式-CTE"><a href="#公用表表达式-CTE" class="headerlink" title="公用表表达式 (CTE)"></a>公用表表达式 (CTE)</h3><p>公用表表达式（CTE，Common table expression)是和派生表相似的一种表表达式，而且具有一些重要优势。</p>
<p>CTE<strong>用WITH子句定义</strong>：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">WITH</span> <span class="token operator">&lt;</span>CTE_Name<span class="token operator">></span> <span class="token keyword">AS</span>
<span class="token punctuation">(</span>
	<span class="token operator">&lt;</span>inner_query_defining_CTE<span class="token operator">></span>
<span class="token punctuation">)</span>
<span class="token operator">&lt;</span>outer_query_against_CTE<span class="token operator">></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>举一个简单的例子，以下代码定义了一个名为USACusts的CTE，它的内部查询返回所有来自美国的客户，外部查询则选择了CTE中的所有行：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">WITH</span> USACusts <span class="token keyword">AS</span>
<span class="token punctuation">(</span>
	<span class="token keyword">SELECT</span> custId<span class="token punctuation">,</span> companyName
    <span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Customers
    <span class="token keyword">WHERE</span> country <span class="token operator">=</span> <span class="token string">'USA'</span>
<span class="token punctuation">)</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> USACusts<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>和派生表一样，一旦外部查询完成，CTE的生命周期也就结束了。</p>
<h4 id="定义多个-CTE"><a href="#定义多个-CTE" class="headerlink" title="定义多个 CTE"></a>定义多个 CTE</h4><p>从表面来看，派生表和CTE之间的区别可能只是语义方面，但是CTE具有几个重要优势，其中之一：<strong>如果必须在一个CTE中引用另一个CTE，不需要像派生表那样进行嵌套，而只要简单地在同一WITH子句中定义多个CTE，并用逗号分隔开</strong>即可。每个CTE<strong>可以引用在它前面定义的所有CTE</strong>。</p>
<p>例如，查询返回订单年份和该年处理的客户数，但要求每个订单年份处理的客户数要多于70人：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 原先做法</span>
<span class="token keyword">SELECT</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>orderDate<span class="token punctuation">)</span> <span class="token keyword">AS</span> orderYear<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token keyword">DISTINCT</span> custId<span class="token punctuation">)</span> <span class="token keyword">AS</span> numCusts
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>orderDate<span class="token punctuation">)</span>
<span class="token keyword">HAVING</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token keyword">DISTINCT</span> custId<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">70</span><span class="token punctuation">;</span>

<span class="token comment">-- CTE方式</span>
<span class="token keyword">WITH</span> C1 <span class="token keyword">AS</span>
<span class="token punctuation">(</span>
	<span class="token keyword">SELECT</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>orderDate<span class="token punctuation">)</span> <span class="token keyword">AS</span> orderYear<span class="token punctuation">,</span> custId
    <span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders
<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">-- 逗号隔开定义的多个CTE</span>
C2 <span class="token keyword">AS</span>
<span class="token punctuation">(</span>
	<span class="token keyword">SELECT</span> orderYear<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token keyword">DISTINCT</span> custId<span class="token punctuation">)</span> <span class="token keyword">AS</span> numCusts
    <span class="token keyword">FROM</span> C1 <span class="token comment">-- 每个CTE可以引用在它前面定义的所有CTE</span>
    <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> orderYear
<span class="token punctuation">)</span>
<span class="token keyword">SELECT</span> orderYear<span class="token punctuation">,</span> numCusts
<span class="token keyword">FROM</span> C2
<span class="token keyword">WHERE</span> numCusts <span class="token operator">></span> <span class="token number">70</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>因为在使用CTE之前就已经定义好了CTE，所以<strong>不会得到嵌套的CTE（另外从技术上讲，既不能嵌套CTE，也不能在定义派生表的圆括号内再定义CTE）</strong>。每个CTE以<strong>模块化</strong>的方式在代码中单独出现。与嵌套的派生表方法相比，这种模块化的方法能大大地提高代码地可读性和可维护性。</p>
<hr>
<h4 id="CTE-的多引用"><a href="#CTE-的多引用" class="headerlink" title="CTE 的多引用"></a>CTE 的多引用</h4><p>CTE<strong>先定义，再查询</strong>的特点带来的另一个优点是<strong>可以引用同一个CTE的多个实例</strong>。</p>
<p>例如，查询计算<strong>当前年份和上一年份处理过的客户数量之差</strong>：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">WITH</span> YearlyCount <span class="token keyword">AS</span>
<span class="token punctuation">(</span>
	<span class="token keyword">SELECT</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>orderDate<span class="token punctuation">)</span> <span class="token keyword">AS</span> orderYear<span class="token punctuation">,</span>
    	<span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token keyword">DISTINCT</span> custId<span class="token punctuation">)</span> <span class="token keyword">AS</span> numCusts
    <span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders
    <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>orderDate<span class="token punctuation">)</span>
<span class="token punctuation">)</span>
<span class="token keyword">SELECT</span> Cur<span class="token punctuation">.</span>orderYear<span class="token punctuation">,</span>
	Cur<span class="token punctuation">.</span>numCusts <span class="token keyword">AS</span> curNumCusts<span class="token punctuation">,</span> Prv<span class="token punctuation">.</span>numCusts <span class="token keyword">AS</span> prvNumCusts<span class="token punctuation">,</span>
	<span class="token punctuation">(</span>Cur<span class="token punctuation">.</span>numCusts <span class="token operator">-</span> Prv<span class="token punctuation">.</span>numCusts<span class="token punctuation">)</span> <span class="token keyword">AS</span> growth
<span class="token keyword">FROM</span> YearlyCount <span class="token keyword">AS</span> Cur
	<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> YearlyCount <span class="token keyword">AS</span> Prv
		<span class="token keyword">ON</span> Cur<span class="token punctuation">.</span>orderYear <span class="token operator">=</span> Prv<span class="token punctuation">.</span>orderYear <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h4 id="递归-CTE"><a href="#递归-CTE" class="headerlink" title="递归 CTE"></a>递归 CTE</h4><p>CTE之所以与其他表表达式不同，是因为它<strong>支持递归查询</strong>。定义一个递归CTE至少需要两个查询，第一个查询称为<strong>定位点成员（anchor member）</strong>，第二个查询称为<strong>递归成员（recursive member）</strong>。递归CTE的基本格式如下：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">WITH</span> <span class="token operator">&lt;</span>CTE_Name<span class="token operator">></span> <span class="token keyword">AS</span>
<span class="token punctuation">(</span>
	<span class="token operator">&lt;</span>anchor_member<span class="token operator">></span>
    <span class="token keyword">UNION</span> <span class="token keyword">ALL</span>
    <span class="token operator">&lt;</span>recursive_member<span class="token operator">></span>
<span class="token punctuation">)</span>
<span class="token operator">&lt;</span>outer_query_against_CTE<span class="token operator">></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p><strong>定位点成员</strong>只是一个返回<strong>有效关系结果表</strong>的查询，与用于定义非递归表表达式的查询类似。定位点成员查询<strong>只被调用一次</strong>。</p>
</li>
<li><p><strong>递归成员</strong>是一个<strong>引用了CTE名称</strong>的查询。<strong>对CTE名称的引用</strong>代表的是<strong>在一个执行序列中逻辑上的前一个结果集</strong>。</p>
<ul>
<li><strong>第一次调用</strong>递归成员时，前一个结果集代表<strong>由定位点成员返回的任何结果集</strong>。</li>
<li><strong>之后每次调用</strong>递归成员时，对CTE名称的引用代表对递归成员的前一次调用所返回的结果集。</li>
<li>递归成员的<strong>递归终止检查是隐式的</strong>，递归成员会一直被重复调用，直到<strong>返回空的结果集</strong>或<strong>超出了某种限制条件</strong>。</li>
</ul>
</li>
<li><p><strong>外部查询</strong>中的CTE名称引用<strong>代表对定位点成员调用和所有对递归成员调用的联合结果集</strong>。</p>
</li>
</ul>
<p>以下代码演示了如何使用递归CTE来返回有关某个雇员（Don Funk, empId 为2）及其所有各级（直接或间接）下属的信息：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">WITH</span> EmpsCTE <span class="token keyword">AS</span>
<span class="token punctuation">(</span>
	<span class="token keyword">SELECT</span> empId<span class="token punctuation">,</span> mgrId<span class="token punctuation">,</span> firstName<span class="token punctuation">,</span> lastName
    <span class="token keyword">FROM</span> HR<span class="token punctuation">.</span>Employees
    <span class="token keyword">WHERE</span> empId <span class="token operator">=</span> <span class="token number">2</span>
    
    <span class="token keyword">UNION</span> <span class="token keyword">ALL</span>
    
    <span class="token keyword">SELECT</span> C<span class="token punctuation">.</span>empId<span class="token punctuation">,</span> C<span class="token punctuation">.</span>mgrId<span class="token punctuation">,</span> C<span class="token punctuation">.</span>firstName<span class="token punctuation">,</span> c<span class="token punctuation">.</span>lastName
    <span class="token keyword">FROM</span> EmpsCTE <span class="token keyword">AS</span> P
    	<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> HR<span class="token punctuation">.</span>Employees <span class="token keyword">AS</span> C
    		<span class="token keyword">ON</span> C<span class="token punctuation">.</span>mgrId <span class="token operator">=</span> P<span class="token punctuation">.</span>empId
<span class="token punctuation">)</span>
<span class="token keyword">SELECT</span> empId<span class="token punctuation">,</span> mgrId<span class="token punctuation">,</span> firstName<span class="token punctuation">,</span> lastName
<span class="token keyword">FROM</span> EmpsCTE<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果递归成员的连接谓词中<strong>存在逻辑错误，或是循环中的数据结果出了问题</strong>，都可能会导致递归成员被调用无限多次。为了安全起见，<strong>SQL Server默认把递归成员最多可以调用的次数限制为100次</strong>。为了修改默认的最大递归数，可以在外部查询的最后指定OPTION(MAXRECURSION n)提示（hint），这里的<strong>n是一个范围在0到32767之间的整数</strong>。<strong>n为0时，表示去掉对递归调用次数的限制</strong>。</p>
<p>SQL Server把定位点成员和递归成员<strong>返回的临时结果集</strong>先保存在<strong>tempdb数据库的工作表中</strong>。如果去掉对递归次数的限制，万一查询失控，工作表的体积将很快变得非常大。<strong>当tempdb数据库的体积不能再继续增长时（例如，磁盘空间耗尽），查询便会失败</strong>。</p>
<hr>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>派生表和CTE的<strong>作用范围仅限于在单个语句范围内</strong>，这意味着它们都<strong>不可重用</strong>。视图的定义<strong>存储在一个数据库对象中</strong>，一旦创建就是数据库的<strong>永久</strong>部分，<strong>只有用删除语句显式删除，才会从数据库中移除</strong>。</p>
<p>以下代码在TSQLFundamentals2008数据库中的Sales架构中创建了一个名为USAcusts的视图，代表来自美国的所有客户：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> TSQFundamentals2008<span class="token punctuation">;</span>

<span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'Sales.USAcusts'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
	<span class="token keyword">DROP</span> <span class="token keyword">VIEW</span> Sales<span class="token punctuation">.</span>USAcusts<span class="token punctuation">;</span>
	
GO <span class="token comment">-- CREATE VIEW必须是批处理中仅有的语句</span>
<span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> Sales<span class="token punctuation">.</span>USAcusts
<span class="token keyword">AS</span>
<span class="token keyword">SELECT</span> custId<span class="token punctuation">,</span> companyName<span class="token punctuation">,</span> contactName<span class="token punctuation">,</span> contactTitle<span class="token punctuation">,</span> address<span class="token punctuation">,</span>
	city<span class="token punctuation">,</span> region<span class="token punctuation">,</span> postalCode<span class="token punctuation">,</span> Country<span class="token punctuation">,</span> phone<span class="token punctuation">,</span> fax
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Customers
<span class="token keyword">WHERE</span> country <span class="token operator">=</span> <span class="token string">'USA'</span><span class="token punctuation">;</span>
GO

<span class="token comment">-- 创建好视图之后，就可以像查询数据库中的其他表一样来查询视图</span>
<span class="token keyword">SELECT</span> custId<span class="token punctuation">,</span> companyName
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>USAcusts<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>因为视图是数据库中的<strong>一个对象</strong>，所以<strong>可以像其他可以查询的数据库对象一样，用权限来控制对视图的访问</strong>（如SELECT、INSERT、UPDATE、DELETE权限）。例如，可以禁止对底层数据库对象的直接访问，而只允许访问视图。</p>
<p>一般建议<strong>避免对视图使用SELECT * 语句</strong>，因为<strong>列是在编译视图时进行枚举的，新加的列可能不会自动加到视图中</strong>。例如，假设基于 SELECT * FROM dbo.T1这个查询而定义一个视图；在视图创建时，T1表有coll和col2两列。 SQL Server<strong>在视图的元数据中只会存储这两列的信息</strong>。如果以后又修改了表的定义或增加了几列，这些<strong>新增加的列不会自动添加到视图中</strong>。用一个<strong>名为sp_ refreshview的存储过程可以刷新视图的元数据</strong>，但为避免混淆，<strong>最好的开发实践就是在视图的定义中显式地列出需要的列名</strong>。如果在底层表中添加了列，而且在视图中需要这些新加的列，则<strong>可以使用 ALTER VIEW语句对视图定义进行相应的修改</strong>。</p>
<hr>
<h4 id="视图和-ORDER-BY-子句"><a href="#视图和-ORDER-BY-子句" class="headerlink" title="视图和 ORDER BY 子句"></a>视图和 ORDER BY 子句</h4><p>记住，<strong>在定义表表达式的查询语句中不允许出现 ORDER BY子句，因为关系表的行之间没有顺序</strong>。试图创建一个有序视图的想法也不合理，因为这违反了关系模型定义的关系的基本属性。</p>
<p>只有在创建视图的语句中<strong>使用了TOP或FOR XML选项</strong>，SQL Server才允许使用ORDER BY子句，<strong>这两种情况都不符合SQL标准</strong>。并且，这两种情况下的ORDER BY子句也<strong>不会用于普通的数据展示</strong>，<strong>无法保证结果集中的行顺序</strong>。</p>
<p>有时，<strong>用于定义表表达式的查询会包含TOP选项和 ORDER BY子句，而对该表表达式的查询却没有ORDER BY子句</strong>。在这些情况下，输出结果<strong>不会保证有什么特定的顺序</strong>。如果结果碰巧是有序的，<strong>可能是优化处理的原因</strong>。因此，当对表表达式进行查询时，除非在外部査询中指定了ORDER BY子句，否则不应该假定输出具有任何顺序。</p>
<hr>
<h4 id="视图选项"><a href="#视图选项" class="headerlink" title="视图选项"></a>视图选项</h4><h5 id="ENCRYPTION-选项"><a href="#ENCRYPTION-选项" class="headerlink" title="ENCRYPTION 选项"></a>ENCRYPTION 选项</h5><p>在创建或修改<strong>视图、存储过程、触发器及用户定义函数(UDF)<strong>时，都可以使用ENCRYPTION选项。如果指定ENCRYPTION选项，SQL Server在内部会</strong>对定义对象的文本信息进行混淆（obfuscated）处理</strong>。<strong>普通用户通过任何目录对象都无法直接看到这种经过混淆处理的文本，只有特权用户通过特殊手段才能访问创建对象的文本</strong>。</p>
<p>为了得到视图的定义，可以：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 调用OBJECT DEFINITION函数</span>
<span class="token keyword">SELECT</span> OBJECT_DEFINITION<span class="token punctuation">(</span>OBJECT_ID<span class="token punctuation">(</span><span class="token string">'Sales.USAcusts'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                         
<span class="token comment">-- 使用存储过程sp_helptext</span>
<span class="token keyword">EXEC</span> sp_helptext <span class="token string">'Sales.USAcusts'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>因为在创建视图时没有指定ENCRYPTION选项，所以<strong>能够直接看到定义视图的文本</strong>。那么接下来修改视图定义，来包含ENCRYPTION选项：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">VIEW</span> Sales<span class="token punctuation">.</span>USAcusts <span class="token keyword">WITH</span> ENCRYPTION
<span class="token keyword">AS</span>
<span class="token keyword">SELECT</span> custId<span class="token punctuation">,</span> companyName<span class="token punctuation">,</span> contactName<span class="token punctuation">,</span> contactTitle<span class="token punctuation">,</span> address<span class="token punctuation">,</span>
	city<span class="token punctuation">,</span> region<span class="token punctuation">,</span> postalCode<span class="token punctuation">,</span> Country<span class="token punctuation">,</span> phone<span class="token punctuation">,</span> fax
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Customers
<span class="token keyword">WHERE</span> country <span class="token operator">=</span> <span class="token string">'USA'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>此时再<strong>获取视图定义的文本，结果为NULL</strong>。</p>
<hr>
<h5 id="SCHEMABINDING-选项"><a href="#SCHEMABINDING-选项" class="headerlink" title="SCHEMABINDING 选项"></a>SCHEMABINDING 选项</h5><p>视图和UDF支持 SCHEMABINDING选项，该选项可以<strong>将对象和列的架构绑定到引用其</strong><br><strong>对象的架构</strong>。也就是说，一旦指定了这个选项，<strong>被引用的对象就不能删除，被引用的列也不能删除或修改</strong>。这样的操作是为了<strong>防止被引用的对象或列的变动导致查询视图时发生运行错误</strong>。</p>
<hr>
<h5 id="CHECK-OPTION-选项"><a href="#CHECK-OPTION-选项" class="headerlink" title="CHECK OPTION 选项"></a>CHECK OPTION 选项</h5><p>CHECK OPTION选项的目的是为了<strong>防止通过视图执行的数据修改与视图中设置的过滤</strong><br><strong>条件（假设在定义视图的查询中存在过滤条件）发生冲突</strong>。</p>
<p>上述定义USACusts视图的查询要筛选出country列等于’USA’的客户。该视图的定义目前没有CHECK OPTION选项。这意味着，现在<strong>可以通过视图把不是来自美国的客户插入表中</strong>；也可以<strong>通过视图对现有的客户进行更新</strong>，把他们的<strong>country列修改为除了美国以外的其他国家</strong>。例如如下代码。通过视图，成功插入了一个公司名称为’customerABCDE’、<strong>来自英国</strong>的客户：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Sales<span class="token punctuation">.</span>USAcusts<span class="token punctuation">(</span>
	companyname<span class="token punctuation">,</span> contactname<span class="token punctuation">,</span> contacttitle<span class="token punctuation">,</span> address<span class="token punctuation">,</span>
	city<span class="token punctuation">,</span> region<span class="token punctuation">,</span> postalcode<span class="token punctuation">,</span> country<span class="token punctuation">,</span> phone<span class="token punctuation">,</span> fax<span class="token punctuation">)</span>
<span class="token keyword">VALUES</span><span class="token punctuation">(</span>
	<span class="token string">'Customer ABCDE'</span><span class="token punctuation">,</span> <span class="token string">'contact ABCDE'</span><span class="token punctuation">,</span> <span class="token string">'TITLE ABCDE'</span><span class="token punctuation">,</span> <span class="token string">'address ABCDE'</span><span class="token punctuation">,</span>
    <span class="token string">'London'</span><span class="token punctuation">,</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span> <span class="token string">'12345'</span><span class="token punctuation">,</span> <span class="token string">'UK'</span><span class="token punctuation">,</span> <span class="token string">'012-3456789'</span><span class="token punctuation">,</span> <span class="token string">'012-3456789'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>这就是所谓的与视图的查询过滤条件相冲突的修改</strong>，只需要在定义视图的<strong>查询语句末尾加上WITH CHECK OPTION</strong>即可：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">VIEW</span> Sales<span class="token punctuation">.</span>USAcusts <span class="token keyword">WITH</span> SCHEMABINDING
<span class="token keyword">AS</span>
<span class="token keyword">SELECT</span> custId<span class="token punctuation">,</span> companyName<span class="token punctuation">,</span> contactName<span class="token punctuation">,</span> contactTitle<span class="token punctuation">,</span> address<span class="token punctuation">,</span>
	city<span class="token punctuation">,</span> region<span class="token punctuation">,</span> postalCode<span class="token punctuation">,</span> Country<span class="token punctuation">,</span> phone<span class="token punctuation">,</span> fax
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Customers
<span class="token keyword">WHERE</span> country <span class="token operator">=</span> <span class="token string">'USA'</span>
<span class="token keyword">WITH</span> <span class="token keyword">CHECK</span> <span class="token keyword">OPTION</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h3 id="内联表值函数"><a href="#内联表值函数" class="headerlink" title="内联表值函数"></a>内联表值函数</h3><p>内联表值函数是一种<strong>可重用的表表达式</strong>，<strong>支持输入参数</strong>，其他方面都<strong>与视图相似</strong>。</p>
<p>例如，以下代码在 TSQLFundamentals2008数据库中创建了一个内联表值函数fn_GetCustOrders:</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> TSQLFundamentals2008<span class="token punctuation">;</span>

<span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span>dbo<span class="token punctuation">.</span>fn_GetCustOrders<span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
	<span class="token keyword">DROP</span> <span class="token keyword">FUNCTION</span> dbo<span class="token punctuation">.</span>fn_GetCustOrders<span class="token punctuation">;</span>
	
GO <span class="token comment">-- CREATE FUNCTION必须是批处理中仅有的语句</span>
<span class="token keyword">CREATE</span> <span class="token keyword">FUNCTION</span> dbo<span class="token punctuation">.</span>fn_GetCustOrders
	<span class="token punctuation">(</span><span class="token variable">@cid</span> <span class="token keyword">INT</span><span class="token punctuation">)</span> <span class="token keyword">RETURNS</span> <span class="token keyword">TABLE</span>
<span class="token keyword">AS</span>
<span class="token keyword">RETURN</span>
    <span class="token keyword">SELECT</span> orderId<span class="token punctuation">,</span> custId<span class="token punctuation">,</span> empId<span class="token punctuation">,</span> orderDate<span class="token punctuation">,</span> requiredDate<span class="token punctuation">,</span>
        shippedDate<span class="token punctuation">,</span> shipperId<span class="token punctuation">,</span> freight<span class="token punctuation">,</span> shipName<span class="token punctuation">,</span> shipAddress<span class="token punctuation">,</span> shipCity<span class="token punctuation">,</span>
        shipRegion<span class="token punctuation">,</span> shipPostalcode<span class="token punctuation">,</span> shipCountry
    <span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders
    <span class="token keyword">WHERE</span> custid <span class="token operator">=</span> <span class="token variable">@cid</span><span class="token punctuation">;</span>
GO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>以下代码将内联表值函数与Sales.OrderDetails表进行连接，对客户1的订单和相关的订单明细进行匹配：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> CO<span class="token punctuation">.</span>orderId<span class="token punctuation">,</span> CO<span class="token punctuation">.</span>custId<span class="token punctuation">,</span> OD<span class="token punctuation">.</span>productId<span class="token punctuation">,</span> OD<span class="token punctuation">.</span>qty
<span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>fn_GetCustOrders<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> CO
	<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> Sales<span class="token punctuation">.</span>OrderDetails <span class="token keyword">AS</span> OD
		<span class="token keyword">ON</span> CO<span class="token punctuation">.</span>orderId <span class="token operator">=</span> OD<span class="token punctuation">.</span>orderId<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h3 id="APPLY-运算符"><a href="#APPLY-运算符" class="headerlink" title="APPLY 运算符"></a>APPLY 运算符</h3><p>APPLY运算符是SQL Server的一个<strong>非标准</strong>表运算符，和其他表运算符一样，这个运算符也<strong>在查询的FROM子句中使用</strong>。APPLY运算符对两个输入表进行操作，其中<strong>第二个可以是一个表表达式</strong>，我们将它们分別称为左表和右表。右表<strong>通常是一个派生表或内联表值函数</strong>。APPLY运算符支持两种形式：CROSS APPLY和OUTER APPLY。 </p>
<hr>
<h4 id="CROSS-APPLY"><a href="#CROSS-APPLY" class="headerlink" title="CROSS APPLY"></a>CROSS APPLY</h4><p>实现了一个<strong>逻辑査询处理</strong>步骤，把右表表达式应用到左表中的每一行，再把结果集组合起来，生成一个统一的结果表。就目前来看，<strong>CROSS APPLY运算符与交叉连接CROSS JOIN非常类似</strong>：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> S<span class="token punctuation">.</span>shipperId<span class="token punctuation">,</span> E<span class="token punctuation">.</span>empId
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Shippers <span class="token keyword">AS</span> S
	<span class="token keyword">CROSS</span> <span class="token keyword">JOIN</span> HR<span class="token punctuation">.</span>Employees <span class="token keyword">AS</span> E<span class="token punctuation">;</span>
	
<span class="token keyword">SELECT</span> S<span class="token punctuation">.</span>shipperId<span class="token punctuation">,</span> E<span class="token punctuation">.</span>empId
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Shippers <span class="token keyword">AS</span> S
	<span class="token keyword">CROSS</span> <span class="token keyword">APPLY</span> HR<span class="token punctuation">.</span>Employees <span class="token keyword">AS</span> E<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>但是，与连接不同的是，当使用CROSS APPLY操作符时，<strong>对于左表中的每一行，右表表达式可能代表不同的数据行集合</strong>。为此，<strong>可以在右边使用一个派生表，在派生表的查询中去引用左表列</strong>；也可以<strong>使用内联表值函数，把左表中的列作为输入参数进行传递</strong>。</p>
<p>例如，以下代码使用CROSS APPLY运算符返回<strong>每个客户最新的三个订单</strong>：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> C<span class="token punctuation">.</span>custId<span class="token punctuation">,</span> A<span class="token punctuation">.</span>orderId<span class="token punctuation">,</span> A<span class="token punctuation">.</span>orderDate
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Customers <span class="token keyword">AS</span> C
	<span class="token keyword">CROSS</span> <span class="token keyword">APPLY</span>
		<span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token keyword">TOP</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> orderId<span class="token punctuation">,</span> empId<span class="token punctuation">,</span> orderDate<span class="token punctuation">,</span> requiredDate
		 <span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders <span class="token keyword">AS</span> O
         <span class="token keyword">WHERE</span> O<span class="token punctuation">.</span>custId <span class="token operator">=</span> C<span class="token punctuation">.</span>custId
         <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> orderDate <span class="token keyword">DESC</span><span class="token punctuation">,</span> orderId <span class="token keyword">DESC</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> A<span class="token punctuation">;</span>
         
<span class="token comment">-- 利用 表子查询 + 排名函数ROW_NUMBER + OVER子句能达到相同效果</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> <span class="token punctuation">(</span>
<span class="token keyword">SELECT</span> C<span class="token punctuation">.</span>custId<span class="token punctuation">,</span> O<span class="token punctuation">.</span>orderId<span class="token punctuation">,</span> O<span class="token punctuation">.</span>orderDate<span class="token punctuation">,</span>
		ROW_NUMBER<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span><span class="token punctuation">(</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> C<span class="token punctuation">.</span>custId <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> orderDate <span class="token keyword">DESC</span><span class="token punctuation">,</span> orderId <span class="token keyword">DESC</span><span class="token punctuation">)</span> rn <span class="token comment">-- 没有订单时，有一行NULL值，会被赋予rn = 1</span>
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Customers <span class="token keyword">AS</span> C
	<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> Sales<span class="token punctuation">.</span>Orders <span class="token keyword">AS</span> O
		<span class="token keyword">ON</span> C<span class="token punctuation">.</span>custid <span class="token operator">=</span> O<span class="token punctuation">.</span>custid<span class="token punctuation">)</span> A
<span class="token keyword">WHERE</span> rn <span class="token operator">&lt;=</span> <span class="token number">3</span> <span class="token operator">and</span> orderID <span class="token operator">is</span> <span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">;</span> <span class="token comment">-- 剔除没有订单的客户</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以把上面查询中的表表达式A看作是一个相关表子查询。就逻辑处理来说，右表表达式要应用于Customers表的每一行。注意，在派生表的查询过滤条件中引用了来自左表的列C.custId。派生表<strong>为左表当前行的客户返回他的3个最新订单</strong>。<strong>对左表的每一行应用派生表，CROSS APPLY运算符就可以返回每个客户最新的3个订单</strong>。</p>
<p>出于<strong>封装</strong>的目的，<strong>内联表值函数比派生表用起来更方便</strong>，<strong>代码也更容易理解和维护</strong>。例如，以下代码创建了一个内联表值函数fn_TopOrders，它的输入参数是一个客户ID(@custId)和一个数量(@n),为客户@custId返回其最新的@n个订单：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">IF OBJECT_ID(&#39;fn_TopOrders&#39;) IS NOT NULL
	DROP FUNCTION dbo.fn_TopOrders;
    
GO
CREATE FUNCTION dbo.fn_TopOrders
	(@custId INT, @n INT) RETURN TABLE
AS
RETURN
	SELECT TOP(@n) orderId, empId, orderDate, requiredDate
	FROM Sales.Orders
	WHERE custId &#x3D; @custId
	ORDER BY orderDate DESC, orderId DESC;
GO

SELECT C.custId, A.orderId, A.orderDate 
FROM Sales.Customers AS C
	CROSS APPLY dbo.fn_TopOrders(C.custId, 3) AS A;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这样一来，代码就更容易理解和维护了。就物理处理来说，不会发生任何变化，<strong>SQL Server在执行査询时会扩展表表达式的定义</strong>，在任何情况下，<strong>最终都会直接査询底层对象</strong>。</p>
<p>如果右表表达式<strong>返回的是一个空集</strong>， CROSS ALLPY运算符则<strong>不会返回相应左边的数据行</strong>。如果要在右表表达式<strong>返回空集时也照样返回相应左表中的行</strong>，则可以<strong>用OUTER APPLY运算符代替CROSS APPLY</strong>。</p>
<hr>
<h4 id="OUTER-APPLY"><a href="#OUTER-APPLY" class="headerlink" title="OUTER APPLY"></a>OUTER APPLY</h4><p>OUTER APPLY运算符在<strong>逻辑査询处理</strong>步骤之外，增加了一个逻辑处理阶段：<strong>标识出让右表表达式返回空集的左表中的数据行，并把这些行作为外部行添加到结果表中，来自右表表达式的列用NULL作为占位符</strong>。</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT C.custId, A.orderId, A.orderDate
FROM Sales.Customers AS C
	OUTER APPLY
		(SELECT TOP(3) orderId, empId, orderDate, requiredDate
		 FROM Sales.Orders AS O
         WHERE O.custId &#x3D; C.custId
         ORDER BY orderDate DESC, orderId DESC) AS A;
         
-- 利用 表子查询 + 排名函数ROW_NUMBER + OVER子句能达到相同效果
SELECT *
FROM (
SELECT C.custId, O.orderId, O.orderDate,
		ROW_NUMBER() OVER(PARTITION BY C.custId ORDER BY orderDate DESC, orderId DESC) rn -- 没有订单时，有一行NULL值，会被赋予rn &#x3D; 1
FROM Sales.Customers AS C
	LEFT JOIN Sales.Orders AS O
		ON C.custid &#x3D; O.custid) A
WHERE rn &lt;&#x3D; 3;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><p>T-SQL支持3种集合运算：</p>
<ol>
<li>并集（<strong>UNION</strong>）</li>
<li>交集（<strong>INTERSECT</strong>）</li>
<li>差集（<strong>EXCEPT</strong>）</li>
</ol>
<p>按照定义，集合运算是在两个集合（或多集）之间进行的运算，而且<strong>集合本身是无序的</strong>，所以，<strong>集合运算涉及的两个查询不能包含 ORDER BY子句</strong>。<strong>包含 ORDER BY子句的查询可以确保结果的排列顺序，因此，这样的查询返回的不是集合，而是游标( cursor)</strong>。虽然运算涉及的查询不能包含 ORDER BY子句，但<strong>可以为整个集合运算结果选择性地增加一个 ORDER BY子句</strong>。</p>
<p>集合运算有个有趣的特点：<strong>对行进行比较时，集合运算认为两个NULL相等</strong>。</p>
<p><strong>ANSI SQL</strong>对每种集合运算都支持两个选项：<strong>DISTINCT（默认值）<strong>和</strong>ALL</strong>。<strong>SQL Server 2008</strong>对3种集合运算，均支持DISTINCT选项，<strong>但只在UNION中支持ALL选项</strong>。按照语法要求，<strong>不能显式指定DISTINCT子句，但如果不显式指定ALL，则默认使用DISTINCT</strong>。</p>
<hr>
<h3 id="UNION-集合运算"><a href="#UNION-集合运算" class="headerlink" title="UNION 集合运算"></a>UNION 集合运算</h3><p>从<strong>逻辑处理过程</strong>来看，UNION（隐含DISTINCT）集合运算通过删除重复记录，可以把两个输入的多集转变为一个集合，<strong>即使只在一个输入中有重复的行，结果中也会只出现一次</strong>。</p>
<p>从<strong>物理处理过程</strong>来看，SQL Server<strong>不一定必须先删除输入多集中的重复行，再进行集合运算</strong>，相反，<strong>它可以先把两个多集组合在一起，然后再删除重复行</strong>。</p>
<p>如果在合并两个输入集以后不可能会出现重复行，建议使用UNION ALL，以避免SQL Server为检查重复行而带来的额外开销。</p>
<hr>
<h3 id="INTERSECT-集合运算"><a href="#INTERSECT-集合运算" class="headerlink" title="INTERSECT 集合运算"></a>INTERSECT 集合运算</h3><h4 id="INTERSECT-DISTINCT-集合运算"><a href="#INTERSECT-DISTINCT-集合运算" class="headerlink" title="INTERSECT DISTINCT 集合运算"></a>INTERSECT DISTINCT 集合运算</h4><p>如果一个行在两个输入多集中都至少出现一次，那么交集返回的结果中将包含这一行。例如，以下代码返回既是雇员地址，也是客户地址的不同地址：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> country<span class="token punctuation">,</span> region<span class="token punctuation">,</span> city <span class="token keyword">FROM</span> HR<span class="token punctuation">.</span>Employees
<span class="token keyword">INTERSECT</span>
<span class="token keyword">SELECT</span> country<span class="token punctuation">,</span> region<span class="token punctuation">,</span> city <span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Customers<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>前面讲过，<strong>集合运算对行进行比较时，认为两个NUL值相等</strong>。如果客户和雇员地址中均包含(UK, <strong>NULL</strong>, London)这个地址，<strong>它能在输出中出现非比寻常</strong>。除了country和city列以外，<strong>当对雇员行中取值为NULL的region列和客户行中取值为NULL的 region列进行比较时，集合运算认为二者相等</strong>，所以就返回该行记录。</p>
<p>这种对NULL值的处理方式有一定的优势。例如，<strong>代替INTERSECT集合运算</strong>的一种方法是使用<strong>内连接INNER JOIN</strong>，另一种方法是使用<strong>EXISTS谓词</strong>。在这两种情况下，当对雇员表region列中的NULL值和客户表region列中的NULL值进行比较时，<strong>比较结果都是UNKNOWN，这样的行将被过滤掉</strong>。因此，<strong>除非增加额外的逻辑，以特定方式对NULL进行处理，否则即使(UK, NULL, London)这行记录在运算两边的表中都出现，内连接和 EXISTS的实现方法都不能返回该行</strong>。</p>
<hr>
<h4 id="INTERSECT-ALL-集合运算"><a href="#INTERSECT-ALL-集合运算" class="headerlink" title="INTERSECT ALL 集合运算"></a>INTERSECT ALL 集合运算</h4><p><strong>ANSI SQL支持带有ALL选项的INTERSECT集合运算</strong>，但<strong>SQL Server 2008还没有实现这种运算</strong>。INTERSECT ALL与UNION ALL不同，前者<strong>不会返回所有重复行，而只返回重复行数目较少的那个多集的所有重复行</strong>。</p>
<p>虽然 SQL Server不支持内建的 INTERSECT ALL运算，但用其他解决方案也能生成相同的结果。<strong>可以用ROW NUMBER函数来计算每个输入查询中每行的出现次数（行号）</strong>。为此，在函数的PARTITION BY子句中指定所有参与集合运算的列，并<strong>在 ORDER BY子句中用 SELECT&lt;常量&gt;来表明行的排列顺序不重要</strong>，接着<strong>再对两个带有ROW_NUMBER函数的查询应用INTERSECT集合运算</strong>。</p>
<p>在排序函数的OVER子句中使用**ORDER BY( SELECT&lt;常量&gt;)**用这种方法可以告诉 SQL Server不必在意行的顺序。 <strong>SQL Server足够聪明，它能够意识到将要为所有行分配同一常量，因此，没有必要对数据进行排序，更没有必要为此付出一定的代价</strong>。</p>
<p>例如，地址(UK, NULL, London)在Employees表中出现了4次，它们的出现次数分别编为1~4。在Customers表中，地址(UK, NULL, London)出现了6次，其出现次数分别编为1-6。对这两个输入集取其交集时，出现次数编号为1-4的所有行就是它们的交集。<br>以下是这个解决方案的完整查询语句：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> ROW_NUMBER<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span><span class="token punctuation">(</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> country<span class="token punctuation">,</span> region<span class="token punctuation">,</span> city
                         <span class="token keyword">ORDER</span> <span class="token keyword">BY</span><span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> rowNum<span class="token punctuation">,</span>
       country<span class="token punctuation">,</span> region<span class="token punctuation">,</span> city
<span class="token keyword">FROM</span> HR<span class="token punctuation">.</span>Employees
<span class="token keyword">INTERSECT</span>
<span class="token keyword">SELECT</span> ROW_NUMBER<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span><span class="token punctuation">(</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> country<span class="token punctuation">,</span> region<span class="token punctuation">,</span> city
                         <span class="token keyword">ORDER</span> <span class="token keyword">BY</span><span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> rowNum<span class="token punctuation">,</span>
       country<span class="token punctuation">,</span> region<span class="token punctuation">,</span> city
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Customers<span class="token punctuation">;</span>


<span class="token comment">-- 如果不想返回行号，则可以在以上基础上【定义一个表表达式（如CTE）】</span>
<span class="token keyword">WITH</span> INTERSECT_ALL
<span class="token keyword">AS</span>
<span class="token punctuation">(</span>
	<span class="token keyword">SELECT</span> ROW_NUMBER<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span><span class="token punctuation">(</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> country<span class="token punctuation">,</span> region<span class="token punctuation">,</span> city
                         	 <span class="token keyword">ORDER</span> <span class="token keyword">BY</span><span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> rowNum<span class="token punctuation">,</span>
           country<span class="token punctuation">,</span> region<span class="token punctuation">,</span> city
    <span class="token keyword">FROM</span> HR<span class="token punctuation">.</span>Employees
    <span class="token keyword">INTERSECT</span>
    <span class="token keyword">SELECT</span> ROW_NUMBER<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span><span class="token punctuation">(</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> country<span class="token punctuation">,</span> region<span class="token punctuation">,</span> city
                             <span class="token keyword">ORDER</span> <span class="token keyword">BY</span><span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> rowNum<span class="token punctuation">,</span>
           country<span class="token punctuation">,</span> region<span class="token punctuation">,</span> city
    <span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Customers
<span class="token punctuation">)</span>
<span class="token keyword">SELECT</span> country<span class="token punctuation">,</span> region<span class="token punctuation">,</span> city
<span class="token keyword">FROM</span> INTERSECT_ALL<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h3 id="EXCEPT-集合运算"><a href="#EXCEPT-集合运算" class="headerlink" title="EXCEPT 集合运算"></a>EXCEPT 集合运算</h3><p>EXCEPT运算对两个输入查询的结果集进行操作，返回<strong>出现在第一个结果集中，但不出现在第二个结果集中的所有行</strong>。</p>
<hr>
<h4 id="EXCEPT-DISTINCT-集合运算"><a href="#EXCEPT-DISTINCT-集合运算" class="headerlink" title="EXCEPT DISTINCT 集合运算"></a>EXCEPT DISTINCT 集合运算</h4><p>EXCEPT集合运算<strong>在逻辑上先删除两个输入多集中的重复行（把多集转变成集合）</strong>，然后返回只在第一个集合中出现，在第二个集合中不出现的所有行。</p>
<p>EXCEPT运算也可以用其他方法来实现。一种方法是使用<strong>外连接</strong>，筛选出在连接左边出现而在右边不出现的外部行。另一种方法是使用<strong>NOT EXISTS谓词</strong>。不过，<strong>如果你认为两个NUL值是相等的，集合运算默认才具有这样的行为</strong>，所以无须增加额外的处理，但其他两种方法不支持该操作。</p>
<hr>
<h4 id="EXCEPT-ALL-集合运算"><a href="#EXCEPT-ALL-集合运算" class="headerlink" title="EXCEPT ALL 集合运算"></a>EXCEPT ALL 集合运算</h4><p>虽然 SQL Server没有提供内建的 EXCEPT ALL运算，但用与 INTERSECT ALL的解决方案类似的方法，也可以为 EXCEPT ALL提供替代的解决方案。也就是为每个输入查询增加一个ROW NUMBER计算，算出每行是第几次出现，再对两个输入集应用 EXCEPT运算。这样就只返回出现次数找不到匹配的行。</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">WITH EXCEPT_ALL
AS
(
	SELECT ROW_NUMBER() OVER(PARTITION BY country, region, city
                         	 ORDER BY(SELECT 0)) AS rowNum,
           country, region, city
    FROM HR.Employees
    EXCEPT
    SELECT ROW_NUMBER() OVER(PARTITION BY country, region, city
                             ORDER BY(SELECT 0)) AS rowNum,
           country, region, city
    FROM Sales.Customers
)
SELECT country, region, city
FROM EXCEPT_ALL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h3 id="集合运算的优先级"><a href="#集合运算的优先级" class="headerlink" title="集合运算的优先级"></a>集合运算的优先级</h3><p>SQL定义了集合运算之间的优先级。 <strong>INTERSECT运算优先级最高</strong>，而<strong>UNION和EXCEPT的优先级相等</strong>。在包含多个集合运算的查询中，首先计算INTERSECT，然后按照从左到右的出现顺序依次处理优先级相同的运算。当然，要控制集合运算的计算顺序，可以使用圆括号，它总是具有最高的优先级。</p>
<hr>
<h2 id="透视、逆透视及分组集"><a href="#透视、逆透视及分组集" class="headerlink" title="透视、逆透视及分组集"></a>透视、逆透视及分组集</h2><ul>
<li>透视转换：把数据从<strong>行</strong>的状态旋转为列的状态。</li>
<li><strong>逆</strong>透视转换：把数据从<strong>列</strong>的状态旋转为<strong>行</strong>的状态。</li>
<li>分组集：用于分组的属性集合。</li>
</ul>
<hr>
<h3 id="透视转换（PIVOT）"><a href="#透视转换（PIVOT）" class="headerlink" title="透视转换（PIVOT）"></a>透视转换（PIVOT）</h3><p>透视数据（<strong>pivoting</strong>）是一种<strong>把数据从行的状态旋转为列的状态</strong>的处理，在这个过程中<strong>可</strong><br><strong>能需要对值进行聚合</strong>。</p>
<p>本章通篇使用的是一个示例数据表Orders，详见如下代码：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> tempdb<span class="token punctuation">;</span>
<span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'dbo.Orders'</span><span class="token punctuation">,</span> <span class="token string">'U'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> 
	<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Orders<span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Orders
<span class="token punctuation">(</span>
	orderId <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    orderDate <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    empId <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    custId <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    qty <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    <span class="token keyword">CONSTRAINT</span> PK_Orders <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>orderid<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>Orders<span class="token punctuation">(</span>orderid<span class="token punctuation">,</span> orderdate<span class="token punctuation">,</span> empid<span class="token punctuation">,</span> custid<span class="token punctuation">,</span> qty<span class="token punctuation">)</span>
<span class="token keyword">VALUES</span>
<span class="token punctuation">(</span><span class="token number">30001</span><span class="token punctuation">,</span> <span class="token string">'20070802'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">(</span><span class="token number">10001</span><span class="token punctuation">,</span> <span class="token string">'20071224'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">(</span><span class="token number">10005</span><span class="token punctuation">,</span> <span class="token string">'20071224'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">(</span><span class="token number">40001</span><span class="token punctuation">,</span> <span class="token string">'20080109'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">(</span><span class="token number">10006</span><span class="token punctuation">,</span> <span class="token string">'20080118'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">(</span><span class="token number">20001</span><span class="token punctuation">,</span> <span class="token string">'20080212'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">(</span><span class="token number">40005</span><span class="token punctuation">,</span> <span class="token string">'20090212'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">(</span><span class="token number">20002</span><span class="token punctuation">,</span> <span class="token string">'20090216'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">(</span><span class="token number">30003</span><span class="token punctuation">,</span> <span class="token string">'20090418'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">(</span><span class="token number">30004</span><span class="token punctuation">,</span> <span class="token string">'20070418'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">(</span><span class="token number">30007</span><span class="token punctuation">,</span> <span class="token string">'20090907'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>Orders<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>先考虑一个需求，生成一个报表，包含每个雇员和客户组合之间的总订货量：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> empId<span class="token punctuation">,</span> custId<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>qty<span class="token punctuation">)</span> <span class="token keyword">AS</span> sumQty
<span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>Orders
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> empId<span class="token punctuation">,</span> custId<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>该查询生成下列输出：</p>
<table>
<thead>
<tr>
<th>empId</th>
<th>custId</th>
<th>sumQty</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>A</td>
<td>52</td>
</tr>
<tr>
<td>3</td>
<td>A</td>
<td>20</td>
</tr>
<tr>
<td>1</td>
<td>B</td>
<td>20</td>
</tr>
<tr>
<td>2</td>
<td>B</td>
<td>27</td>
</tr>
<tr>
<td>1</td>
<td>C</td>
<td>34</td>
</tr>
<tr>
<td>3</td>
<td>C</td>
<td>22</td>
</tr>
<tr>
<td>3</td>
<td>D</td>
<td>30</td>
</tr>
</tbody></table>
<p>现在要求按如下格式（<strong>行为雇员，列为客户，值为总订货量</strong>）来生成输出结果：</p>
<table>
<thead>
<tr>
<th>empId</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>NULL</td>
<td>20</td>
<td>34</td>
<td>NULL</td>
</tr>
<tr>
<td>2</td>
<td>52</td>
<td>27</td>
<td>NULL</td>
<td>NULL</td>
</tr>
<tr>
<td>3</td>
<td>20</td>
<td>NULL</td>
<td>22</td>
<td>30</td>
</tr>
</tbody></table>
<p>上表是对Orders表中的数据进行<strong>聚合</strong>和<strong>透视转换</strong>后的视图，用于生成数据的这种视图的技术被称为透视转换。透视转换<strong>涉及三个逻辑处理阶段</strong>，每个阶段都有相关的元素：</p>
<ol>
<li><strong>分组</strong>阶段：处理相关的分组或<strong>行</strong>元素</li>
<li><strong>扩展（spreading）<strong>阶段：处理相关的扩展或</strong>列</strong>元素</li>
<li><strong>聚合</strong>阶段：处理相关的<strong>聚合元素</strong>和<strong>聚合函数</strong></li>
</ol>
<p>上述例子中，必须要在结果中<strong>为每个唯一的雇员ID生成一行记录</strong>。这就要求对Orders表中的行<strong>按照empId列分组</strong>。Orders表分别用一个列来保存所有的客户ID值和他们的订货量。透视处理应该<strong>为每个唯一的客户ID生成一个不同的结果列，用于保存该客户的聚合订货量</strong>。可以将这个处理看作是根据客户ID来<strong>扩展</strong>订货聚合量的过程，本例中的扩展元素为custId列。最后，由于透视转换<strong>涉及分组</strong>，所以<strong>需要对数据进行聚合</strong>，以生成<strong>分组元素</strong>和<strong>扩展元素</strong>的<strong>交叉位置上的结果值</strong>，这就需要标识聚合函数和聚合元素（本例中为SUM函数和qty列）。</p>
<p>总之，透视转换涉及<strong>分组、扩展及聚合三个阶段</strong>。本例按照empId进行分组，按照custId对订货量进行扩展，最后进行聚合SUM(qty)。在弄清楚透视转换<strong>涉及的元素</strong>以后，剩下的任务就是在透视转换的某个<strong>通用查询模板</strong>中把这些元素组装在合适的位置上。下面将介绍两种透视转换的解决方案：</p>
<ol>
<li>标准SQL的解决方案</li>
<li>T-SQL特定的PVOT运算符的解决方案</li>
</ol>
<hr>
<h4 id="使用标准SQL进行透视转换"><a href="#使用标准SQL进行透视转换" class="headerlink" title="使用标准SQL进行透视转换"></a>使用标准SQL进行透视转换</h4><p>透视转换的标准解决方案以一种<strong>非常直接的方式</strong>来处理转换过程中涉及的三个阶段：</p>
<ol>
<li>分组阶段用 GROUP BY子句实现；</li>
<li>扩展阶段通过在 SELECT子句中<strong>为每个目标列指定CASE表达式来实现</strong>。这需要<strong>事先知道每个扩展元素的取值</strong>，并为每个值指定一个单独的CASE表达式；<strong>如果不知道需要扩展的值，而且希望从数据中查询这些值，就得用动态SQL（第10章）去构建查询字符串</strong>；</li>
<li>聚合阶段通过<strong>为每个CASE表达式的结果应用相关的聚合函数</strong>来实现。</li>
</ol>
<p>以下是对订单数据进行透视转换解决方案的完整査询语句，返回每个雇员（按行）和客户（按列）的总订货量：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> empId<span class="token punctuation">,</span>
	<span class="token function">SUM</span><span class="token punctuation">(</span><span class="token keyword">CASE</span> <span class="token keyword">WHEN</span> custId <span class="token operator">=</span> <span class="token string">'A'</span> <span class="token keyword">THEN</span> qty <span class="token keyword">END</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> A<span class="token punctuation">,</span>
	<span class="token function">SUM</span><span class="token punctuation">(</span><span class="token keyword">CASE</span> <span class="token keyword">WHEN</span> custId <span class="token operator">=</span> <span class="token string">'B'</span> <span class="token keyword">THEN</span> qty <span class="token keyword">END</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> B<span class="token punctuation">,</span>
	<span class="token function">SUM</span><span class="token punctuation">(</span><span class="token keyword">CASE</span> <span class="token keyword">WHEN</span> custId <span class="token operator">=</span> <span class="token string">'C'</span> <span class="token keyword">THEN</span> qty <span class="token keyword">END</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> C<span class="token punctuation">,</span>
	<span class="token function">SUM</span><span class="token punctuation">(</span><span class="token keyword">CASE</span> <span class="token keyword">WHEN</span> custId <span class="token operator">=</span> <span class="token string">'D'</span> <span class="token keyword">THEN</span> qty <span class="token keyword">END</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> D
<span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>Orders
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> empId<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h4 id="使用T-SQL-PIVOT运算符进行透视转换"><a href="#使用T-SQL-PIVOT运算符进行透视转换" class="headerlink" title="使用T-SQL PIVOT运算符进行透视转换"></a>使用T-SQL PIVOT运算符进行透视转换</h4><p>和其他表运算符类（如JOIN）类似，PIVOT运算符也是<strong>在FROM子句上下文中执行操作</strong>。它对某个源表或表表达式进行操作、透视数据，再返回一个结果表：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">FROM</span> <span class="token operator">&lt;</span>sourceTable_or_tableExpression<span class="token operator">></span>
	<span class="token keyword">PIVOT</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>agg_func<span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&lt;</span>aggregation_element<span class="token operator">></span><span class="token punctuation">)</span>
          <span class="token keyword">FOR</span> <span class="token operator">&lt;</span>spreading_element<span class="token operator">></span>
         	<span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>list_of_targretColumns<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token operator">&lt;</span>resultTableAlias<span class="token operator">></span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在PIVOT运算符的圆括号内要指定聚合函数、聚合元素、<strong>扩展元素（列）<strong>及</strong>目标列名的列表</strong>。在PIVOT运算的圆括号后面，可以为结果表指定一个别名。</p>
<p>对于PIVOT运算符有个重要的地方需要注意：<strong>不需要显式指定分组元素，也就不需要在查询中使用GROUP BY子句</strong>。PIVOT运算符<strong>隐式地把源表（或表表达式）中既没有指定为扩展元素，也没有指定为聚合元素的那些元素作为分组元素</strong>。所以在使用PIVOT运算符时，<strong>必须保证PIVOT运算符的源表除了分组、扩展和聚合元素以外，不能再包含其他属性（列）</strong>，为此，<strong>一般不直接把PIVOT运算符应用到源表，而是将其应用到一个表表达式</strong>。</p>
<p>上述例子使用PIVOT运算符的写法：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> empId<span class="token punctuation">,</span> A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">,</span> D
<span class="token keyword">FROM</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> empId<span class="token punctuation">,</span> custId<span class="token punctuation">,</span> qty
      <span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>Orders<span class="token punctuation">)</span> <span class="token keyword">AS</span> D
	<span class="token keyword">PIVOT</span><span class="token punctuation">(</span><span class="token function">SUM</span><span class="token punctuation">(</span>qty<span class="token punctuation">)</span> <span class="token keyword">FOR</span> custId <span class="token operator">IN</span> <span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">,</span> D<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> P<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>为了深刻理解这里<strong>为什么要求使用表表达式</strong>，可以看如下直接对Orders表应用PIVOT运算符的查询：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> empId<span class="token punctuation">,</span> A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">,</span> D
<span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>Orders
	<span class="token keyword">PIVOT</span><span class="token punctuation">(</span><span class="token function">SUM</span><span class="token punctuation">(</span>qty<span class="token punctuation">)</span> <span class="token keyword">FOR</span> custId <span class="token operator">IN</span> <span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">,</span> D<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> P<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>Orders表包含orderId、orderDate、empId、custId和qty列，上述查询会<strong>默认将orderId、orderDate、empId认为是分组元素</strong>。因此，<strong>强烈建议不要直接对基础表进行操作，即使表中只包含用于透视转换的列</strong>。因为<strong>我们无法预测将来是否会向表中添加新列，从而让查询产生不正确的结果</strong>。</p>
<hr>
<h3 id="逆透视转换（UNPIVOT）"><a href="#逆透视转换（UNPIVOT）" class="headerlink" title="逆透视转换（UNPIVOT）"></a>逆透视转换（UNPIVOT）</h3><p>逆透视转换（<strong>unpivoting</strong>）是一种<strong>把数据从列的状态旋转为行的状态</strong>的技术。通常，它涉及查询数据的透视状态，<strong>将来自单个记录中多个列的值扩展为单个列中具有相同值的多个记录</strong>。换句话说，把透视表中的<strong>每个源行潜在地转换成多个行，每行代表原透视表的一个指定的列值</strong>。</p>
<p>接下来我们通过一个实例来理解。先在tempdb数据库中创建并填充EmpCustOrders表：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'dbo. Empcustorders'</span><span class="token punctuation">,</span><span class="token string">'U'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> 
	<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>EmpCustOrders<span class="token punctuation">;</span>
	
<span class="token keyword">SELECT</span> empId<span class="token punctuation">,</span> A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">,</span> D
<span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>EmpCustOrders
<span class="token keyword">FROM</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> empId<span class="token punctuation">,</span> custId<span class="token punctuation">,</span> qty
      <span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>Orders<span class="token punctuation">)</span> <span class="token keyword">As</span> D
	<span class="token keyword">PIVOT</span><span class="token punctuation">(</span><span class="token function">SUM</span><span class="token punctuation">(</span>qty<span class="token punctuation">)</span> <span class="token keyword">FOR</span> custId <span class="token operator">IN</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">,</span> D<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> P<span class="token punctuation">;</span>
	
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>EmpCustOrders<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>现在对EmpCustOrders表进行逆透视转换数据，为每个雇员和客户组合返回一行记录，其中包含这一组合的订货量。期望的输出结果如下：</p>
<table>
<thead>
<tr>
<th>empId</th>
<th>custId</th>
<th>sumQty</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>A</td>
<td>52</td>
</tr>
<tr>
<td>3</td>
<td>A</td>
<td>20</td>
</tr>
<tr>
<td>1</td>
<td>B</td>
<td>20</td>
</tr>
<tr>
<td>2</td>
<td>B</td>
<td>27</td>
</tr>
<tr>
<td>1</td>
<td>C</td>
<td>34</td>
</tr>
<tr>
<td>3</td>
<td>C</td>
<td>22</td>
</tr>
<tr>
<td>3</td>
<td>D</td>
<td>30</td>
</tr>
</tbody></table>
<hr>
<h4 id="使用标准-SQL-进行逆透视转换"><a href="#使用标准-SQL-进行逆透视转换" class="headerlink" title="使用标准 SQL 进行逆透视转换"></a>使用标准 SQL 进行逆透视转换</h4><p>逆透视转换的标准SQL解决方案非常明确地要实现<strong>3个逻辑处理阶</strong>段：</p>
<ol>
<li><p><strong>生成副本</strong>（为<strong>需要逆透视的每个列生成一个副本</strong>）</p>
<p> 在关系代数和SQL中，可以<strong>用笛卡尔积（交叉连接CROSS JOIN）来生成每一行的多个副本</strong>。为此，需要在EmpCustOrders表和<strong>一个每行代表一个客户的表</strong>之间进行交叉连接。</p>
<p> 从SQL Server 2008开始，可以<strong>用表值构造函数，按照VALUES子句的格式来创建一个虚拟表</strong>，该表中<strong>每个客户对应一行记录</strong>。</p>
 <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>EmpCustOrders
	<span class="token keyword">CROSS</span> <span class="token keyword">JOIN</span> <span class="token punctuation">(</span><span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'C'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'D'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> Custs<span class="token punctuation">(</span>custId<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
<span class="token comment">-- SQL Server 2008之前，需要把上述VALUES子句替换为一系列的SELECT语句，每条---- SELECT语句根据常量构造一行记录，并在各SELECT语句之间用UNION ALL集合运算组合</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>EmpCustOrders
	<span class="token keyword">CROSS</span> <span class="token keyword">JOIN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token string">'A'</span> <span class="token keyword">AS</span> custId
                <span class="token keyword">UNION</span> <span class="token keyword">ALL</span> <span class="token keyword">SELECT</span> <span class="token string">'B'</span>
                <span class="token keyword">UNION</span> <span class="token keyword">ALL</span> <span class="token keyword">SELECT</span> <span class="token string">'C'</span>
                <span class="token keyword">UNION</span> <span class="token keyword">ALL</span> <span class="token keyword">SELECT</span> <span class="token string">'D'</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> Custs<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>提取元素</strong>和<strong>删除不相关的交叉</strong></p>
<p> 生成一个数据列，返回<strong>与当前副本所代表的客户相对应的列值</strong>。</p>
<p> 具体到本例，如果当前custId的值为A，则qty列应该返回A列的值，以此类推。用一个简单的CASE表达式就可以实现这一步：</p>
 <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> empid<span class="token punctuation">,</span> custid<span class="token punctuation">,</span>        
      	<span class="token punctuation">(</span><span class="token keyword">CASE</span> custid
            <span class="token keyword">WHEN</span> <span class="token string">'A'</span> <span class="token keyword">THEN</span> A
            <span class="token keyword">WHEN</span> <span class="token string">'B'</span> <span class="token keyword">THEN</span> B
            <span class="token keyword">WHEN</span> <span class="token string">'C'</span> <span class="token keyword">THEN</span> C
            <span class="token keyword">WHEN</span> <span class="token string">'D'</span> <span class="token keyword">THEN</span> D
         <span class="token keyword">END</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> qty
       <span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>EmpCustOrders
      		<span class="token keyword">CROSS</span> <span class="token keyword">JOIN</span> <span class="token punctuation">(</span><span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'C'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'D'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> Custs<span class="token punctuation">(</span>custId<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> D
<span class="token keyword">WHERE</span> qty <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span> <span class="token comment">-- 原始表中NULL值代表不相关的交叉</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<hr>
<h4 id="使用-T-SQL-的-UNPIVOT-运算符进行逆透视转换"><a href="#使用-T-SQL-的-UNPIVOT-运算符进行逆透视转换" class="headerlink" title="使用 T-SQL 的 UNPIVOT 运算符进行逆透视转换"></a>使用 T-SQL 的 UNPIVOT 运算符进行逆透视转换</h4><p>对数据进行逆透视转换时，会<strong>为源表中想要进行逆透视的任意列生成两个结果列</strong>。在这<br>个例子中，须要对源表列A、B、C和D进行逆透视，为它们生成两个结果列custId和qty，前者用于保存源表列的名称(“A”、“B”、“C”及“D”)，后者用于保存源表列的值（本例为订货量）。使用UNPVOT运算符的査询语句的一般格式为：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">FROM</span> <span class="token operator">&lt;</span>sourceTable_or_tableExpression<span class="token operator">></span>
	<span class="token keyword">UNPIVOT</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>targetCol_to_hold_sourceColValues<span class="token operator">></span>
		<span class="token keyword">FOR</span> <span class="token operator">&lt;</span>targetCol_to_hold_sourceColNames<span class="token operator">></span> 
            <span class="token operator">IN</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>list_of_sourceColumns<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">As</span> <span class="token operator">&lt;</span>resultTableAlias<span class="token operator">></span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>与 PIVOT运算符类似，UNPIVOT也是作为表运算符，在FROM子句的上下文中执行操作。它的操作对象是源表或表表达式(本例的EmpCustOrders)。在<strong>UNPIVOT运算符的圆括号中需要指定的内容</strong>包括：<strong>用于保存源表列值的目标列名</strong>(这里为qty)，<strong>用于保存源表列名的目标列名</strong>(custId)，以及<strong>源表的列名列表</strong>(A、B、C、D)。在UNPIVOT运算符的圆括号后面，可以为表运算符的结果表提供一个别名。</p>
<p>下面使用UNPIVOT运算符来实现这个例子要求的逆透视转换的完整查询方案：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> empId<span class="token punctuation">,</span> custId<span class="token punctuation">,</span> qty
<span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>EmpCustOrders
	<span class="token keyword">UNPIVOT</span><span class="token punctuation">(</span>qty <span class="token keyword">FOR</span> custId <span class="token operator">IN</span> <span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">,</span> D<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> U<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>注意， UNPIVOT运算符会执行与前面介绍的逻辑处理阶段相同的几个步骤：<strong>生成副本、提取元素和删除交叉位置上的NUL值</strong>。与基于标准SQL的解决方案相比， UNPIVOT的最后一个阶段不是可选的。</p>
<p>还要注意，<strong>对经过透视转换所得的表再进行逆透视转换，并不能得到原来的表</strong>。因为逆透视转换只是把经过透视转换后的值再旋转到另一种新的格式。<strong>但是，经过逆透视转换后的表可以再通过透视转换回到原来的状态</strong>。换句话说，<strong>透视转换中的聚合操作会丢失掉源表中的详细信息，经过透视转换后，保存下来的只是操作之间的所有聚合结果，而逆透视转换则不会丢失任何信息</strong>。</p>
<hr>
<h3 id="分组集（GROUPING-SET）"><a href="#分组集（GROUPING-SET）" class="headerlink" title="分组集（GROUPING SET）"></a>分组集（GROUPING SET）</h3><p>简单来说，分组集就是<strong>分组（GROUP BY子句）使用的一组属性（或列名）</strong>。<strong>在传统的SQL中，一个聚合查询只能定义一个分组集</strong>。例如，对于下列4个查询，它们每个都只定义了一个分组集：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> empId<span class="token punctuation">,</span> custId<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>qty<span class="token punctuation">)</span> <span class="token keyword">AS</span> sumQty
<span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>Orders
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> empId<span class="token punctuation">,</span> custId<span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> empId<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>qty<span class="token punctuation">)</span> <span class="token keyword">AS</span> sumQty
<span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>Orders
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> empId<span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> custId<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>qty<span class="token punctuation">)</span> <span class="token keyword">AS</span> sumQty
<span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>Orders
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> custId<span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> <span class="token function">SUM</span><span class="token punctuation">(</span>qty<span class="token punctuation">)</span> <span class="token keyword">AS</span> sumQty
<span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>Orders<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>假设现在不想生成4个单独的结果集，而是希望生成一个统一的结果集，其中包含所有4个分组集的聚合数据。为了实现该目标，<strong>可以使用UNION ALL集合运算，将所有4个査询的结果集合并在一起</strong>。由于集合运算要求所有结果集包含相同的列数，对应列的架构定义要保持兼容，所以可能须要对查询进行调整，用增加占位符(比如NULL)的办法来代替缺少的列。</p>
<p>虽然设法得到了期望的结果，但<strong>这种解决方案存在两个主要问题</strong>：<strong>代码长度</strong>和<strong>性能</strong>。首先，因为<strong>需要为每个分组集指定完整的GROUP BY査询</strong>，所以当分组集的数量很大时，查询语句可能变得相当长。其次，为了处理査询， SQL Server<strong>需要为每个查询分别单独扫描源表，导致效率低下</strong>。</p>
<p>SQL Server 2008引入了很多遵循标准SQL的新功能，能够支持在同一査询语句中定义多个分组集。这些分组集可以是GROUP BY子句的<strong>GROUPING SETS、CUBE、ROLLUP从属子句(subClause),以及GROUPING_ID函数</strong>。</p>
<hr>
<h4 id="GROUPING-SETS-从属子句"><a href="#GROUPING-SETS-从属子句" class="headerlink" title="GROUPING SETS 从属子句"></a>GROUPING SETS 从属子句</h4><p>GROUPING SETS从属子句是增强GROUP BY子句的有力保证，主要用于<strong>生成报表</strong>和<strong>数据仓库处理</strong>。<strong>借助该从属子句，就可以在同一査询中定义多个分组集</strong>。只要简单地在GROUPING SETS从属子句的圆括号内列出想要定义的各分组集，分组集之间用逗号分隔开。对于每个分组集，也在圆括号中列出它们各自的成员，成员之间用逗号隔开。例如，下面的查询定义了4个分组集：(empId, custId)、(empId)、(custId)和()：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> empId<span class="token punctuation">,</span> custId<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>qty<span class="token punctuation">)</span> <span class="token keyword">AS</span> sumqty
<span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>Orders
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> GROUPING SETS <span class="token punctuation">(</span>
    		<span class="token punctuation">(</span>empId<span class="token punctuation">,</span> custId<span class="token punctuation">)</span><span class="token punctuation">,</span>
    		<span class="token punctuation">(</span>empid<span class="token punctuation">)</span><span class="token punctuation">,</span>
    		<span class="token punctuation">(</span>custid<span class="token punctuation">)</span><span class="token punctuation">,</span>
    		<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个査询具有两大主要优势：一是需要的代码明显少得多；二是<strong>SQL Server能够优化扫描源表的次数，不须要为每个分组集单独对源表进行扫描</strong>。</p>
<hr>
<h4 id="CUBE-从属子句"><a href="#CUBE-从属子句" class="headerlink" title="CUBE 从属子句"></a>CUBE 从属子句</h4><p>GROUP BY 子句的CUBE从属子句为定义多个分组集提供了一种简略的方法。在CUBE从属子句的圆括号中，只须要<strong>列出由逗号分隔开的元素成员</strong>，就可以<strong>得到基于输入成员而定义的所有可能的分组集</strong>。例如，<strong>CUBE(a,b,c)与 GROUPING SETS[(a, b, c), (a, b), (a, c), (b, c), (a), (b), (c), ()]等效</strong>。在集合论中，由给定集合的所有子集构成的集合称为<strong>幂集( power set)</strong>。对于由给定元素构成的一个分组集(如(a, b, c) )，<strong>可以把CUBE从属子句看作是用于生成这个分组集的幂集</strong>。</p>
<p>前面用GROUPING SETS从属子句定义的4个分组集：(empId, custId)、(empId)、(custId)和( )，也可以简单地使用CUBE(empId, custId)来实现：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> empId<span class="token punctuation">,</span> custId<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>qty<span class="token punctuation">)</span> <span class="token keyword">AS</span> sumQty
<span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>Orders
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> CUBE<span class="token punctuation">(</span>empId<span class="token punctuation">,</span> custId<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<hr>
<h4 id="ROLLUP-从属子句"><a href="#ROLLUP-从属子句" class="headerlink" title="ROLLUP 从属子句"></a>ROLLUP 从属子句</h4><p>GROUP BY 子句的ROLLUP从属子句也提供了一种定义多个分组集的简略方法。不过，与CUBE从属子句不同的是， <strong>ROLLUP并不是生成基于输入成员而定义的所有可能的分组集</strong>，而<strong>只生成其中的一个子集</strong>。 <strong>ROLLUP认为输入成员之间存在一定的层次关系，从而生成让这种层次关系有意义的所有分组集</strong>。换句话说，CUBE(a,b,c)生成由3个输入成员得到的所有8个可能的分组集；而 ROLLUP认为这3个输入成员存在a &gt; b &gt; c的<strong>层次关系</strong>，所以只生成4个分组集，<strong>在效果上相当于指定了ROUPING SETS((a, b, c), (a, b), (a), () )</strong>。</p>
<p>例如，假设现在想按时间层次关系：订单年份 &gt; 订单月份 &gt; 订单日，以这样的关系来定义所有分组集，并为每个分组集返回其总订货量。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 如果使用 GROUPING SETS从属子句，就得显式列出所有可能的4个分组集：</span>
GROUPING SETS<span class="token punctuation">(</span>
	<span class="token punctuation">(</span><span class="token keyword">YEAR</span><span class="token punctuation">(</span>orderDate<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">MONTH</span><span class="token punctuation">(</span>orderDate<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">DAY</span><span class="token punctuation">(</span>orderDate<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token keyword">YEAR</span><span class="token punctuation">(</span>orderDate<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">MONTH</span><span class="token punctuation">(</span>orderDate<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token keyword">YEAR</span><span class="token punctuation">(</span>orderDate<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>
 
<span class="token comment">-- 而使用逻辑上等效的ROLLUP从属子句，则要更精简得多：</span>
<span class="token keyword">SELECT</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>orderDate<span class="token punctuation">)</span> <span class="token keyword">AS</span> orderYear
	<span class="token keyword">MONTH</span><span class="token punctuation">(</span>orderDate<span class="token punctuation">)</span> <span class="token keyword">AS</span> orderMonth<span class="token punctuation">,</span>
	<span class="token keyword">DAY</span><span class="token punctuation">(</span>orderDate<span class="token punctuation">)</span> <span class="token keyword">AS</span> orderday<span class="token punctuation">,</span>
	<span class="token function">SUM</span><span class="token punctuation">(</span>qty<span class="token punctuation">)</span> <span class="token keyword">As</span> sumQty
<span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>Orders
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> ROLLUP<span class="token punctuation">(</span><span class="token keyword">YEAR</span><span class="token punctuation">(</span>orderDate<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">MONTH</span><span class="token punctuation">(</span>orderDate<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">DAY</span><span class="token punctuation">(</span>orderDate<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在 SQL Server的早期版本中， ROLLUP也有一个非标准的“前身”——<strong>非标准的 WITH ROLLUP选项</strong>。标准的 GROUPING SETS、CUBE及ROLLUP从属子句<strong>比非标准的CUBE和ROLLUP选项更加灵活</strong>。<strong>可以在同一 GROUP BY子句中组合多个标准的从属子句，从而实现各种各样有趣的功能。而使用非标准的选项，每个查询只能限于使用一个选项</strong>。</p>
<hr>
<h4 id="GROUPING-和-GROUPING-ID-函数"><a href="#GROUPING-和-GROUPING-ID-函数" class="headerlink" title="GROUPING 和 GROUPING_ID 函数"></a>GROUPING 和 GROUPING_ID 函数</h4><p>如果一个查询定义了多个分组集，可能还想<strong>把结果行和分组集关联起来</strong>，也就是说，为每个结果行标识出它是和哪个分组集关联的。<strong>只要所有分组元素都定义为NOT NULL</strong>，实现这个要求就不难。例如，考虑如下查询：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> empId<span class="token punctuation">,</span> custId<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>qty<span class="token punctuation">)</span> <span class="token keyword">AS</span> sumQty
<span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>Orders
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> CUBE<span class="token punctuation">(</span>empId<span class="token punctuation">,</span> custId<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>因为 Orders表的empId和custId列都定义为<strong>NOT NULL</strong>，因此这些列中的NULL值<strong>只代表个占位符</strong>，<strong>表示该列并不属于当前的分组集</strong>。所以，所有empId和custId均不为NULL的行都与分组集(empId, custId)相关联；所有 empId不为NULL、custId为NULL的行都与分组集(empId)有关联，以此类推。有些人<strong>使用ALL或其他类似的标志来代替NULL(假设原始列不允许为NULL)，这种做法对生成报表很有用</strong>。</p>
<p>但是，<strong>如果表中的分组列定义为允许取NULL值</strong>，这时就无法区分结果集中的NULL是来自原始数据，还是占位符（表示该列不是分组集的成员）。<strong>如果想以确定性的方式来判断分组集的关联(即使分组列允许为NULL)，一种方法就是使用 GROUPING函数</strong>。这个函数接受一个列名，<strong>如果该列是当前分组集的成员，就返回0，否则返回1</strong>。例如，以下査询为每个分组元素调用 GROUPING函数：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT GROUPING(empId) AS grpEmp,
	GROUPING(custId) AS grpCust,
	empId, custId, SUM(qty) AS sumqty
FROM dbo.Orders
GROUP BY CUBE(empId, custId);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这样就<strong>不需要再依靠NULL来计算结果行和分组集之间的关联了</strong>。</p>
<p>SQL Server 2008<strong>引入了一个名为GROUPING_ID的函数</strong>，<strong>进一步简化了关联结果行和分组集的处理</strong>。可以把<strong>任何分组集中的所有元素</strong>作为 GROUPING_ID的输入（例如，GROUPING_ID(a, b, c, d)），这个函数<strong>返回一个整数位图(integer bitmap)</strong>，该整数的<strong>每一位代表一个不同的输入元素</strong>（最右边的位代表最右边的元素）。例如，分组集(a, b, c, d)可以用整数0 ($0\times 2^3 + 0\times 2^2 + 0\times 2^1 + 0\times 2^0$)表示，而分组集(a, c)则可以用整数5 ( $0\times 2^3 + 1\times 2^2 + 0\times 2^1 + 1\times 2^0$)表示，以此类推。</p>
<p><strong>除了像在前一个查询中那样为每个分组元素调用 GROUPING函数，也可以只调用一次ROUPING_ID函数，将所有分组元素作为该函数的输入</strong>，如下所示：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> GROUPING_ID<span class="token punctuation">(</span>empId<span class="token punctuation">,</span> custId<span class="token punctuation">)</span> <span class="token keyword">AS</span> groupingSet<span class="token punctuation">,</span>
	empId<span class="token punctuation">,</span> custId<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>qty<span class="token punctuation">)</span> <span class="token keyword">AS</span> sumQty
<span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>Orders
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> CUBE<span class="token punctuation">(</span>empId<span class="token punctuation">,</span> custId<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h2 id="数据修改"><a href="#数据修改" class="headerlink" title="数据修改"></a>数据修改</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><h4 id="INSERT-VALUES-语句"><a href="#INSERT-VALUES-语句" class="headerlink" title="INSERT VALUES 语句"></a>INSERT VALUES 语句</h4><p>INSERT VALUES语句可以<strong>将基于指定值的行插入表</strong>。在tempdb数据库中创建一个名为Orders表进行操作(在dbo架构中)，用于演示语句。请运行以下代码以创建 Orders表：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> tempdb<span class="token punctuation">;</span>
<span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'dbo.Orders'</span><span class="token punctuation">,</span> <span class="token string">'U'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> 
	<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Orders<span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Orders
<span class="token punctuation">(</span>
	orderId <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
    	<span class="token keyword">CONSTRAINT</span> PK_orders <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
    orderDate <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
    	<span class="token keyword">CONSTRAINT</span> DFT orderdate <span class="token keyword">DEFAULT</span><span class="token punctuation">(</span><span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    empId <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    custId <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
<span class="token punctuation">)</span>

<span class="token comment">-- 使用INSERT VALUES语句向Orders表中插入一行：</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>Orders<span class="token punctuation">(</span>orderId<span class="token punctuation">,</span> orderDate<span class="token punctuation">,</span> empId<span class="token punctuation">,</span> custId<span class="token punctuation">)</span>
	<span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">10001</span><span class="token punctuation">,</span> <span class="token string">'20090212'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>紧接着表名之后</strong>，<strong>可以指定目标列的名称</strong>。虽然显式地指定列名是可选的，但这样做<strong>可以对语句中指定的列值和列名之间的关联关系进行控制</strong>，而不必单纯地依赖在定义表时（或者在对表结构进行最后一次修改以后）各个列的出现顺序。</p>
<p>如果为某个列指定了一个值， Microsoft SQL Server将使用这个值。如果<strong>没有为某个列指定取值， SQL Server将检查是否为该列定义了默认值</strong>。如果定义了默认值，则使用该默认值。<strong>如果没有定义默认值，但该列允许为NULL值，则为该列使用NULL值</strong>。<strong>如果在INSERT语句中既没有为某个列指定一个值，也没有什么机制能让它自动获取一个值，这个 INSERT语句的执行就会失败</strong>。作为依赖默认值或表达式的一个例子，以下语句向Orders表插入一行没有为 orderdate列指定值的记录，但由于已经为这个列定义了一个默认表达式(CURRENT TIMESTAMP)，在这种情况下就使用这个默认值：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>Orders<span class="token punctuation">(</span>orderId<span class="token punctuation">,</span> empId<span class="token punctuation">,</span> custId<span class="token punctuation">)</span>
<span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">10002</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>SQL Server 2008增强了VALUES语句的功能，允许在一条语句中指定由逗号分隔开的多行记录。如下：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>Orders<span class="token punctuation">(</span>orderId<span class="token punctuation">,</span> orderDate<span class="token punctuation">,</span> empId<span class="token punctuation">,</span> custId<span class="token punctuation">)</span>
<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">10003</span><span class="token punctuation">,</span> <span class="token string">'20090213'</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	   <span class="token punctuation">(</span><span class="token number">10004</span><span class="token punctuation">,</span> <span class="token string">'20090214'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	   <span class="token punctuation">(</span><span class="token number">10005</span><span class="token punctuation">,</span> <span class="token string">'20090213'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
       <span class="token punctuation">(</span><span class="token number">10006</span><span class="token punctuation">,</span> <span class="token string">'20090215'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面这个语句是作为<strong>原子操作</strong>(atomic operation)而处理的，这意味着<strong>如果有任何一行在插入表时失败，那么语句中的所有行都不会插入表</strong>。</p>
<p>SQL Server 2008不仅增强了INSERT VALUES语句，而且还<strong>增强了VALUES子句本身的功能</strong>，现在可以用它来<strong>构建虚拟表（virtual table）</strong>。这种功能称为<strong>行值构造函数(Row Value Constructor)或表值构造函数（Table Value Constructor）</strong>，<strong>是符合SQL标准的一种用法</strong>。这意味着在SQL Server 2008中<strong>可以定义一个基于 VALUES子句的表表达式</strong>。下面这个例子就是对一个基于 VALUES子句而定义的派生表进行查询：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> <span class="token punctuation">(</span><span class="token keyword">VALUES</span>
      	<span class="token punctuation">(</span><span class="token number">10003</span><span class="token punctuation">,</span> <span class="token string">'20090213'</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      	<span class="token punctuation">(</span><span class="token number">10004</span><span class="token punctuation">,</span> <span class="token string">'20090214'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      	<span class="token punctuation">(</span><span class="token number">10005</span><span class="token punctuation">,</span> <span class="token string">'20090213'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      	<span class="token punctuation">(</span><span class="token number">10006</span><span class="token punctuation">,</span> <span class="token string">'20090215'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">As</span> O<span class="token punctuation">(</span>orderId<span class="token punctuation">,</span> orderDate<span class="token punctuation">,</span> empId<span class="token punctuation">,</span> custId<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h4 id="INSERT-SELECT-语句"><a href="#INSERT-SELECT-语句" class="headerlink" title="INSERT SELECT 语句"></a>INSERT SELECT 语句</h4><p>INSERT SELECT语句可以将一组由SELECT査询返回的结果行插入目标表中。它的语法和INSERT VALUES语句非常相似，只不过这里是用SELECT査询代替了VALUES子句。</p>
<p>如果想在SQL Server 2008之前版本的 SQL Server中<strong>构建一个基于常量值的虚拟表</strong>，就不得不使用多个SELECT语句，由每个 SELECT语句返回一个基于常量值的行，再用UNION ALL集合运算把各行合并到一起。如前所述， SQL Server 2008<strong>支持表值构造函数，所以实际上不必再使用这种技术了</strong>。</p>
<p>在 SQL Server 2008<strong>之前的版本中</strong>，<strong>几乎所有的INSERT SELECT操作</strong>都进行<strong>完整模式</strong>的日志处理(也就是说，<strong>所有操作都写入数据库的事务日志</strong>)。和<strong>以最小方式记录日志</strong>的操作相比，以完整模式记录日志的操作<strong>可能会相当慢</strong>。和以前的版本相比， <strong>SQL Server 2008能够在更多的场合中支持以最小方式记录日志的操作，包括INSERT SELECT语句</strong>。</p>
<hr>
<h4 id="INSERT-EXEC-语句"><a href="#INSERT-EXEC-语句" class="headerlink" title="INSERT EXEC 语句"></a>INSERT EXEC 语句</h4><p>INSERT EXEC语句可以<strong>把存储过程或动态SQL批处理返回的结果集插入目标表</strong>。有关<strong>存储过程、批处理及动态SQL</strong>的内容将在第10章“可编程对象”中介绍。</p>
<p>例如，以下代码在TSQLFundamentals2008数据库中创建一个名为Sales.usp_getOrders的存储过程，返回要发货到指定输入国家（@country 参数）的订单：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> TSQLFundamentals2008<span class="token punctuation">;</span>

<span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'sales.usp_getOrders'</span><span class="token punctuation">,</span> <span class="token string">'P'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
	<span class="token keyword">DROP</span> <span class="token keyword">PROC</span> Sales<span class="token punctuation">.</span>usp_getOrders<span class="token punctuation">;</span>
GO
<span class="token keyword">CREATE</span> <span class="token keyword">PROC</span> Sales<span class="token punctuation">.</span>usp_getOrders
	<span class="token variable">@country</span> <span class="token keyword">AS</span> NVARCHAR<span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span>
<span class="token keyword">AS</span>
<span class="token keyword">SELECT</span> orderId<span class="token punctuation">,</span> orderDate<span class="token punctuation">,</span> empId<span class="token punctuation">,</span> custId
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders
<span class="token keyword">WHERE</span> shipCountry <span class="token operator">=</span> <span class="token variable">@country</span><span class="token punctuation">;</span>
GO

<span class="token keyword">EXEC</span> Sales<span class="token punctuation">.</span>usp_getOrders <span class="token variable">@country</span> <span class="token operator">=</span> <span class="token string">'France'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用INSERT EXEC语句，可以把该存储过程返回的结果集插入 tempdb数据库的dbo.Orders表：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> tempdb<span class="token punctuation">;</span>

<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>Orders<span class="token punctuation">(</span>orderId<span class="token punctuation">,</span> orderDate<span class="token punctuation">,</span> empId<span class="token punctuation">,</span> custId<span class="token punctuation">)</span>
	<span class="token keyword">EXEC</span> TSQLFundamentals2008 Sales<span class="token punctuation">.</span>usp_getOrders <span class="token variable">@country</span> <span class="token operator">=</span> <span class="token string">'France'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h4 id="SELECT-INTO-语句"><a href="#SELECT-INTO-语句" class="headerlink" title="SELECT INTO 语句"></a>SELECT INTO 语句</h4><p>SELECT INTO语句的作用是<strong>创建一个目标表</strong>，<strong>并用查询返回的结果来填充它</strong>。<strong>SELECT INTO语句不是一个标准的SQL语句，也就是说，它不是 ANSI SQL标准的一部分</strong>。<strong>不能用这个语句向已经存在的表中插入数据</strong>。按照语法，只要简单地<strong>将INTO&lt;目标表名称&gt;加到</strong>用于生成结果集的SELECT查询的<strong>FROM子句前面</strong>就可以了。例如，以下代码在tempdb数据库中创建一个名为dbo.Orders的表，并用TSQLFundamentals2008数据库中Sales.Orders表的所有行填充这个新表：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">USE tempdb;

IF OBJECT_ID(&#39;dbo.Orders&#39;,&#39;u&#39;) IS NOT NULL 
	DROP TABLE dbo.Orders;
	
SELECT orderId, orderDate, empId, custId
INTO dbo.Orders
FROM TSQLFundamentals2008.Sales.Orders;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>SELECT INTO<strong>语句会复制来源表的基本结构（包括列名、数据类型、是否允许为NULL及 IDENTITY属性）和数据</strong>。不过，SELECT INTO语句<strong>不会复制3样东西：约束、索引及触发器</strong>。如果目标表中需要这些东西，则<strong>需要亲自创建</strong>它们。</p>
<p>SELECT INTO语句的一个优点是：<strong>只要不把一个名为恢复模式(Recovery Model)的数据库属性设置成FULL（完整恢复模式），SELECT INTO就会按最小日志记录模式来执行操作</strong>。与完整日志记录模式相比，在最小日志记录模式下可以进行非常快速的操作。</p>
<p>如果想使用带有集合操作的 SELECT INTO语句，应该把INTO子句放在第一个査询的FROM子句之前。例如，下面的 SELECT INTO语句创建一个名为 Locations的表，并<strong>用一个EXCEPT集合操作的结果来填充这个新表</strong>，该集合操作返回的是客户地址，但不是雇员地址的那些行：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> tempdb<span class="token punctuation">;</span>

<span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'dbo.Locations'</span><span class="token punctuation">,</span> <span class="token string">'U'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> 
	<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Locations
	
<span class="token keyword">SELECT</span> country<span class="token punctuation">,</span> region<span class="token punctuation">,</span> city
<span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>Locations
<span class="token keyword">FROM</span> TSQLFundamentals2008<span class="token punctuation">.</span>Sales<span class="token punctuation">.</span>Customers
<span class="token keyword">EXCEPT</span>
<span class="token keyword">SELECT</span> country<span class="token punctuation">,</span> region<span class="token punctuation">,</span> city
<span class="token keyword">FROM</span> TSQLFundamentals2008<span class="token punctuation">.</span>HR<span class="token punctuation">.</span>Employees<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h4 id="BULK-INSERT-语句"><a href="#BULK-INSERT-语句" class="headerlink" title="BULK INSERT 语句"></a>BULK INSERT 语句</h4><p>BULK INSERT语句用于<strong>将文件中的数据导入一个已经存在的表</strong>。在这个语句中，须要指定目标表、源文件及一些选项。<strong>可以指定的选项很多，包括数据文件的类型（例如，是字符格式(char)，还是本机数据库类型(native) ）、字段终止符和行终止符</strong>，所有这些选项都有完整的文档说明。</p>
<p>例如，以下代码将文件”c:\temp\orders.txt”中的数据<strong>大容量插入(bulk insert)</strong> tempdb的dbo.Orders表，同时指定数据文件类型为字符格式，字段终止符为逗号，行终止符为换行符(\t):</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> tempdb<span class="token punctuation">;</span>

<span class="token keyword">BULK</span> <span class="token keyword">INSERT</span> dbo<span class="token punctuation">.</span>Orders <span class="token keyword">FROM</span> <span class="token string">'c:\temp\orders.txt'</span>
	<span class="token keyword">WITH</span> <span class="token punctuation">(</span>
    	DATAFILETYPE <span class="token operator">=</span> <span class="token string">'char'</span><span class="token punctuation">,</span>
        FIELDTERMINATOR <span class="token operator">=</span> <span class="token string">','</span><span class="token punctuation">,</span>
        ROWTERMINATOR <span class="token operator">=</span> <span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h4 id="IDENTITY-属性"><a href="#IDENTITY-属性" class="headerlink" title="IDENTITY 属性"></a>IDENTITY 属性</h4><p>在SQL Server中可以<strong>为列定义一个名为IDENTITY的属性</strong>（标识列），它是一个<strong>任意整数</strong>。当<strong>把值插入(INSERT)有标识列的表时</strong>，数据库引擎会<strong>根据列定义中提供的一个种子（seed, 第1个值）和增量（步长值）自动生成递增的标识值</strong>。通常是<strong>用这种属性生成代理键（surrogate key）</strong>，<strong>这是一种由系统生成的键，而不是由应用数据派生出来的键</strong>。<br>例如，以下代码在tempdb数据库中创建一个名为dbo.T1的表：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> tempdb<span class="token punctuation">;</span>

<span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'dbo.T1'</span><span class="token punctuation">,</span> <span class="token string">'U'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> 
	<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>T1<span class="token punctuation">;</span>
	
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>T1
<span class="token punctuation">(</span>
	keyCol <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">IDENTITY</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">-- 种子值和增量值均为1</span>
    	<span class="token keyword">CONSTRAINT</span> PK_T1 <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
    dataCol <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
    	<span class="token keyword">CONSTRAINT</span> CHK_T1_datacol <span class="token keyword">CHECK</span><span class="token punctuation">(</span>dataCol <span class="token operator">LIKE</span> <span class="token string">'[A-Za-z]%'</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>在INSERT语句中，应该完全忽略标识列，就像它们在表中不存在一样</strong>。例如，以下代码向该表插入3行数据时，只为 dataCol列指定值：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>T1<span class="token punctuation">(</span>dataCol<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">'AAAAA'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>T1<span class="token punctuation">(</span>dataCol<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">'CCCCC'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>T1<span class="token punctuation">(</span>dataCol<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">'BBBBB'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>当查询这个表时，自然可以通过标识列的列名来引用它(在这个例子中是 keycol)。<strong>SQL Server为引用标识列提供了一种更通用的格式： <code>$identity</code></strong>。例如，以下使用通用格式来查询T1表中的标识列：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> $<span class="token keyword">identity</span> <span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>T1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>当在表中<strong>新插入一行</strong>时， SQL Server会根据<strong>表中当前的标识值</strong>和<strong>增量</strong>生成一个新的标识值。如果需要获得这个新生成的标识值(例如，要在引用表中插入子行)，可以查询以下两个函数：</p>
<ol>
<li><p><code>@@identity</code></p>
<p> <code>@@identity</code>函数是从以前版本遗留下来的功能，它<strong>返回会话最后生成的一个标识值，而不考虑任何作用域</strong>。</p>
</li>
<li><p><code>SCOPE_IDENTITY()</code></p>
<p> <code>SCOPE IDENTITY()</code>返回<strong>当前作用域</strong>(例如，同一存储过程)<strong>内会话生成的最后一个标识值</strong>。除非是一些非常特殊不需要关心作用域的情况，否则，<strong>应该总是使用<code>SCOPE IDENTITY()</code>函数</strong>。</p>
</li>
</ol>
<p>例如，以下代码在T1表中插入一行，通过査询SCOPE SCOPE_IDENTITY函数以获得新生成的标识值，并将其赋值给一个变量，然后再查询该变量：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DECLARE</span> <span class="token variable">@new_key</span> <span class="token keyword">AS</span> <span class="token keyword">INT</span><span class="token punctuation">;</span>

<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>T1<span class="token punctuation">(</span>dataCo1<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">'AAAAA'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">SET</span> <span class="token variable">@new_key</span> <span class="token operator">=</span> SCOPE_IDENTITY<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> <span class="token variable">@new_key</span> <span class="token keyword">AS</span> new_key<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>记住，<code>@@identity</code>和<code>SCOPE_ IDENTITY()</code>都是<strong>返回当前会话生成的最后一个标识值</strong>。二者都<strong>不受其他会话中插入操作的影响</strong>。不过，如果你想知道<strong>一个表当前的标识值（最后生成的值）而不考虑作用域</strong>，则应该使用<strong>IDENT_CURRENT函数</strong>，<strong>并将表名作为其输入参数</strong>。例如，从一个新的会话(不是运行先前INSERT语句的那个会话)中运行以下代码：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> SCOPE_IDENTITY<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token punctuation">[</span>SCOPE_IDENTITY<span class="token punctuation">]</span><span class="token punctuation">,</span>
	@<span class="token variable">@identity</span> <span class="token keyword">AS</span> <span class="token punctuation">[</span>@<span class="token variable">@identity</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
	IDENT_CURRENT<span class="token punctuation">(</span><span class="token string">'dbo.T1'</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token punctuation">[</span>IDENT_CURRENT<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><code>@@identity</code>和<code>SCOPE_ IDENTITY</code>返回的都是NULL，因为在运行查询的会话内还没有创建任何标识值。 IDENT_CURRENT的返回值是4，它返回的是表中当前的标识值，不用考虑这个标识值是在哪个会话中生成的。</p>
<p>如果导致当前标识值发生变化的<strong>INSERT语句插入失败</strong>，或者是该语句所在的<strong>事务(transaction)发生了回滚(roll back)</strong>，表中当前<strong>标识值的变化并不会被撤销</strong>。这意味着，当你<strong>不在意标识值之间有间隔时，应该只依赖标识属性自动生成标识值</strong>；否则，<strong>应该考虑使用自己的替代机制</strong>。</p>
<p>标识属性需要注意的另一个重要地方是，<strong>不能在现有的列上增加或删除标识属性</strong>，只能用CREATE TABLE语句或旨在增加新列的ALTER TABLE语句，<strong>在定义列的同时一起定义标识属性</strong>。如果为INSERT操作涉及的表<strong>设置了一个名为IDENTITY INSERT的会话选项</strong>，SQL Server就可以<strong>允许在INSERT语句中显式地指定标识列的取值</strong>。不过，<strong>没有任何选项可以对标识列进行更新</strong>。</p>
<p>例如，以下代码演示了如何在T1表中插入一行数据，并<strong>显式指定这行的 keyCol列的取值</strong>为5：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SET</span> <span class="token keyword">IDENTITY_INSERT</span> dbo<span class="token punctuation">.</span>T1 <span class="token keyword">ON</span><span class="token punctuation">;</span> <span class="token comment">-- 设置了一个名为IDENTITY INSERT的会话选项</span>

<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>T1<span class="token punctuation">(</span>keyCol<span class="token punctuation">,</span> dataCol<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">'FFFFF'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">SET</span> <span class="token keyword">IDENTITY_INSERT</span> dbo<span class="token punctuation">.</span>T1 <span class="token keyword">OFF</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>有趣的是，<strong>只有当为标识列显式提供的值大于表的当前标识值时， SQL Serverオ会改变表的当前标识值</strong>。</p>
<p><strong>标识属性本身并不会强制限制标识列的唯一性，理解这一点很重要</strong>。前面已经说过，<strong>当把 IDENTITY INSERT选项设置为ON以后，就可以为标识列显式地指定自己需要的值，但这些值有可能在表的某些行中已经存在了</strong>。<strong>此外，可以使用DBCC CHECKIDENT命令来重设(reseed)表的当前标识值</strong>。有关 DBCC CHECKIDENT命令语法的细节，请参考SQL Server联机从书的“ DBCC CHECKIDENT( Transact-SQL)”一文。<strong>总之，标识属性并不会强制实施唯一性约束。如果想要保证标识列的唯一性，可以在标识列上另外同时定义一个主键或唯一性约束</strong>。</p>
<hr>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>TSOL提供了两个从表中删除数据行的语句：<strong>DELETE</strong>和<strong>TRUNCATE</strong>。本节就重点介绍这两个语句。</p>
<p>运行以下代码以创建并填充Customers表和Orders表：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> tempdb<span class="token punctuation">;</span>

<span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'dbo.Orders'</span><span class="token punctuation">,</span> <span class="token string">'U'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> 
	<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Orders<span class="token punctuation">;</span>
<span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'dbo.Customers'</span><span class="token punctuation">,</span> <span class="token string">'U'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> 
	<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Customers<span class="token punctuation">;</span>
	
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>Customers <span class="token keyword">FROM</span> TSQLFundamentals2008<span class="token punctuation">.</span>Sales<span class="token punctuation">.</span>Customers<span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>Orders <span class="token keyword">FROM</span> TSQLFundamentals2008<span class="token punctuation">.</span>Sales<span class="token punctuation">.</span>Orders<span class="token punctuation">;</span>

<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Customers <span class="token keyword">ADD</span>
	<span class="token keyword">CONSTRAINT</span> PK_Customers <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>custId<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Orders <span class="token keyword">ADD</span>
	<span class="token keyword">CONSTRAINT</span> PK_orders <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token keyword">CONSTRAINT</span> FK_Orders_Customers <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>custId<span class="token punctuation">)</span>
		<span class="token keyword">REFERENCES</span> dbo<span class="token punctuation">.</span>Customers<span class="token punctuation">(</span>custId<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h4 id="DELETE-语句"><a href="#DELETE-语句" class="headerlink" title="DELETE 语句"></a>DELETE 语句</h4><p>DELETE语句只有两个子句：用于指定目标表名的FROM子句和用于指定谓词条件的WHERE子句。</p>
<p>DELETE语句采用的是<strong>完整模式的日志处理</strong>，<strong>当删除大量数据时，可能会花费大量时间</strong>。</p>
<hr>
<h4 id="TRUNCATE-语句"><a href="#TRUNCATE-语句" class="headerlink" title="TRUNCATE 语句"></a>TRUNCATE 语句</h4><p>TRUNCATE语句<strong>不是标准的SQL语句</strong>，它用于<strong>删除表中的所有行</strong>。与DELETE语句不同，TRUNCATE不需要过滤条件。例如，要刑除dbo.TI表的所有行，可以使用以下代码：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">TRUNCATE</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>T1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>和DELETE语句相比，TRUNCATE具有的优点是：TRUNCATE<strong>以最小模式记录日志</strong>，而DELETE则以完整模式记录日志，二者<strong>在性能方面有巨大差异</strong>。例如，对于一个包含数百万行记录的表，要删除表中的所有行，如果用 TRUNCATE语句，操作在几秒钟内就能完成：如果用 DELETE语句，操作可能要花费几分钟，甚至几个小时。</p>
<p>当表中有<strong>标识列</strong>时，TRUNCATE和DELETE在功能上也有所不同。<strong>TRUNCATE会把标识值重置为最初的种子(seed)，而 DELETE则不会</strong>。</p>
<p>当目标表是<strong>由外键约束引用</strong>的表时，SQL Server将<strong>不允许对这样的表使用TRUNCATE语句，即使引用表(referencing table)为空或外键被禁止也是如此</strong>。这时要使用TRUNCATE语句，<strong>唯一的办法就是删除正在引用目标表的所有外键</strong>。</p>
<p>TRUNCATE语句的<strong>执行速度非常快</strong>，因而有时具有一定的危险。当清空表的内容或删除表时，搞错了要操作的表，类似的事故时有发生。例如，假设你现在同时打开了与产品环境和开发环境相连的两个连接，但提交代码时使用了错误的连接。 TRUNCATE和DROP语句执行得如此迅速，以至于当你意识到错误时，事务已经提交了。为了避免发生这样的事故，可以简单地<strong>创建一个虚拟表(dummy table)，让虚拟表包含一个指向产品表的外键，这样就可以保护产品表了</strong>。甚至还可以禁用虚拟表的外键，以便让虚拟外键不会对性能产生任何影响。如前所述，即使虚拟外键被禁用，它也能够阻止清空被引用表的内容或删除被引用表。</p>
<hr>
<h4 id="基于连接的-DELETE"><a href="#基于连接的-DELETE" class="headerlink" title="基于连接的 DELETE"></a>基于连接的 DELETE</h4><p>T-SQL支持一种<strong>基于连接的DELETE语法</strong>，这<strong>不是一种标准的SQL语法</strong>。连接意味着，<strong>可以根据对另一个表中相关行的属性定义的过滤器来删除表中的数据行</strong>。</p>
<p>例如，以下语句将删除美国客户下的订单：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> tempdb<span class="token punctuation">;</span>

<span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> O
<span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>Orders <span class="token keyword">AS</span> O
	<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> dbo<span class="token punctuation">.</span>Customers <span class="token keyword">AS</span> C
		<span class="token keyword">ON</span> <span class="token number">0.</span>custId <span class="token operator">=</span>C<span class="token punctuation">.</span>custId
<span class="token keyword">WHERE</span> C<span class="token punctuation">.</span>country<span class="token operator">=</span> <span class="token string">'USA'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个语句和 SELETE语句非常相似， DELETE语句在逻辑上第一个处理的子句是FROM子句（在这个语句的第二行出现）。接着处理的是 WHERE子句处理，最后是 DELETE子句。<strong>DELETE语句中基于连接的两个FROM子句可能令人费解</strong>。但当开发这段代码时，可以把它当成好像是在开发一个带有连接的 SELETE语句。也就是说，先从带有连接的FROM子句着手，然后转到WHERE子句，最后不是指定 SELECT子句，而是指定一个 DELETE子句，并提供要删除的目标表在连接中的别名。</p>
<p>如前所述，基于连接的DELETE语句不是标准的SQL语句。如果要<strong>使用标准代码，可以用子査询来代替连接</strong>。例如，以下DELETE语句用子查询也可以完成相同的任务：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>Orders
<span class="token keyword">WHERE</span> <span class="token keyword">EXISTS</span>
	<span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span>
     <span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>Customers <span class="token keyword">AS</span> C
     <span class="token keyword">WHERE</span> Orders<span class="token punctuation">.</span>custId <span class="token operator">=</span> C<span class="token punctuation">.</span>custId
     	<span class="token operator">AND</span> C<span class="token punctuation">.</span>country <span class="token operator">=</span> <span class="token string">'USA'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>本节提供的例子需要对tempdb数据库中创建的Orders表和OrderDetails表进行操作。运行以下代码，以创建并填充这两个表：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> tempdb<span class="token punctuation">;</span>

<span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'dbo.OrderDetails'</span><span class="token punctuation">,</span> <span class="token string">'U'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> 
	<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>OrderDetails<span class="token punctuation">;</span>
<span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'dbo.Orders'</span><span class="token punctuation">,</span> <span class="token string">'U'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
	<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Orders<span class="token punctuation">;</span>
	
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>Orders <span class="token keyword">FROM</span> TSQLFundamentals2008<span class="token punctuation">.</span>Sales<span class="token punctuation">.</span>Orders<span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>Orderdetails <span class="token keyword">FROM</span> TSQLFundamentals2008<span class="token punctuation">.</span>Sales<span class="token punctuation">.</span>OrderDetails<span class="token punctuation">;</span>

<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Orders <span class="token keyword">ADD</span>
	<span class="token keyword">CONSTRAINT</span> PK_Orders <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span>

<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>OrderDetails <span class="token keyword">ADD</span>
	<span class="token keyword">CONSTRAINT</span> PK_OrderDetails <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>corderId<span class="token punctuation">,</span> productId<span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token keyword">CONSTRAINT</span> FK_OrderDetails_Orders <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span>
		<span class="token keyword">REFERENCES</span> dbo<span class="token punctuation">.</span>Orders<span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h4 id="UPDATE-语句"><a href="#UPDATE-语句" class="headerlink" title="UPDATE 语句"></a>UPDATE 语句</h4><p>UPDATE语句是标准SQL语句，用于<strong>对表中数据行的一个子集进行更新</strong>。为了标识作为更新目标的子集行，需要在WHERE子句中指定一个谓词。在<strong>SET子句中指定要更改的列和这些列的新值（或表达式），各列之间用逗号分隔</strong>。</p>
<p>当然，在进行更新操作前后，可以通过一个具有相同过滤条件的SELECT语句来查看变化。在本章最后还将介绍另一种<strong>査看变化的方法</strong>：<strong>在修改语句的后面使用一个名为OUTPUT的子句</strong>。</p>
<p>SQL Server 2008<strong>引入了对复合赋值运算符(compound assignment operator)的支持</strong>：<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>及<code>%=</code>。</p>
<p>用<strong>同时操作</strong>(<strong>第2章单表查询</strong>)的思想，你能想出<strong>交换col1和col2列值的UPDATE语句</strong>是怎样写的吗？<strong>在大多数编程语言中，表达式和赋值语句按特定的顺序（通常是从左到右）执行，在这种情况下要交换两个变量，需要一个临时变量</strong>。然而，<strong>因为在SQL中所有赋值表达式好像都是同时进行计算的，解决这个问题就非常简单</strong>：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> dbo<span class="token punctuation">.</span>T1
<span class="token keyword">SET</span> col1 <span class="token operator">=</span> col2<span class="token punctuation">,</span> co12 <span class="token operator">=</span> coll<span class="token punctuation">;</span> <span class="token comment">-- SET子句中指定要更改的列和这些列的新值（或表达式），各列之间用逗号分隔</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<hr>
<h4 id="基于连接的-UPDATE"><a href="#基于连接的-UPDATE" class="headerlink" title="基于连接的 UPDATE"></a>基于连接的 UPDATE</h4><p>与DELETE语句类似，T-SQL也支持一种基于连接的UPDATE语法，这<strong>不是标准SQL语法</strong>。和基于连接的DELETE语句一样，连接在此处也<strong>起过滤作用</strong>。</p>
<p>在UPDATE关键字之后<strong>指定要更新的目标表的别名</strong>，然后<strong>在SET子句中指定要更改的列和这些列的新值</strong>。例如，如下的UPDATE语句为客户1下的订单中的所有商品增加5%的折扣：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> OD
<span class="token keyword">SET</span> discount <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">0.05</span>
<span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>OrderDetails <span class="token keyword">AS</span> OD
	<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> dbo<span class="token punctuation">.</span>Orders <span class="token keyword">AS</span> O
		<span class="token keyword">ON</span> OD<span class="token punctuation">.</span>orderId <span class="token operator">=</span> O<span class="token punctuation">.</span>orderId
<span class="token keyword">WHERE</span> custId <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> 

<span class="token comment">-- 标准代码通过子查询实现，【推荐】</span>
<span class="token keyword">UPDATE</span> dbo<span class="token punctuation">.</span>OrderDetails
<span class="token keyword">SET</span> discount <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">0.05</span>
<span class="token keyword">WHERE</span> <span class="token keyword">EXISTS</span>
	<span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>Orders <span class="token keyword">AS</span> o
     <span class="token keyword">WHERE</span> O。orderId <span class="token operator">=</span> orderDetails<span class="token punctuation">.</span>orderId
     	<span class="token operator">AND</span> custId <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>推荐使用标准代码</strong>。不过，<strong>在某些情况下，使用连接比使用子查询在性能上更具优势</strong>。除了过滤作用，<strong>通过连接还可以访问其他表的属性（列），并在SET子句中使用这些属性为列赋值</strong>。所以，连接中对其他表的同一访问既可以用于过滤目的，也可以用于在赋值表达式中获取来自其他表的列值。<strong>然而，如果使用子査询的方法，每个子查询都是独立地访问另一个表</strong>（至少 SQL Server引擎目前就是这样处理子查询的）例如，考虑以下基于连接的非标准 UPDATE语句：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> T1
<span class="token keyword">SET</span> col1 <span class="token operator">=</span> T2<span class="token punctuation">.</span>Col1<span class="token punctuation">,</span>
	col2 <span class="token operator">=</span> T2<span class="token punctuation">.</span>co12<span class="token punctuation">,</span>
	col3 <span class="token operator">=</span> T2<span class="token punctuation">.</span>col3
<span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>T1 
	<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> dbo<span class="token punctuation">.</span>T2
<span class="token keyword">ON</span> T2<span class="token punctuation">.</span>keyCol <span class="token operator">=</span> T1<span class="token punctuation">.</span>keyCol
<span class="token keyword">WHERE</span> T2<span class="token punctuation">.</span>Col4 <span class="token operator">=</span> <span class="token string">'ABC'</span><span class="token punctuation">;</span>

<span class="token comment">-- 如果非要使用标准代码，用子查询来实现这个任务，最终会产生如下冗长的查询语句</span>
<span class="token keyword">UPDATE</span> dbo<span class="token punctuation">.</span>T1
<span class="token keyword">SET</span> col1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> Col1
            <span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>T2
            <span class="token keyword">WHERE</span> T2<span class="token punctuation">.</span>keyCol <span class="token operator">=</span> T1<span class="token punctuation">.</span>keyCol<span class="token punctuation">)</span><span class="token punctuation">,</span>
    col2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> Co12
            <span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>T2
            <span class="token keyword">WHERE</span> T2<span class="token punctuation">.</span>keyCol <span class="token operator">=</span> T1<span class="token punctuation">.</span>keyCol<span class="token punctuation">)</span><span class="token punctuation">,</span>
    co13 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> co13
            <span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>T2
            <span class="token keyword">WHERE</span> T2<span class="token punctuation">.</span>keyCol <span class="token operator">=</span> T1<span class="token punctuation">.</span>keyCol<span class="token punctuation">)</span>
<span class="token keyword">WHERE</span> <span class="token keyword">EXISTS</span>
	<span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span>
     <span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>T2
     <span class="token keyword">WHERE</span> T2<span class="token punctuation">.</span>keyCol <span class="token operator">=</span> T1<span class="token punctuation">.</span>keyCol
     	<span class="token operator">AND</span> T2<span class="token punctuation">.</span>Col4 <span class="token operator">=</span> <span class="token string">'ABC'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>ANSI SQL支持一种称为<strong>行构造函数（也称为向量表达式）的功能</strong>，SQL Server 2008<strong>只实现了其中的部分功能</strong>。行构造函数的很多方面在SQL Server中还没有实现，这其中包括在UPDATE语句的SET子句中使用行构造函数的功能，如下所示：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> dbo<span class="token punctuation">.</span>T1
	<span class="token keyword">SET</span> <span class="token punctuation">(</span>col1<span class="token punctuation">,</span> col2<span class="token punctuation">,</span> co13<span class="token punctuation">)</span> <span class="token operator">=</span> 
		<span class="token punctuation">(</span><span class="token keyword">SELECT</span> col1<span class="token punctuation">,</span> col2<span class="token punctuation">,</span> col3
         <span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>T2
         <span class="token keyword">WHERE</span> T2<span class="token punctuation">.</span>keyCol <span class="token operator">=</span> T1<span class="token punctuation">.</span>keyCol<span class="token punctuation">)</span>
<span class="token keyword">WHERE</span> <span class="token keyword">EXISTS</span>
	<span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span>
     <span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>T2
     <span class="token keyword">WHERE</span> T2<span class="token punctuation">.</span>keyCol <span class="token operator">=</span> T1<span class="token punctuation">.</span>keyCol
     	<span class="token operator">AND</span> T2<span class="token punctuation">.</span>Col4 <span class="token operator">=</span> <span class="token string">'ABC'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h4 id="赋值-UPDATE"><a href="#赋值-UPDATE" class="headerlink" title="赋值 UPDATE"></a>赋值 UPDATE</h4><p>T-SQL支持一种<strong>特有的UPDATE语法</strong>，可以在<strong>对表中的数据进行更新的同时为变量赋值</strong>。这种语法使你不须要使用单独的 UPDATE和 SELECTI语句，就能完成同样的任务。</p>
<p><strong>使用这种语法的一种常见情况是：当由于某种原因，标识列不能满足需要时，就得维护一种自定义的序列&#x2F;自动编号机制，这时就能用到这种语法</strong>。其思想是<strong>把最后用过的值保存在一个表中，然后使用这种特殊的UPDATE语法来增加表中的值，并把新值赋给一个变量</strong>。</p>
<p>运行以下代码，先创建一个Sequence表(具有一个名为val的列)，然后为这个表填充一行，其中的val列为0（该值<strong>小于你想使用的第一个值</strong>）：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">USE tempdb;
IF OBJECT_ID(&#39;dbo.Sequence&#39;, &#39;U&#39;) IS NOT NULL 
	DROP TABLE dbo.Sequence;
CREATE TABLE dbo.Sequence(val INT NOT NULL);
INSERT INTO dbo.Sequence VALUES(0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>现在，当须要得到一个新的序列值时，可以使用以下代码：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">DECLARE @nextVal AS INT;
UPDATE Sequence 
	SET @nextVal &#x3D; val +&#x3D; 1; -- SET子句中的赋值表达式【从右向左执行】
SELECT @nextVal;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用这种特殊语法的UPDATE<strong>语句是作为原子操作而运行</strong>，因为它只须要访问一次数据，所以比使用单独的UPDATE和SELECT语句的效率要更高。</p>
<hr>
<h3 id="合并数据"><a href="#合并数据" class="headerlink" title="合并数据"></a>合并数据</h3><p>SQL Server 2008引入了一个称为<strong>MERGE</strong>的语句，它能<strong>在一条语句中根据逻辑条件对数据进行不同的修改操作</strong>( INSERT、UPDATE和DELETE)。<strong>MERGE语句是SQL标准的一部分</strong>，而T-SQL版本的MERGE语句也<strong>增加了一些非标准的扩展</strong>。</p>
<p>一个MERGER语句实现的功能通常可以转换成SQL Server早期版本的多个其他DML语句( INSERT, UPDATE, DELETE)的组合来实现。和其他方法相比，<strong>使用 MERGE语句的好处是：用较少的代码就可以表达需求，提高查询性能，因为它可以更少地访问查询涉及表</strong>。</p>
<p>为了演示MERGE语句，本节的例子将使用Customers表和CustomersStage表。运行如下代码来创建这两个表，并为它们填充示例数据。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> tempdb<span class="token punctuation">;</span>

<span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'dbo.Customers'</span><span class="token punctuation">,</span> <span class="token string">'U'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> 
	<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Customers<span class="token punctuation">;</span>
	
Go
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Customers
<span class="token punctuation">(</span>
    custId <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    companyName <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    phone <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    address <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    <span class="token keyword">CONSTRAINT</span> PK_Customers <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>custId<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>Customers<span class="token punctuation">(</span>custId<span class="token punctuation">,</span> companyName<span class="token punctuation">,</span> phone<span class="token punctuation">,</span> address<span class="token punctuation">)</span>
<span class="token keyword">VALUES</span>
	<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'cust 1'</span><span class="token punctuation">,</span> <span class="token string">'(111) 111-1111'</span><span class="token punctuation">,</span> <span class="token string">'address 1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'cust 2'</span><span class="token punctuation">,</span> <span class="token string">'(222) 222-2222'</span><span class="token punctuation">,</span> <span class="token string">'address 2'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'cust 3'</span><span class="token punctuation">,</span> <span class="token string">'(333) 333-3333'</span><span class="token punctuation">,</span> <span class="token string">'address 3'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'cust 4'</span><span class="token punctuation">,</span> <span class="token string">'(444) 444-4444'</span><span class="token punctuation">,</span> <span class="token string">'address 4'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">'cust 5'</span><span class="token punctuation">,</span> <span class="token string">'(555) 555-5555'</span><span class="token punctuation">,</span> <span class="token string">'address 5'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
<span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'dbo.CustomersStage'</span><span class="token punctuation">,</span><span class="token string">'u'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> 
	<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>CustomersStage<span class="token punctuation">;</span>
	
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>CustomersStage
<span class="token punctuation">(</span>
	custId <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    companyName <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    phone <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    address <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    	<span class="token keyword">CONSTRAINT</span> PK_CustomersStage <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>custId<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>CustomersStage<span class="token punctuation">(</span>custId<span class="token punctuation">,</span> companyName<span class="token punctuation">,</span> phone<span class="token punctuation">,</span> address<span class="token punctuation">)</span>
<span class="token keyword">VALUES</span>
	<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'AAAAA'</span><span class="token punctuation">,</span> <span class="token string">'(222) 222-2222'</span><span class="token punctuation">,</span> <span class="token string">'address2'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'cust 3'</span><span class="token punctuation">,</span> <span class="token string">'(333) 333-3333'</span><span class="token punctuation">,</span> <span class="token string">'address 3'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">'BBBBB'</span><span class="token punctuation">,</span> <span class="token string">'CCCCC'</span><span class="token punctuation">,</span> <span class="token string">'DDDDD'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">'cust 6 (new)'</span><span class="token punctuation">,</span> <span class="token string">'(666) 666-6666'</span><span class="token punctuation">,</span> <span class="token string">'address 6'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">'cust 7 (new)'</span><span class="token punctuation">,</span> <span class="token string">'(777) 777-7777'</span><span class="token punctuation">,</span> <span class="token string">'address 7'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>本节将将要演示的第一个MERGE语句的例子是<strong>把CustomersStage表（来源表）中的内容合并到Customers表（目标表）中</strong>。更具体地说，假设<strong>现在想增加一些还不存在的客户，并更新已经存在的客户属性</strong>。</p>
<p><strong>在MERGE子句中指定目标表的名称，在USING子句中指定来源表的名称</strong>。可以通过在ON子句中指定谓词来定义合并条件，这一点非常像连接。<strong>合并条件用于定义来源表中的哪些行在目标表中有匹配，哪些行没有匹配</strong>。在 MERGE语句中既可以在<strong>WHEN MATCHEDE THEN子句中定义当找到匹配时要进行的操作，也可以在WHEN NOT MATCHED THEN子句中定义当没有找到匹配时要进行的操作</strong>。</p>
<p>以下是第一个关于 MERGE语句的例子：<strong>增加还不存在的客户，并更新已经存在的客户</strong>：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">MERGE</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>Customers <span class="token keyword">AS</span> TGT
<span class="token keyword">USING</span> dbo<span class="token punctuation">.</span>CustomersStage <span class="token keyword">AS</span> SRC
	<span class="token keyword">ON</span> TGT<span class="token punctuation">.</span>custId <span class="token operator">=</span> SRC<span class="token punctuation">.</span>custId
<span class="token keyword">WHEN</span> <span class="token keyword">MATCHED</span> <span class="token keyword">THEN</span>
	<span class="token keyword">UPDATE</span> <span class="token keyword">SET</span>
		TGT<span class="token punctuation">.</span>companyName <span class="token operator">=</span> SRC<span class="token punctuation">.</span>companyName<span class="token punctuation">,</span>
		TGT<span class="token punctuation">.</span>phone <span class="token operator">=</span> SRC<span class="token punctuation">.</span>phone<span class="token punctuation">,</span>
		TGT<span class="token punctuation">.</span>address <span class="token operator">=</span> SRC<span class="token punctuation">.</span>address
<span class="token keyword">WHEN</span> <span class="token operator">NOT</span> <span class="token keyword">MATCHED</span> <span class="token keyword">THEN</span>
	<span class="token keyword">INSERT</span> <span class="token punctuation">(</span>custId<span class="token punctuation">,</span> companyName<span class="token punctuation">,</span> phone<span class="token punctuation">,</span> address<span class="token punctuation">)</span>
	<span class="token keyword">VALUES</span> <span class="token punctuation">(</span>SRC<span class="token punctuation">.</span>custId<span class="token punctuation">,</span> SRC<span class="token punctuation">.</span>companyName<span class="token punctuation">,</span> SRC<span class="token punctuation">.</span>phone<span class="token punctuation">,</span> SRC<span class="token punctuation">.</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>WHEN MATCHED子句用于定义当目标表的一个行和来源表的一个行能够匹配时应该采取的操作。WHEN NOT MATCHED子句用于定义当目标表中没有行能够和来源表中的行进行匹配时应该采取的操作</strong>。T-SQL还支持第3种子句<strong>WHEN NOT MATCHED BY SOURCE</strong>，<strong>它用于定义对于目标表的一个行，在来源表中没有与之匹配的行时应该采取的操作</strong>。例如，假设现在想为前面的MERGE例子增加以下逻辑处理：当目标表中的某一行<strong>在来源表中找不到匹配行</strong>时，就删除目标表中的这一行。需要做的只是増加一个带有DELETE操作的WHEN NOT MATCHED BY SOURCE子句，如下所示：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">MERGE</span> dbo<span class="token punctuation">.</span>Customers <span class="token keyword">AS</span> TGT
<span class="token keyword">USING</span> dbo<span class="token punctuation">.</span>CustomersStage <span class="token keyword">AS</span> SRC
<span class="token keyword">ON</span> TGT<span class="token punctuation">.</span>custId <span class="token operator">=</span> SRC<span class="token punctuation">.</span>custId
<span class="token keyword">WHEN</span> <span class="token keyword">MATCHED</span> <span class="token keyword">THEN</span>
	<span class="token keyword">UPDATE</span> <span class="token keyword">SET</span>
		TGT<span class="token punctuation">.</span>companyName <span class="token operator">=</span> SRC<span class="token punctuation">.</span>companyName<span class="token punctuation">,</span>
		TGT<span class="token punctuation">.</span>phone <span class="token operator">=</span> SRC<span class="token punctuation">.</span>phone<span class="token punctuation">,</span>
		TGT<span class="token punctuation">.</span>address <span class="token operator">=</span> SRC<span class="token punctuation">.</span>address
<span class="token keyword">WHEN</span> <span class="token operator">NOT</span> <span class="token keyword">MATCHED</span> <span class="token keyword">THEN</span> <span class="token comment">-- 不存在匹配时，将【来源表】中的数据行插入目标表</span>
	<span class="token keyword">INSERT</span> <span class="token punctuation">(</span>custId<span class="token punctuation">,</span> companyName<span class="token punctuation">,</span> phone<span class="token punctuation">,</span> adress<span class="token punctuation">)</span>
	<span class="token keyword">VALUES</span> <span class="token punctuation">(</span>SRC<span class="token punctuation">.</span>custId<span class="token punctuation">,</span> SRC<span class="token punctuation">.</span>companyName<span class="token punctuation">,</span> SRC<span class="token punctuation">.</span>phone<span class="token punctuation">,</span> SRC<span class="token punctuation">.</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">WHEN</span> <span class="token operator">NOT</span> <span class="token keyword">MATCHED</span> <span class="token keyword">BY</span> SOURCE <span class="token keyword">THEN</span> <span class="token comment">-- 在【来源表】中找不到匹配行</span>
	<span class="token keyword">DELETE</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>回到前面第一个MERGE例子，在这个例子中需要<strong>更新已经存在的客户和增加不存在的客户</strong>，可以看到，这个例子使用的方法并不是最有效的。<strong>在重写现有客户的属性之前，语句没有检查列值是否真的发生过变化</strong>。<strong>也就是说，即使来源表和目标表的行完全相同，仍然要修改客户行</strong>。用<strong>AND选项</strong>能够为不同的操作子句增加谓词条件，除了最初的条件以外，只有其他额外的谓词条件计算结果为TRUE时，才会执行相应的操作。在本例中，为了调整UPDATE操作，需要在WHEN MATCHED AND子句中增加一个谓词，以保证要修改的客户行中至少有一个属性发生过变化。完整的 MERGE语句如下所示：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">MERGE</span> dbo<span class="token punctuation">.</span>Customers <span class="token keyword">AS</span> TGT
<span class="token keyword">USING</span> dbo<span class="token punctuation">.</span>CustomersStage <span class="token keyword">AS</span> SRC
	<span class="token keyword">ON</span> TGT<span class="token punctuation">.</span>custId <span class="token operator">=</span> SRC<span class="token punctuation">.</span>custId
<span class="token keyword">WHEN</span> <span class="token keyword">MATCHED</span> <span class="token operator">AND</span>
	<span class="token punctuation">(</span>TGT<span class="token punctuation">.</span>companyName <span class="token operator">!=</span> SRC<span class="token punctuation">.</span>companyName
     <span class="token operator">OR</span> TGT<span class="token punctuation">.</span>phone <span class="token operator">!=</span> SRC<span class="token punctuation">.</span>phone
     <span class="token operator">OR</span> TGT<span class="token punctuation">.</span>address <span class="token operator">!=</span> SRC<span class="token punctuation">.</span>address<span class="token punctuation">)</span> 
	<span class="token keyword">THEN</span> <span class="token keyword">UPDATE</span> <span class="token keyword">SET</span>
		TGT<span class="token punctuation">.</span>companyName <span class="token operator">=</span> SRC<span class="token punctuation">.</span>companyName<span class="token punctuation">,</span>
		TGT<span class="token punctuation">.</span>phone <span class="token operator">=</span> SRC<span class="token punctuation">.</span>phone<span class="token punctuation">,</span>
		TGT<span class="token punctuation">.</span>address <span class="token operator">=</span> SRC<span class="token punctuation">.</span>address
<span class="token keyword">WHEN</span> <span class="token operator">NOT</span> <span class="token keyword">MATCHED</span> <span class="token keyword">THEN</span>
	<span class="token keyword">INSERT</span> <span class="token punctuation">(</span>custId<span class="token punctuation">,</span> companyName<span class="token punctuation">,</span> phone<span class="token punctuation">,</span> address<span class="token punctuation">)</span>
	<span class="token keyword">VALUES</span> <span class="token punctuation">(</span>SRC<span class="token punctuation">.</span>custId<span class="token punctuation">,</span> SRC<span class="token punctuation">.</span>companyName<span class="token punctuation">,</span> SRC<span class="token punctuation">.</span>phone<span class="token punctuation">,</span> SRC<span class="token punctuation">.</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到， MERGE语句的功能非常强大。与其他方法相比， <strong>MERGE语句在表达修改的逻辑处理时使用的代码更少，但在性能上更强</strong>。</p>
<p>虽然通常都是在<strong>需要根据逻辑条件来采取不同的操作</strong>的情况下，才会考虑使用MERGE语句；但当需要根据一个核心谓词条件为TRUE<strong>就采取一种操作时，也可以使用 MERGE语句</strong>。换句话说，<strong>MERGE语句可以和WHEN MATCHED子句分开使用，而不必非得需要WHEN NOT MATCHED子句</strong>。</p>
<hr>
<h3 id="通过表表达式修改数据"><a href="#通过表表达式修改数据" class="headerlink" title="通过表表达式修改数据"></a>通过表表达式修改数据</h3><p>SQL Server并没有限制在表表达式(派生表、CTE、视图及内联表值的UDF)中使用的操作只能是SELECT，相反，它<strong>允许在表表达式中使用其他DML语句（INSERT、UPDATE、DELETE及MERGE)</strong>。可以这么想：表表达式并不真正包含数据，它只是基础表中底层数据的一种反映。从这个角度来看，<strong>可以把对表表达式的修改看作是通过表表达式对底层表中数据的修改</strong>，就像使用 SELECT语句的表表达式一样。当使用数据修改语句时，同样也会对表表达式的定义进行扩展，所以实际操作还是对底层的表进行的修改。</p>
<p>通过表表达式修改数据须要满足以下逻辑限制，例如：</p>
<ul>
<li>如果定义表表达式的查询需要对表进行连接，则在同一修改语句中的修改只能影响连接的一边，而不能同时影响连接的两边。</li>
<li>不能对作为计算结果的列进行更新； SQL Server不会尝试对值进行反向工程（或反向解析）。</li>
<li>如果表表达式中至少有一列没有赋值，也无论如何都不能自动获取其值（没有默认值，不允许为NUL,也没有 IDENTITY属性），则不能通过该表表达式向表中插入数据行。</li>
</ul>
<p>在SQL Server 联机丛书中可以找到一些其他限制，可以看到，这些要求都有一定的意义。</p>
<p><strong>通过表表达式修改数据，可以更好地调试和解决问题</strong>。例如，前述的一处代码包含以下UPDATE语句：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> tempdb<span class="token punctuation">;</span>

<span class="token keyword">UPDATE</span> OD
	<span class="token keyword">SET</span> discount <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">0.05</span>
<span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>OrderDetails <span class="token keyword">AS</span> OD
	<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> dbo<span class="token punctuation">.</span>Orders <span class="token keyword">AS</span> O
		<span class="token keyword">ON</span> OD<span class="token punctuation">.</span>orderId <span class="token operator">=</span> O<span class="token punctuation">.</span>orderId
<span class="token keyword">WHERE</span> custId <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>假设为了解决问题，想先看看这个语句将要修改哪些行，但不真的进行修改。一种选择是修改代码，让它使用SELECT语句。解决了问题以后，再把代码修改回UPDATE语句。除了像这样在SELECT和UPDATE语句之间来回修改的方法以外，还可以简单地使用表表达式的方法。也就是说，<strong>可以在以上包含连接的SELECT语句基础上先定义一个表表达式，再对该表表达使用 UPDATE语句</strong>。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 使用CTE：</span>
<span class="token keyword">WITH</span> C <span class="token keyword">AS</span>
<span class="token punctuation">(</span>
	<span class="token keyword">SELECT</span> custId<span class="token punctuation">,</span> OD<span class="token punctuation">.</span>orderId<span class="token punctuation">,</span>
    	productId<span class="token punctuation">,</span> discount<span class="token punctuation">,</span> discount <span class="token operator">+</span> <span class="token number">0.05</span> <span class="token keyword">AS</span> newDiscount
    <span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>OrderDetails <span class="token keyword">AS</span> OD
    	<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> dbo<span class="token punctuation">.</span>Orders <span class="token keyword">AS</span> O
    		<span class="token keyword">ON</span> OD<span class="token punctuation">.</span>orderId <span class="token operator">=</span> O<span class="token punctuation">.</span>orderId
    <span class="token keyword">WHERE</span> custId <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">)</span>
<span class="token keyword">UPDATE</span> C
	<span class="token keyword">SET</span> discount <span class="token operator">=</span> newDiscount<span class="token punctuation">;</span>
	
<span class="token comment">-- 使用派生表:</span>
<span class="token keyword">UPDATE</span> D
	<span class="token keyword">SET</span> discount <span class="token operator">=</span> newDiscount
<span class="token keyword">FROM</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> custId<span class="token punctuation">,</span> OD<span class="token punctuation">.</span>orderId
      	productId<span class="token punctuation">,</span> discount<span class="token punctuation">,</span> discount <span class="token operator">+</span> <span class="token number">0.05</span> <span class="token keyword">AS</span> newDiscount
      <span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>OrderDetails <span class="token keyword">AS</span> OD
      	<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> dbo<span class="token punctuation">.</span>Orders <span class="token keyword">AS</span> O
      		<span class="token keyword">ON</span> OD<span class="token punctuation">.</span>orderId <span class="token operator">=</span> O<span class="token punctuation">.</span>orderId
      <span class="token keyword">WHERE</span> custId <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> D<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>**当使用表表达式时，解决问题就简单多了，因为总是可以把定义表表达式的SELECT语句单独分离出来再运行，这样就不会修改任何数据。**在这个例子中，使用表表达式只是为了方便。然而，<strong>对于某些问题，使用表表达式并不是选择与否的问题，而是必须使用</strong>。为了演示这个问題，将使用一个名为T1的表作为例子，以下代码用于创建和填充这个表：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> tempdb<span class="token punctuation">;</span>

<span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'dbo.T1'</span><span class="token punctuation">,</span> <span class="token string">'U'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> 
	<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>T1<span class="token punctuation">;</span>

<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>T1<span class="token punctuation">(</span>Col1 <span class="token keyword">INT</span><span class="token punctuation">,</span> Co12 <span class="token keyword">INT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>T1<span class="token punctuation">(</span>col1<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>T1<span class="token punctuation">(</span>col1<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>T1<span class="token punctuation">(</span>col1<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>假设现在想更新这个表，<strong>把col2列设置为一个包含ROW_NUMBER函数的表达式的结果</strong>。问题出现了，<strong>UPDATE语句的SET子句中不允许包含ROW_NUMBER函数</strong>。如下代码运行会报错：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> dbo<span class="token punctuation">.</span>T1
	<span class="token keyword">SET</span> col2 <span class="token operator">=</span> ROW_NUMBER<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span><span class="token punctuation">(</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> COl1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>为了避开这个问题，可以定义一个表表达式，由它返回须要更新的列(col2)和一个包含ROW_NUMBER函数的表达式的结果列(称为rowNum)。对表表达式进行查询的外部査询将是一个UPDATE语句，由它将col2列设置为rowNum。以下是用CTE方法实现的代码：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">WITH</span> C <span class="token keyword">AS</span>
<span class="token punctuation">(</span>
	<span class="token keyword">SELECT</span> col1<span class="token punctuation">,</span> col2<span class="token punctuation">,</span> ROW_NUMBER<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span><span class="token punctuation">(</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> col1<span class="token punctuation">)</span> <span class="token keyword">AS</span> rowNum
    <span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>T1
<span class="token punctuation">)</span>
<span class="token keyword">UPDATE</span> C
	<span class="token keyword">SET</span> co12 <span class="token operator">=</span> rowNum<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h3 id="带有-TOP-选项的数据更新"><a href="#带有-TOP-选项的数据更新" class="headerlink" title="带有 TOP 选项的数据更新"></a>带有 TOP 选项的数据更新</h3><p>SQL Server 2008把对TOP选项的支持扩展到新增的MERGE语句。<strong>当使用TOP选项时，如果已经处理过的行数达到指定的数量或百分比后，SQL Server将会立即停止处理修改语句</strong>。不幸的是，<strong>与SELECT语句不同，不能为修改语句中的TOP选项指定逻辑上的ORDER BY子句。事实上，SQL Server最初访问到哪些行，修改操作就会影响到哪些行</strong>。</p>
<p>下面将使用tempdb数据库中的Orders表来演示带有TOP选项的修改操作，运行以下代码以创建这个表，并用示例数据填充该表：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> tempdb<span class="token punctuation">;</span>

<span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'dbo.OrderDetails'</span><span class="token punctuation">,</span> <span class="token string">'U'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> 
	<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>OrderDetails<span class="token punctuation">;</span>
<span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'dbo.Orders'</span><span class="token punctuation">,</span> <span class="token string">'U'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> 
	<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Orders<span class="token punctuation">;</span>
	
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>Orders <span class="token keyword">FROM</span> TSQLFundamentals2008<span class="token punctuation">.</span>Sales<span class="token punctuation">.</span>Orders<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>下面这个例子演示了用带有TOP选项的 DELETE语句来删除Orders表的50行数据</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DELETE</span> <span class="token keyword">TOP</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>Orders<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<p>因为不允许为修改语句中的TOP选项指定逻辑上的ORDER BY子句，所以，上面这个査询就会有一定问题：<strong>无法控制将要删除哪50行数据</strong>。这个问题暴露了在修改语句中使用TOP选项的局限性。</p>
<p>当然，<strong>在实际应用中，通常会在意修改将影响哪些行，而不能有选择地修改哪些行</strong>。为了避开这个问题，<strong>可以借助表表达式来修改数据</strong>。可以在<strong>带有TOP选项的SELECT查询</strong>的基础上<strong>定义一个表表达式</strong>，这样就能<strong>用一个逻辑上的ORDER BY子句来定义各行之间的优先关系</strong>。接下来就要编写修改语句，在修改语句中再使用表表达式。</p>
<p>例如，以下代码将删除具有最小订单ID值的50个订单，而不是随机删除50行：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">WITH</span> C <span class="token keyword">AS</span>
<span class="token punctuation">(</span>
    <span class="token keyword">SELECT</span> <span class="token keyword">TOP</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span>
    <span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span> Orders
    <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> orderid
<span class="token punctuation">)</span>
<span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> C<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>同样，以下代码将更新具有最大订单ID值的50个订单，将其freight列的值增加10：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">WITH</span> C <span class="token keyword">AS</span>
<span class="token punctuation">(</span>
	<span class="token keyword">SELECT</span> <span class="token keyword">TOP</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span>
    <span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>Orders
    <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> orderId <span class="token keyword">DESC</span>
<span class="token punctuation">)</span>
<span class="token keyword">UPDATE</span> C
	<span class="token keyword">SET</span> freight <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">10.00</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h3 id="OUTPUT-子句"><a href="#OUTPUT-子句" class="headerlink" title="OUTPUT 子句"></a>OUTPUT 子句</h3><p>例如，考虑UPDATE语句，除了修改数据以外，<strong>对于发生更新的列，UPDATE语句还可以返回这个列更新之前和更新之后的值</strong>。在排除问题、审核等其他情况下，这样的功能很有用处。</p>
<p>SQL Server 2005引入了一个名为<strong>OUTPUT</strong>的子句，<strong>通过在修改语句中添加 OUTPUT子句，就可以实现从修改语句中返回数据的功能</strong>。在 OUTPUT子句中，可以指定希望从修改过的行中要返回的列和表达式。SQL Server2008还支持在新的MERGE语句中使用OUTPUT子句。</p>
<p>OUTPUT子句的考虑方式<strong>和SELECT子句非常像</strong>，也就是说，它们都是把想要返回的列或基于现有列的表达式依次列举出来。按照OUTPUT子句的语法，不同之处在于<strong>需要在列名之前加上inserted或deleted关键字</strong>。在INSERT语句中需要引用inserted，在DELETE语句中需要引用deleted。而在UPDATE语句中，如果需要<strong>更新前行的映像(Image)</strong>，则引用deleted；如果需要<strong>更新后行的映像</strong>，则引用inserted。</p>
<p>对于在OUTPUT子句中请求的各个属性，它会把来自修改过的各行中的相应值作为结果集而返回，这一点和SELECT语句的处理非常像。如果想把结果集导入另一个表，可以增加一个INTO子句，并提供目标表的名称。<strong>如果既想把修改过的行返回给调用者，又想把这些数据导入另一个表，则可以指定两个OUTPUT子句（一个有INTO子句，另一个没有）</strong>。</p>
<hr>
<h4 id="带有-OUTPUT-的-INSERT-语句"><a href="#带有-OUTPUT-的-INSERT-语句" class="headerlink" title="带有 OUTPUT 的 INSERT 语句"></a>带有 OUTPUT 的 INSERT 语句</h4><p>当需要为<strong>包含标识列的表</strong>插入数据行，同时<strong>又想知道所有新生成的标识值</strong>时，<strong>在INSERT语句中使用OUTPUT子句</strong>将非常有用。 <strong>SCOPE_IDENTITY函数只能返回当前范围内会话最后生成的标识值，但对于一次插入多行（即一个行集）的 INSERT语句，如果要返回生成的所有标识值，SCOPE_IDENTITY函数就帮不上多少忙了</strong>。而有了OUTPUT子句，解决问题就非常简单了。为了演示这种技术，按如下代码创建表：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> tempdb<span class="token punctuation">;</span>

<span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'dbo.T1'</span><span class="token punctuation">,</span> <span class="token string">'U'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> 
	<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>T1<span class="token punctuation">;</span>
	
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>T1
<span class="token punctuation">(</span>
	keyCol <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">IDENTITY</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">CONSTRAINT</span> PK_71 <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
    dataCol NVARCHAR<span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>假设现在想把对TSQLFundamentals2008数据库中HR.Employees表的一个查询结果插入T1表。为了返回由INSERT语句新产生的所有标识值，只要简单地增加一个OUTPUT子句，并指定想要返回的列：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">INSERT INTO dbo.T1(dataCol)
	OUTPUT inserted.keyCol, inserted.dataCol
SELECT lastName
FROM TSQLFundamentals2008.HR.Employees
WHERE country &#x3D; &#39;USA&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如前所述，也可以把结果集导入另一个表。该表可以是一个真实存在的表、临时表或一个<strong>表变量</strong>。如果把结果集保存在目标表中，则可以通过查询该表来操作这些数据。例如，以下代码首先声明一个名为@ NewRows的变量，然后将另一个结果集插入T1，最后将OUTPUT子句返回的结果集导入表变量。接着再用代码来查询该表变量，以显示存储到其中的数据：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DECLARE</span> <span class="token variable">@NewRows</span> <span class="token keyword">TABLE</span><span class="token punctuation">(</span>keyCol <span class="token keyword">INT</span><span class="token punctuation">,</span> dataCom NVARCHAR<span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">-- 表变量</span>

<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>T1<span class="token punctuation">(</span>dataCol<span class="token punctuation">)</span>
	OUTPUT inserted<span class="token punctuation">.</span>keyCol<span class="token punctuation">,</span> inserted<span class="token punctuation">.</span>dataCol
	<span class="token keyword">INTO</span> <span class="token variable">@NewRows</span>
		<span class="token keyword">SELECT</span> lastName
		<span class="token keyword">FROM</span> TSQLFundamentals2008<span class="token punctuation">.</span>HR<span class="token punctuation">.</span>Employees
		<span class="token keyword">WHERE</span> country <span class="token operator">=</span> <span class="token string">'UK'</span><span class="token punctuation">;</span>
		
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token variable">@NewRows</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h4 id="带有-OUTPUT-的-DELETE-语句"><a href="#带有-OUTPUT-的-DELETE-语句" class="headerlink" title="带有 OUTPUT 的 DELETE 语句"></a>带有 OUTPUT 的 DELETE 语句</h4><p>接下来，举例说明如何在DELETE语句中使用OUTPUT子句。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> tempdb<span class="token punctuation">;</span>

<span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'dbo.orders'</span><span class="token punctuation">,</span> <span class="token string">'U'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> 
	<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Orders<span class="token punctuation">;</span>
	
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>Orders 
<span class="token keyword">FROM</span> TSQLFundamentals2008<span class="token punctuation">.</span>Sales<span class="token punctuation">.</span>Orders<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>以下代码将删除2008年之前下过的所有订单，并使用 OUTPUT子句返回被删除行中的一些列：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>Orders
	OUTPUT
		deleted<span class="token punctuation">.</span>orderId<span class="token punctuation">,</span>
		deleted<span class="token punctuation">.</span>orderDate<span class="token punctuation">,</span>
		deleted<span class="token punctuation">.</span>empId<span class="token punctuation">,</span>
		deleted<span class="token punctuation">.</span>custId
    <span class="token comment">-- INTO ...</span>
<span class="token keyword">WHERE</span> orderDate <span class="token operator">&lt;</span> <span class="token string">'20080101'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果想对被删除的各行进行归档，只要简单地增加一个INTO子句，并指定用于归档的表名作为其目标表。</p>
<hr>
<h4 id="带有-OUTPUT-的-UPDATE-语句"><a href="#带有-OUTPUT-的-UPDATE-语句" class="headerlink" title="带有 OUTPUT 的 UPDATE 语句"></a>带有 OUTPUT 的 UPDATE 语句</h4><p>在UPDATE语句中使用OUTPUT子句时，既可以通过将<strong>deleted关键字</strong>作为列名的前缀来引用被修改的行在<strong>发生变化之前的映像</strong>，也可以通过将<strong>inserted关键字</strong>作为列名的前缀来引用被修改的行在<strong>发生变化之后的映像</strong>。用这种方法就可以<strong>返回更新过的列的新、旧两个版本</strong>。</p>
<p>在演示如何在UPDATE语句中使用OUTPUT子句之前，先运行以下代码，在tempdb数据库中以dbo架构创建一个 TSQLFundamentals2008数据库中 Sales.OrderDetails表的复本：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> tempdb<span class="token punctuation">;</span>

<span class="token keyword">IF</span> OBJEC_ID<span class="token punctuation">(</span><span class="token string">'dbo.OrderDetails'</span><span class="token punctuation">,</span> <span class="token string">'U'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> 
	<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>OrderDetails<span class="token punctuation">;</span>
	
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>OrderDetails 
<span class="token keyword">FROM</span> TSQLFundamentals2008<span class="token punctuation">.</span>Sales<span class="token punctuation">.</span>Orderdetails<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>以下UPDATE语句为与产品51相关的所有订单详情增加5%的折扣，并使用OUTPUT子句从修改过的行中返回产品ID、原来的折扣值和新的折扣值：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">UPDATE dbo.OrderDetails
SET discount +&#x3D; 0.05
OUTPUT
	inserted.productId,
	deleted.discount AS oldDiscount,
	inserted.discount AS newDiscount
WHERE productId &#x3D; 51;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h4 id="带有-OUTPUT-的-MERGE-语句"><a href="#带有-OUTPUT-的-MERGE-语句" class="headerlink" title="带有 OUTPUT 的 MERGE 语句"></a>带有 OUTPUT 的 MERGE 语句</h4><p>在MERGE语句中同样也可以使用OUTPUT子句，但要记得<strong>一个MERGE语句可以根据条件逻辑调用多个不同的DML操作</strong>。<strong>这意味着一个MERGE语句可能返回由不同DML操作生成的OUTPUT子句行</strong>。为了标识输出行由哪个DML操作生成，可以在OUTPUT子句中调用一个<strong>名为<code>$Saction</code>的函数，它会返回一个代表相应操作的字符串（“INSERT”、“UPDATE”及“DELETE”）</strong>。为了演示在MERGE语句中如何使用OUTPUT子句，这里将使用本章前面“合并数据”一节中的例子。为了运行这个例子，务必再次运行“合并数据”一节中的代码，重新在tempdb数据库中创建Customers表和CustomersStage表，并为其填充示例数据。</p>
<p>以下代码将CustomersStage表的内容合并到Customers表，如果客户已经在目标表中存在，则更新该客户的一些属性，否则将客户添加到目标表中：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">MERGE INTO dbo.Customers AS TGT
USING dbo.CustomersStage AS SRC
	ON TGT.custId &#x3D; SRC.custId
WHEN MATCHED THEN
	UPDATE SET
		TGT.companyName &#x3D; SRC.companyName,
		TGT.phone &#x3D; SRC.phone,
		TGT.address &#x3D; SRC.address
WHEN NOT MATCHED THEN
	INSERT (custId, companyName, phone, address)
	VALUES (SRC.custId, SRC.companyName, SRC.phone, SRC.address)
OUTPUT $action, inserted.custId,
	deleted.companyName AS oldCompanyName,
	inserted.companyName AS newCompanyName,
	deleted.phone AS oldPhone,
	inserted.phone AS newPhone,
	deleted.address AS oldAddress,
	inserted.address AS newAddress;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>以上MERGE语句使用OUTPUT子句返回被修改过的行的新、旧版本的值。当然，<strong>对于INSERT操作不存在旧版本的值，因此所有引用deleted的列都返回NULL</strong>。<strong><code>$action</code>函数可以告诉我们输出行是由UPDATE，还是由INSERT操作生成的</strong>。</p>
<hr>
<h4 id="可组合的-DML"><a href="#可组合的-DML" class="headerlink" title="可组合的 DML"></a>可组合的 DML</h4><p>OUTPUT子句为每个修改过的行返回一个输出行。但是，<strong>如果出于审核的目的，只需要把修改过的行的一个子集导入一个表</strong>，应该怎么做呢？以前在SQL Server 2005中，必须先把所有行导入一个临时表(staging table)，然后再将需要的子集行从临时表复制到审核表中。<strong>SQL Server 2008则引入了一种称为组合DML(composable DML)的功能，可以通过这种功能来跳过临时表的处理阶段，直接从被修改过的行的全部集合中将需要的子集行插入最终的目标表</strong>。</p>
<p>为了演示这种功能，先运行以下代码，在tempdb数据库以dbo架构创建一个Products表( TSQLFundamentals2008数据库的Production.Products表的复本)和ProductsAudit表：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> tempdb<span class="token punctuation">;</span>

<span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'dbo.ProductsAudit'</span><span class="token punctuation">,</span> <span class="token string">'U'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> 
	<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>ProductsAudit<span class="token punctuation">;</span>
<span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'dbo.Products'</span><span class="token punctuation">,</span> <span class="token string">'U'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> 
	<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Products<span class="token punctuation">;</span>
	
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>Products <span class="token keyword">FROM</span> TSQLFundamentals2008<span class="token punctuation">.</span>Production<span class="token punctuation">.</span>Product<span class="token punctuation">;</span>

<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>ProductsAudit
<span class="token punctuation">(</span>
	LSN <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">IDENTITY</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
    TS <span class="token keyword">DATETIME</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span><span class="token punctuation">(</span><span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    productId <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    colName SYSNAME <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    oldVal SQL_VARIANT <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    newVal SQL_VARIANT <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>假设现在须要更新由供应商1提供的所有产品，将其价格提高15%。同样，还需要<strong>审核那些被更新的产品的原有价格和新价格，但只审核原来的价格低于20，而新价格高于或等于20的那些产品</strong>。</p>
<p>可以用组合DML来实现该这一需求。先编写一个<strong>带有OUTPUT子句的UPDATE语句，然后基于该UPDATE语句定义一个派生表</strong>。再写一个<strong>对派生表进行查询的INSERT SELECT语句，只筛选出需要的行</strong>。以下是解决方案的完整查询语句：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>ProductsAudit<span class="token punctuation">(</span>productId<span class="token punctuation">,</span> colName<span class="token punctuation">,</span> oldVal<span class="token punctuation">,</span> newVal<span class="token punctuation">)</span>
<span class="token keyword">SELECT</span> productId<span class="token punctuation">,</span> <span class="token string">'unitPrice'</span><span class="token punctuation">,</span> oldVal<span class="token punctuation">,</span> newVal
<span class="token keyword">FROM</span> <span class="token punctuation">(</span><span class="token keyword">UPDATE</span> dbo<span class="token punctuation">.</span>Products
      	<span class="token keyword">SET</span> unitPrice <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">1.15</span>
			OUTPUT
              inserted<span class="token punctuation">.</span>productId<span class="token punctuation">,</span>
              deleted<span class="token punctuation">.</span>unitPrice <span class="token keyword">AS</span> oldVal<span class="token punctuation">,</span>
              inserted<span class="token punctuation">.</span>unitPrice <span class="token keyword">AS</span> newVal
		<span class="token keyword">WHERE</span> SupplierID <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> D
<span class="token keyword">WHERE</span> oldVal <span class="token operator">&lt;</span> <span class="token number">20.0</span> <span class="token operator">AND</span> newVal <span class="token operator">>=</span> <span class="token number">20.0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h2 id="事务和并发"><a href="#事务和并发" class="headerlink" title="事务和并发"></a>事务和并发</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务是作为<strong>单个工作单元</strong>而执行的一系列操作，如查询和修改数据，甚至可能是修改数据定义。</p>
<p><strong>定义事务边界</strong>的方式有<strong>显式</strong>和<strong>隐式</strong>两种：</p>
<ul>
<li><p><strong>显式事务的定义需要以<code>BEGIN TRAN</code>语句作为开始</strong>，如果想<strong>提交事务，则应该以<code>COMMIT TRAN</code>语句显式结束事务</strong>；如果<strong>不想提交事务（撤消事务中的修改），则应该以<code>ROLLBACK TRAN</code>语句显式结束事务</strong>。</p>
<p>  下面的例子将两个INSERT语句封装在由BEGIN TRAN和COMMIT TRAN定义的一个事务边界中：</p>
  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">BEGIN</span> <span class="token keyword">TRAN</span><span class="token punctuation">;</span>
	<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>T1<span class="token punctuation">(</span>keyCol<span class="token punctuation">,</span> col1<span class="token punctuation">,</span> co12<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">101</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>T2<span class="token punctuation">(</span>keyCol<span class="token punctuation">,</span> col1<span class="token punctuation">,</span> co12<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">201</span><span class="token punctuation">,</span> <span class="token string">'X'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">COMMIT</span> <span class="token keyword">TRAN</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>如果不显式定义事务的边界，SQL Server会<strong>默认把每个单独的语句作为一个事务</strong>；换句话说， SQL Server默认在执行完每个语句之后就自动提交事务。</p>
</li>
</ul>
<p>提示：通过查询<code>@@TRANCOUNT</code>函数，在代码的任何位置都可以用编程方式来<strong>判断当前是否位于一个打开的事务当中</strong>。如果<strong>不在任何打开的事务范围内，则该函数返回0</strong>；如果在某个打开的事务范围内，则返回一个大于0的值。</p>
<p>可以<strong>通过<code>IMPLICIT_TRANSACTIONS</code>会话选项来改变 SQL Server处理隐式事务的方式</strong>。该选项默认是OFF。<strong>当把这个选项设置为ON时，就不必用<code>BEGIN TRAN</code>语句来标明事务开始，但每个事务仍需要以<code>COMMIT TRAN</code>或<code>ROLLBACK TRAN</code>语句来标明事务完成</strong>。</p>
<p>事务必须有四个属性：<strong>原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)</strong>，这4个属性的首字母可以缩写为<strong>ACID</strong>。</p>
<ul>
<li><p>原子性 (Atomicity)</p>
<p>  事务必须是是原子工作单元。这意味着在事务中进行的修改，要么全都执行，要么全都不执行。如果在<strong>事务完成之前</strong>（<strong>在提交指令被记录到事务日志之前</strong>）系统出现故障或是重新启动，SQL Server将会<strong>撤消在事务中进行的所有修改</strong>。同样，如果在事务处理中<strong>遇到错误</strong>， SQL Server通常会<strong>自动回滚事务</strong>，但是也有少数例外。<strong>一些不太严重的错误不会引发事务的自动回滚，例如主键冲突（primary key violation)、锁超时（在本章后面会讨论这个问题）等</strong>。<strong>可以使用错误处理代码来捕获这些错误，并采取某种操作(例如，把错误记录在日志中，再回滚事务)</strong>。第10章“可编程对象”概述如何用代码进行错误处理。</p>
</li>
<li><p>一致性 (Consistency)</p>
<p>  事务的一致性这个术语指的是，<strong>同时发生的事务在修改和查询数据时不发生冲突</strong>，通过 RDBMS访问的数据要保持一致的状态。可以想到，<strong>一致性是一个具有一定主观性的术语</strong>，取决于应用程序的需要。在本章后面的“隔离级别”一节中会介绍 SQL Server默认采用的一致性级别，以及如果默认的行为不适合实际应用时，如何对一致性进行控制。</p>
</li>
<li><p>隔离性 (Isolation)</p>
<p>  隔离性是一种用于<strong>控制数据访问的机制</strong>，能够<strong>确保事务只访问处于期望的一致性级别下的数据</strong>。 SQL Server<strong>使用锁对各个事务之间正在修改和查询的数据进行隔离</strong>。本章后面的“锁”这一小节提供了有关隔离级别的更多细节。</p>
</li>
<li><p>持久性 (Durability)</p>
<p>  在将数据修改写入到磁盘上数据库的数据分区之前，总是先把这些修改写入到磁盘上数据库的<strong>事务日志</strong>中。<strong>把提交指令记录到磁盘的事务日志中以后，即使数据修改还没有应用到磁盘的数据分区，也可以认为事务是持久化的</strong>。这时如果系统重新启动（正常启动或在发生系统故障之后启动）， SQL Server会检查每个数据库的事务日志，进行<strong>恢复(recovery)处理</strong>。恢复处理一般包括两个阶段：<strong>重做阶段(redo)和撤消阶段(undo)</strong>。</p>
<ul>
<li>在重做阶段，对于提交指令已经写入到日志，但数据修改还没有应用到数据分区的事务，数据库引擎会重做(replaying)这些事务所做的所有修改，这个过程也称为“前滚( rolling forward)”。</li>
<li>在撤消阶段，对于提交指令还没有记录到日志中的事务，数据库引擎会撤消(undoing)这些事务所做的修改，这个过程也称为“回滚(rolling back)”。</li>
</ul>
</li>
</ul>
<p>例如，以下代码定义了一个事务，把关于一个新订单的数据记录到TSQLFundamentals2008数据库中：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> TSQLFundamentals2008<span class="token punctuation">;</span>

<span class="token comment">-- 开始一个新的事务</span>
<span class="token keyword">BEGIN</span> <span class="token keyword">TRAN</span><span class="token punctuation">;</span>
	<span class="token comment">-- 声明一个变量</span>
	<span class="token keyword">DECLARE</span> <span class="token variable">@newOrderId</span> <span class="token keyword">AS</span> <span class="token keyword">INT</span><span class="token punctuation">;</span>
	
	<span class="token comment">-- 将一个新订单入到Sa1es.Orders表</span>
	<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Sales<span class="token punctuation">.</span>Orders
		<span class="token punctuation">(</span>custId<span class="token punctuation">,</span> empId<span class="token punctuation">,</span> orderDate<span class="token punctuation">,</span> requiredDate<span class="token punctuation">,</span> shippedDate<span class="token punctuation">,</span>
         shipperId<span class="token punctuation">,</span> freight<span class="token punctuation">,</span> shipName<span class="token punctuation">,</span> shipAddress<span class="token punctuation">,</span> shipCity<span class="token punctuation">,</span>
         shipPostalCode<span class="token punctuation">,</span> shipCountry<span class="token punctuation">)</span>
    <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">85</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">'20090212'</span><span class="token punctuation">,</span> <span class="token string">'20090301'</span><span class="token punctuation">,</span> <span class="token string">'20090216'</span><span class="token punctuation">,</span>
            <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">32.38</span><span class="token punctuation">,</span> <span class="token string">'Ship to 85-B'</span><span class="token punctuation">,</span> <span class="token string">'6789 rue de 1''abbaye'</span><span class="token punctuation">,</span> <span class="token string">'Reims'</span><span class="token punctuation">,</span>
            <span class="token string">'10345'</span><span class="token punctuation">,</span> <span class="token string">'France'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            
    <span class="token comment">-- 将新的订单ID保存在变量中（由于orderId列具有IDENTITY属性，所以在插入订单时， SQL Server会自动生成新的订单ID）</span>
    <span class="token keyword">SET</span> <span class="token variable">@newOrderId</span> <span class="token operator">=</span> SCOPE_IDENTITY<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">-- 返回新的订单ID</span>
    <span class="token keyword">SELECT</span> <span class="token variable">@newOrderId</span> <span class="token keyword">AS</span> newOrderId<span class="token punctuation">;</span>
    
    <span class="token comment">-- 将新订单的订单明细行插入到Sales.OrderDetai1s表</span>
    <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> sales<span class="token punctuation">.</span>OrderDetails
    	<span class="token punctuation">(</span>orderId<span class="token punctuation">,</span> productId<span class="token punctuation">,</span> unitPrice<span class="token punctuation">,</span> qty<span class="token punctuation">,</span> discount<span class="token punctuation">)</span>
    <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token variable">@newOrderId</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">14.00</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">0.000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Sales<span class="token punctuation">.</span>OrderDetails
    	<span class="token punctuation">(</span>orderId<span class="token punctuation">,</span> productId<span class="token punctuation">,</span> unitPrice<span class="token punctuation">,</span> qty<span class="token punctuation">,</span> discount<span class="token punctuation">)</span>
    <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token variable">@newOrderId</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">9.80</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0.000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Sales<span class="token punctuation">.</span>OrderDetails
    	<span class="token punctuation">(</span>orderId<span class="token punctuation">,</span> productId<span class="token punctuation">,</span> unitPrice<span class="token punctuation">,</span> qty<span class="token punctuation">,</span> discount<span class="token punctuation">)</span>
   	<span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token variable">@newOrderId</span><span class="token punctuation">,</span> <span class="token number">72</span><span class="token punctuation">,</span> <span class="token number">34.80</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0.000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">-- 提交事务</span>
<span class="token keyword">COMMIT</span> <span class="token keyword">TRAN</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意，<strong>这个例子没有进行错误处理，因而也就没有提供出错时的 ROLLBACK（回滚）语句</strong>。<strong>为了进行错误处理，可以把事务封装在一个<code>TRY/CATCH</code>代码结构中</strong>。第10章概述了如何用代码进行错误处理。</p>
<p>操作完成后，运行以下代码清理测试数据：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>OrderDetails
<span class="token keyword">WHERE</span> orderId <span class="token operator">></span> <span class="token number">11077</span><span class="token punctuation">;</span>

<span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders
<span class="token keyword">WHERE</span> orderId <span class="token operator">></span> <span class="token number">11077</span><span class="token punctuation">;</span>

<span class="token keyword">DBCC</span> CHECKIDENT<span class="token punctuation">(</span><span class="token string">'Sales.Orders'</span><span class="token punctuation">,</span> RESEED<span class="token punctuation">,</span> <span class="token number">11077</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">-- 【重设表的当前标识值】</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h3 id="锁定和阻塞"><a href="#锁定和阻塞" class="headerlink" title="锁定和阻塞"></a>锁定和阻塞</h3><p>SQL Server<strong>使用锁(lock)来实施事务隔离属性</strong>。本节将详细介绍锁定( locking)的相关细节，以及如何解决由冲突的锁定请求而引起阻塞的问题。</p>
<hr>
<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>锁是事务获取的一种<strong>控制资源</strong>，用于<strong>保护数据资源，防止其他事务对数据进行冲突的或不兼容的访问</strong>。这部分首先介绍SQL Server支持的几种重要的<strong>锁模式(lock mode)和它们的兼容性</strong>，接着再讲述<strong>可以锁定的资源类型</strong>。</p>
<hr>
<h5 id="锁模式及其兼容性"><a href="#锁模式及其兼容性" class="headerlink" title="锁模式及其兼容性"></a>锁模式及其兼容性</h5><p>开始学习事务和并发性时，应该首先熟悉两种主要的锁模式——<strong>排他锁(exclusive lock)和共享锁(shared lock)</strong>。其他类型的锁模式(<strong>更新锁、意向锁、架构锁</strong>)是更高级的锁模式。</p>
<p>当试图<strong>修改数据</strong>时，<strong>事务会为所依赖的数据资源请求排他锁</strong>，一旦授予，事务将<strong>一直持有排他锁，直至事务完成</strong>。这种锁模式<strong>之所以称为排他锁，是因为对于相同的数据资源，如果有其他事务已经获得了该资源的任何类型的锁，就不能再获得该资源的排他锁；如果有其他事务已经获得了该资源的排他锁，就不能再获得该资源的任何类型的锁</strong>。这是<strong>修改行为的默认处理方式，而且这种默认行为不能改变</strong>一一不能改变为修改数据资源而请求的锁模式（排他锁），也不能改变持有锁的时间长度（直到事务完成）。</p>
<p>当试图<strong>读取数据</strong>时，<strong>事务默认会为所依赖的数据资源请求共享锁</strong>，读操作一完成，就立即释放资源上的共享锁。这种锁模式<strong>之所以称为共享锁，是因为多个事务可以同时持有同一数据资源上的共享锁</strong>。虽然当修改数据时不能改变请求的锁模式和持续时间，但当<strong>读取数据时可以对如何处理锁定进行控制</strong>。本章后面的“隔离级别”一节将对此作详细介绍。</p>
<p><strong>事务之间的相互制约关系就是锁的兼容性</strong>。下表给出了<strong>排他锁和共享锁之间的兼容性</strong>，其中列代表已经授予的锁模式，行代表请求授予的锁模式。</p>
<table>
<thead>
<tr>
<th>请求模式</th>
<th>已经授予排他锁（X）</th>
<th>已经授予共享锁（S）</th>
</tr>
</thead>
<tbody><tr>
<td>授予请求的排他锁？</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>授予请求的共享锁？</td>
<td>否</td>
<td><strong>是</strong></td>
</tr>
</tbody></table>
<p>用简单的话来总结一下事务之间锁的相互制约关系：<strong>如果数据正在由一个事务进行修改，其他事务就既不能修改该数据，也不能读取（至少默认不能）该数据，直到第一个事务完成。如果数据正在由另一个事务读取，其他事务就不能修改该数据（至少默认不能）</strong>。</p>
<hr>
<h5 id="可锁定资源的类型"><a href="#可锁定资源的类型" class="headerlink" title="可锁定资源的类型"></a>可锁定资源的类型</h5><p>SQL Server可以锁定不同类型或粒度的资源，这些资源类型包括<strong>RID或KEY（行）、PAGE（页）、对象(例如表)、数据库等</strong>。行位于页中，而页则是包含表或索引数据的物理数据块。你应该先熟悉这些资源类型，到了更高级的阶段再去了解其他可锁定的资源类型，如 EXTENT（区）、分配单元(ALLOCATION_UNIT）、堆（HEAP）以及B树(B-tree）。</p>
<p>为了获得特定资源类型上的锁，事务<strong>必须先在更高的粒度级别上获得相同模式的意向锁</strong>。例如，为了获得<strong>某一行的排他锁</strong>，事务<strong>必须先在包含那一行的页上获取意向排他锁，并在包含那一页的数据对象上也获取意向排他锁</strong>。同样，<strong>要获得某一粒度级别上的共享锁，事务就必须先在更高的粒度级别上获取意向共享锁</strong>。<strong>意向锁的目的</strong>是为了<strong>在较高的粒度级别上有效地检测不兼容的锁定请求，防止授予不兼容的锁</strong>。例如，如果一个事务持有一个行锁，而其他事务想在包含那一行的整个页或表上请求不兼容的锁模式，这时SQL Server可以很容易地识别出这种冲突，因为第一个事务已经获取了相关页和表上的意向锁。<strong>意向锁不会干预较低粒度上的锁定请求</strong>。例如，<strong>一个页上的意向锁不会阻止其他事务在该页内的行上获取不兼容的锁模式</strong>。下表对锁兼容性的内容进行了扩展，增加了<strong>意向排它锁</strong>(<strong>IX</strong>锁, <strong>I</strong>ntent <strong>Ex</strong>clusive)和<strong>意向共享锁</strong>(<strong>IS</strong>锁)。</p>
<table>
<thead>
<tr>
<th align="left">请求模式</th>
<th>已经授予排他锁(X)</th>
<th>已经授予共享锁(S)</th>
<th>已经授予意向排他锁(IX)</th>
<th align="left">已经授予意向共享锁(IS)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">授予请求的排他锁？</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">授予请求的共享锁？</td>
<td>否</td>
<td>是</td>
<td>否</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">授予请求的意向排他锁？</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">授予请求的意向共享锁？</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td align="left">是</td>
</tr>
</tbody></table>
<p>SQL Server<strong>动态决定</strong>应该锁定哪种类型的资源。自然，为了获得理想的并发性，最好是只锁定需要的资源，即只锁定受影响的那些行。但是，<strong>锁定需要占用内存资源和内部的管理开销</strong>，所以 SQL Server在选择锁定哪种类型的资源时会<strong>同时考虑并发性</strong>和<strong>系统资源</strong>。</p>
<p>SQL Server可以会<strong>先获得细粒度的锁</strong>(例如，行或页)，<strong>在某些情况下再尝试将细粒度的锁升级</strong>为更粗粒度的锁(例如，表)。例如，当单个语句获得至少5,000个锁时，就会触发锁升级；如果由于锁冲突而导致无法升级锁，则 SQL Server每当获取1,250个新锁时便会触发锁升级。</p>
<p>在 SQL Server 2008之前，不能显式地禁止锁升级，所以在表上总是会进行锁升级。在SQL Server 2008中，<strong>可以用ALTER TABLE语句为表设置一个<code>LOCK_ESCALATION</code>选项</strong>，以<strong>控制锁升级的处理方式</strong>。如果愿意，你可以禁止锁升级，或自己决定**锁升级是在表上进行（默认）**还是在分区(partition)上进行。<strong>表在物理上可以划分成多个更小的单元，即分区</strong>。</p>
<hr>
<h4 id="检测阻塞"><a href="#检测阻塞" class="headerlink" title="检测阻塞"></a>检测阻塞</h4><p>如果一个事务持有某一数据资源上的锁，而<strong>另一事务请求相同资源上的不兼容的锁，则对新锁的请求将被阻塞，发出请求的事务进入等待状态</strong>。<strong>在默认情况下，被阻塞的请求会一直等待，直到原来的事务释放相关的锁</strong>。本章后面会介绍如何<strong>在会话中定义一个锁定超时期限</strong>，这样就可以<strong>限制被阻塞的请求在超时之前要等待的时间</strong>。</p>
<p>只要能够在合理的时间范围内满足请求，系统中的阻塞就是正常的。但是，<strong>如果一些请求等待了太长的时间，可能就需要手工排除阻塞状态，看看能采取什么措施来防止这样长时间的延迟</strong>。例如，事务的运行时间过长，会导致持有锁的时间也过久：这时<strong>可以尝试缩短事务处理，把不属于工作单元的操作移到事务外面</strong>。在某些情况下，应用程序中的bug也可能导致事务一直打开；这时可以先把这样的bug找出来，修复它，确保在所有情况下都可以关闭事务。</p>
<p>本节<strong>以一个阻塞情况为例，一步一步地教你如何排除这种阻塞</strong>。先在SSMS中<strong>打开3个单独的查询窗口</strong>（在本例中分别称这3个窗口为Connection 1、Connection 2 和 Connection 3)。确保把它们全都连接到TSQLFundamentals2008样例数据库。</p>
<p>在Connection 1中运行以下代码，对Production.Products表的一行进行更新，为产品2的当前单价19.00增加1.00：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">BEGIN</span> <span class="token keyword">TRAN</span><span class="token punctuation">;</span>
	<span class="token keyword">UPDATE</span> Production<span class="token punctuation">.</span>Products
	<span class="token keyword">SET</span> unitPrice <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1.00</span>
	<span class="token keyword">WHERE</span> productId <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>为了<strong>更新</strong>这一行，会话必须<strong>先获得一个排他锁</strong>，如果更新成功，SQL Server会向会话授予这个锁。回顾前面介绍的内容，<strong>事务会一直持有排他锁，直到事务完成；因为这个例子中的事务一直保持打开，所以它会一直持有排他锁</strong>。</p>
<p>在Connection 2中运行以下代码，试着查询同一行：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> productId<span class="token punctuation">,</span> unitPrice
<span class="token keyword">FROM</span> Production<span class="token punctuation">.</span>Products
<span class="token keyword">WHERE</span> productId <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>在默认情况下，为了读取数据，这个会话需要一个共享锁，但是因为<strong>这一行已经被其他会话持有的排他锁锁定</strong>，而且<strong>共享锁和排他锁不兼容</strong>，所以<strong>第二个会话被阻塞，进入等待状态</strong>。</p>
<p>假设系统中发生了这样的阻塞情况，而且被阻塞的对话最终等待了很长时间，你可能会想排除这种阻塞状况。在此，提供一些<strong>对动态管理对象（包括视图和函数）的查询</strong>，当排除阻塞时，可以在Connection 3中运行这些查询。</p>
<p>要得到<strong>有关锁的信息</strong>（包括<strong>已经授予的锁</strong>和<strong>当前会话正等待授予的锁</strong>），可以在Connection 3中查询<strong>动态管理视图</strong>(<strong>DMV</strong>, dynamic management view)<code>sys.dm_tran_locks</code>：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> request_session_id <span class="token keyword">AS</span> SPID<span class="token punctuation">,</span>
	resource_type <span class="token keyword">AS</span> resType<span class="token punctuation">,</span>
	resource_database_id <span class="token keyword">AS</span> dbId<span class="token punctuation">,</span>
	DB_NAME<span class="token punctuation">(</span>resource_database_id<span class="token punctuation">)</span> <span class="token keyword">AS</span> dbName<span class="token punctuation">,</span>
	resource_description <span class="token keyword">AS</span> res<span class="token punctuation">,</span>
	resource_associated_entity_id <span class="token keyword">AS</span> resId<span class="token punctuation">,</span>
	request_mode <span class="token keyword">AS</span> <span class="token keyword">mode</span><span class="token punctuation">,</span>
	request_status <span class="token keyword">AS</span> <span class="token keyword">status</span>
<span class="token keyword">FROM</span> sys<span class="token punctuation">.</span>dm_tran_locks<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当我运行这段代码（没有打开其他查询窗口）时，得到以下输出：</p>
<p><img src="https://i.loli.net/2021/07/14/uAw5akeYKpJcbZ3.png"></p>
<p><strong>每个会话</strong>都由唯一的<strong>服务器进程标识符</strong>(<strong>SPID</strong>, server process ID)进行标识，可以通过查询<code>@@SPID</code>函数来查看会话的SPID。如果你正在使用SSMS，<strong>在屏幕底部的状态栏中显示了当前登陆的用户名，在用户名右边的圆括号内显示的就是当前会话的SPID，在已经连接到数据库的查询窗口的标题条中也能够找到SPID</strong>。</p>
<p>从对<code>sys.dm_tran_lock</code>进行查询的输出中可以看到，3个会话(61, 62, 63)目前都持有锁，具体包括以下信息：</p>
<ul>
<li>resType：被锁定资源的类型(例如，取值之一的KEY代表索引中的行锁)</li>
<li>dbId &amp; dbName：被锁定资源所位于的数据库的ID,可以用<code>DB_NAME</code>函数把这个ID转换成相应的数据库名称</li>
<li>res &amp; resId：资源说明和与资源相关联的实体ID</li>
<li>mode：锁模式</li>
<li>status：已经授予了锁，还是会话正在请求授予锁</li>
</ul>
<p>注意，以上只是该视图属性的一部分：建议査阅这个视图的其他属性，看看还能得到什么其他有关锁的信息。</p>
<p>在前面查询的输出中，可以观察到进程62正在等待请求TSQLFundamentals2008示例数据库中一个<strong>行上的共享锁</strong>(用DB_NAME函数获得数据库名称)。注意，进程61<strong>持有同行上的一个排他锁</strong>。如果你能观察到<strong>这两个进程锁定的行具有相同的res和resid值</strong>，就能意识到这一事实。沿着进程61或62的锁层次结构<strong>向上检查</strong>在包含那一行的页或对象（表）上的<strong>意向锁</strong>，<strong>便可以搞明白锁定所涉及到的表</strong>。用<code>OBJECT_NAME</code>函数能够把对象锁的resId属性列中出现的对象ID(此例中为709577566)转换为对象名称。你会发现锁定涉及到的表是Production.Product。</p>
<p><code>sys.dm_tran_locks</code>视图<strong>只提供当前阻塞链中涉及到的进程的ID信息</strong>，除此之外没有其他关于进程的信息。为了获得<strong>与阻塞链中涉及到的进程相关联的连接</strong>的信息，可以查询一个名为<code>sys.dm_exec_connections</code>的动态管理视图，只筛选阻塞链中涉及到的那些SPlD：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> session_id <span class="token keyword">AS</span> SPID<span class="token punctuation">,</span>
	connect_time<span class="token punctuation">,</span>
	last_read<span class="token punctuation">,</span>
	last_write<span class="token punctuation">,</span>
	most_recent_sql_handle
<span class="token keyword">FROM</span> sys<span class="token punctuation">.</span>dm_exec_connections
<span class="token keyword">WHERE</span> session_id <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">61</span><span class="token punctuation">,</span> <span class="token number">62</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意，这里指定的进程ID是我的系统中阻塞链涉及的进程D(61和62)。当你在系统中运行这里演示的查询时，要确保把进程ID替换成在你的系统阻塞链中找到的进程ID。</p>
<p>这个查询将返回以下输出结果：</p>
<p><img src="https://i.loli.net/2021/07/14/hLouyOWsT9JCwFb.png"></p>
<p>这个査询给出的<strong>关于连接的信息</strong>包括以下内容：</p>
<ul>
<li><p>connect_time：连接建立的时间</p>
</li>
<li><p>last_read &amp; last_write：连接中最后一次发生读操作和写操作的时间</p>
</li>
<li><p>most_recent_sql_handle：一个<strong>二进制值标记(handle)</strong>，用于<strong>代表此连接上执行的最后一个SQL批处理</strong></p>
<p>  <strong>可以把这个标记值作为输入参数提供给表函数<code>sys.dm_exec_sql_text</code>，由这个函数返回该标记值代表的SQL代码</strong>。</p>
</li>
</ul>
<p>査询表函数时可以显式地传递二进制标记值，但方便的方法可能是使用第5章”表表达式”中介绍的<strong>APPLY表运算符</strong>，<strong>为每个连接行应用这个表函数</strong>，如下所示(在Connection 3中运行)：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> session_id<span class="token punctuation">,</span> <span class="token keyword">text</span>
<span class="token keyword">FROM</span> sys<span class="token punctuation">.</span>dm_exec_connections
	<span class="token keyword">CROSS</span> <span class="token keyword">APPLY</span> sys<span class="token punctuation">.</span>dm_exec_sql_text<span class="token punctuation">(</span>most_recent_sql_handle<span class="token punctuation">)</span> <span class="token keyword">AS</span> ST
<span class="token keyword">WHERE</span> session_id <span class="token operator">IN</span><span class="token punctuation">(</span><span class="token number">61</span><span class="token punctuation">,</span> <span class="token number">62</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行以上査询，就可以在得到的输出中<strong>显示阻塞链涉及的每个连接最后调用的批处理代码</strong>：</p>
<p><img src="https://i.loli.net/2021/07/14/aQztTeVF57xOwhB.png"></p>
<p>以上显示了<strong>被阻塞进程(进程62)正在等待执行的代码</strong>，<strong>因为这是该进程最后执行的一个操作</strong>。<strong>对于阻塞进程来说，通过这个例子能够看到是哪条语句导致了问题，但要记住：阻塞进程可能在不断地运行，所以在代码中看到的最后一个操作不一定就是导致问题的语句</strong>。</p>
<p>对于<strong>阻塞状态中涉及到的会话</strong>，用动态管理视图<code>sys.dm_exec_sessions</code>也能找到很多有用的信息。以下査询返回的只是有关会话的可用属性中的一小部分：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> session_id <span class="token keyword">AS</span> SPID<span class="token punctuation">,</span>
	login_time<span class="token punctuation">,</span>
	host_name<span class="token punctuation">,</span>
	program_name<span class="token punctuation">,</span>
	login_name<span class="token punctuation">,</span>
	nt_user_name<span class="token punctuation">,</span>
	last_request_start_time<span class="token punctuation">,</span>
	last_request_end_time
<span class="token keyword">FROM</span> sys<span class="token punctuation">.</span>dm_exec_sessions
<span class="token keyword">WHERE</span> session_id <span class="token operator">IN</span><span class="token punctuation">(</span><span class="token number">61</span><span class="token punctuation">,</span> <span class="token number">62</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>本例中的这个查询将返回以下输出：</p>
<p><img src="https://i.loli.net/2021/07/14/iroOQFkPlg6WZM8.png"></p>
<p>这段输出提供的信息包含建立会话的时间(login_time)、特定于会话的客户端工作站名称(host name)、初始化会话的客户端程序的名称(program_name)、会话所使用的SQL Server登录名(login_name)、客户端的Windows用户名(nt_user_name)、最近一次会话请求的开始时间(last_request_start_time)、最近一次会话请求的完成时间(last_request_ end_time)。这些信息可以详细地告诉你会话正在做什么。</p>
<p>对于<strong>排除阻塞状态</strong>，另一个可能很有用的动态管理视图是<code>sys.dm_exec_requests</code>。<strong>这个视图的每一行代表一个活动的请求（包括被阻塞的请求）</strong>。实际上，可以容易地区分<strong>被阻塞请求</strong>，因为这些请求的<strong>blocking_session_id属性值大于0</strong>。例如，以下查询只筛选被阻塞的请求：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> session_id <span class="token keyword">AS</span> SPID<span class="token punctuation">,</span>
	blocking_session_id<span class="token punctuation">,</span>
	command<span class="token punctuation">,</span>
	sql_handle<span class="token punctuation">,</span>
	database_id<span class="token punctuation">,</span>
	wait_type<span class="token punctuation">,</span>
	wait_time<span class="token punctuation">,</span>
	wait_resource
<span class="token keyword">FROM</span> sys<span class="token punctuation">.</span>dm_exec_requests
<span class="token keyword">WHERE</span> blocking_session_id <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个查询将返回以下输出：</p>
<p><img src="https://i.loli.net/2021/07/14/4FTvUYAmRIZbfDB.png"></p>
<p>从这些信息中可以容易地识别出阻塞链<strong>涉及到的会话、争用的资源、被阻塞会话等待了多长时间（以毫秒为单位）等信息</strong>。</p>
<p>如果需要<strong>终止导致阻塞的进程</strong>（例如，当你发现事务一直保持打开是由于程序中的bug造成的，而且程序中没有关闭事务的处理），可以使用**<code>KILL &lt;spid&gt;</code>命令**（现在先不要这样做）。</p>
<p>前面提到，<strong>在默认情况下会话不会设置锁定的超时期限</strong>。如果想<strong>限制会话等待锁释放的时间，则可以设置<code>LOCK_TIMEOUT</code>选项</strong>。该选项<strong>以毫秒为单位</strong>，即5000表示5秒，<strong>0表示立刻超时，-1（默认值）表示无限期等待</strong>，以此类推。为了演示这个选项，先终止Connection 2中进行的査询。然后运行以下代码，将会话的超时期限设置为5秒，再重新运行原来的查询：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SET LOCK_TIMEOUT 5000;

SELECT productId, unitPrice
FROM Production.Products
WHERE productId &#x3D; 2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>因为Connection 1还没有完成更新的事务，所以这时Connection 2中的查询仍然将被阻塞，但如果超过5秒钟以后，锁定请求还不能被满足，SQL Server就会终止查询，返回以下错误消息：</p>
<blockquote>
<p>消息 1222，级别 16，状态 51，第 4 行</p>
<p>已超过了锁请求超时时段。</p>
</blockquote>
<p>注意<strong>锁定超时不会引发事务回滚</strong>。</p>
<p>为了取消锁定超时期限，将该选项设置回默认值（无限期等待），再次进行查询，在Connection 2中运行以下代码：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SET LOCK_TIMEOUT -1;

SELECT productId, unitPrice
FROM Production.Products
WHERE productId &#x3D; 2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>为了演示终止Connection 1中的更新事务而产生的效果，在Connection 3中运行以下代码：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">KILL 61;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<p>这个语句会<strong>引起Connection 1中事务的回滚（这意味着将会撤消产品单价从19.00到20.00的更新操作），同时释放排他锁</strong>。再回到Connection 2，这时<strong>查询将得到取消单价变化后的结果</strong>（即单价未改变时的值）。</p>
<hr>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>隔离级别用于<strong>决定如何控制并发用户读写数据的操作</strong>。<strong>读操作</strong>可以是任何检索数据的语句，<strong>默认使用共享锁</strong>。<strong>写操作</strong>是指任何对表做出修改的语句，<strong>需要使用排他锁</strong>。对于操作获得的锁，以及锁的持续时间来说，<strong>虽然不能控制写操作的处理方式，但可以控制读操作的处理方式</strong>。当然，作为对读操作的行为进行控制的一种结果，也将隐含地影响写操作的行为方式。为此，<strong>可以在会话级别上用会话选项来设置隔离级别</strong>，也可以<strong>在查询级别上用表提示(table hint)来设置隔离级别</strong>。</p>
<p>可以设置的隔离级别有6个：READ UNCOMMITTED（未提交读）、READ COMMITTED（已提交读）（<strong>默认值</strong>）、REPEATABLE READ（可重复读）、SERIALIZABLE(可序列化）、SNAPSHOT（快照）和READ COMMITTED SNAPSHOT(已经提交读隔离）。最后两个级别是在 SQL Server2005中引入的。要<strong>设置整个会话的隔离级别</strong>，可以使用以下命令：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SET</span> <span class="token keyword">TRANSACTION</span> <span class="token keyword">ISOLATION</span> <span class="token keyword">LEVEL</span> <span class="token operator">&lt;</span><span class="token keyword">isolation</span> Name<span class="token operator">></span><span class="token punctuation">;</span>

<span class="token comment">-- 也可以使用【表提示】来设置查询的隔离级别：</span>
<span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">FROM</span> <span class="token operator">&lt;</span><span class="token keyword">table</span><span class="token operator">></span> <span class="token keyword">WITH</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>isolationName<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意，使用<strong>会话选项</strong>时，如果隔离级别的名称是由多个单词组成的，则<strong>需要在各单词之间指定一个空格</strong>，例如REPEATABLE READ。而<strong>使用查询提示</strong>时，则<strong>不必在各单词之间指定任何空格</strong>，例如WITH (REPEATABLEREAD)。此外，一些作为表提示用的隔离级别名称也有同义词，例如， NOLOCK相当于指定 READUNCOMMITTED，HOLDLOCK相当于指定REPEATABLEREAD。</p>
<p><strong>默认的隔离级别是READ COMMITTED</strong>。如果你选择改变这个默认的隔离级别，那么选择的结果对数据库用户的并发性和他们获取数据的一致性都会产生影响。对于SQL Server2005之前可用的四个隔离级别，<strong>隔离级别越高，读操作请求的锁定就越严格，锁持有的时间也更长；因此，隔离级别越高，一致性也就越高，并发性就越低</strong>。当然，反过来也一样。对于其他两个<strong>基于快照的隔离级别</strong>，SQL Server能够<strong>把以前提交过的行保存到tempdb数据库中</strong>。当读操作发现行的当前版本和它们预期的不一致时，<strong>可以立即得</strong><br><strong>到行的以前版本</strong>，从而不用请求共享锁也能取得预期的一致性。<br>下面各小节将分别介绍 SQL Server支持的6个隔离级别，演示它们的行为方式。</p>
<hr>
<h4 id="READ-UNCOMMITTED-未提交读"><a href="#READ-UNCOMMITTED-未提交读" class="headerlink" title="READ UNCOMMITTED 未提交读"></a>READ UNCOMMITTED 未提交读</h4><p>READ UNCOMMITTED是<strong>最低级的隔离级别</strong>。在这个隔离级别运行的事务，读操作<strong>不会请求共享锁</strong>。如果读操作不请求共享锁，就绝对不会和持有排他锁的写操作发生冲突。<strong>这意味着读操作可以读取未提交的修改</strong>（也称为<strong>脏读</strong>）。同时也意味着读操作不会妨碍写操作请求排他锁。也就是说，当运行在READ UNCOMMITTED隔离级别下的读操作正在读取数据时，<strong>写操作可以同时对这些数据进行修改</strong>。</p>
<p>为了演示什么是未提交读(脏读，dirty read),打开两个査询窗口（将这两个窗口分别称为Connection 1和Connection 2)。确保两个窗口都连接到样例数据库TSQLFundamentals2008。</p>
<p>在Connection 1中运行以下代码，打开一个事务，更新产品2的单价，为其当前值(19.00)增加1.00,然后查询该产品：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">BEGIN</span> <span class="token keyword">TRAN</span><span class="token punctuation">;</span>
	
	<span class="token keyword">UPDATE</span> Production<span class="token punctuation">.</span>Products
		<span class="token keyword">SET</span> unitPrice <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1.00</span>
    <span class="token keyword">WHERE</span> productId <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    
    <span class="token keyword">SELECT</span> productId<span class="token punctuation">,</span> unitPrice
    <span class="token keyword">FROM</span> Production<span class="token punctuation">.</span>Products
    <span class="token keyword">WHERE</span> productid <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>注意，以上代码中的<strong>事务保持打开</strong>，这意味着<strong>产品2所在的行将一直被Connection 1持有的排他锁锁定</strong>。 </p>
<p>在Connection 2中，运行以下代码，<strong>将会话的隔离级别设置为READ UNCOMMITTED</strong>，再查询产品2所在的行：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SET</span> <span class="token keyword">TRANSACTION</span> <span class="token keyword">ISOLATION</span> <span class="token keyword">LEVEL</span> <span class="token keyword">READ</span> <span class="token keyword">UNCOMMITTED</span><span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> productId<span class="token punctuation">,</span> unitPrice
<span class="token keyword">FROM</span> Production<span class="token punctuation">.</span>Products
<span class="token keyword">WHERE</span> productId <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>因为这个读操作<strong>不用请求共享锁，所以它不会和其他事务发生冲突</strong>。<strong>该査询返回产品2所在行修改后的状态，即使这一修改还没有被提交</strong>。</p>
<p>Connection 1在事务中可能会对行再进行更多的修改，或者在某一点上回滚事务。例如，在 onnection1中运行以下代码以回滚事务：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ROLLBACK</span> <span class="token keyword">TRAN</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<p>这个回滚操作会撤消对产品2的更新，把它的价格修改回19.00，<strong>读操作此前获得的20.00再也不会被提交了。这就是脏读的一个例子</strong>。</p>
<hr>
<h4 id="READ-COMMITTED-已提交读"><a href="#READ-COMMITTED-已提交读" class="headerlink" title="READ COMMITTED 已提交读"></a>READ COMMITTED 已提交读</h4><p>如果想避免读取未提交的修改，则需要使用要求更严格的隔离级别。<strong>能够防止脏读的最低隔离级别是READ COMMIITTED</strong>，这也是所有版本的 SQL Server<strong>默认使用的隔离级别</strong>。如其名称所示，这个隔离级别只允许读取已经提交过的修改。<strong>它要求读操作必须获得共享锁才能进行操作，从而防止读取未提交的修改</strong>。这意味着，如果写操作持有排他锁，读操作提出的共享锁请求就会和写操作发生冲突，所以读操作不得不等待。一旦写操作提交了事务，读操作就能获得它请求的共享锁，而这时再读取到的只能是修改提交过的数据。</p>
<p>下面这个例子演示在READ COMMITTED隔离级别下，读操作只能读取修改提交过的数据。</p>
<p>在 Connection1中运行以下代码，打开事务，更新产品2的价格，再査询该行以显示新价格：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">BEGIN</span> <span class="token keyword">TRAN</span><span class="token punctuation">;</span>
	<span class="token keyword">UPDATE</span> Production<span class="token punctuation">.</span>Products
		<span class="token keyword">SET</span> unitPrice <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1.00</span>
	<span class="token keyword">WHERE</span> productId <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	
	<span class="token keyword">SELECT</span> productId<span class="token punctuation">,</span> unitPrice
	<span class="token keyword">FROM</span> Production<span class="token punctuation">.</span>Products
	<span class="token keyword">WHERE</span> productId <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Connection 1现在<strong>以排他锁锁定了产品2的数据行</strong>。</p>
<p>在Connection 2中运行以下代码，将会话的隔离级别设置为READ COMMITTED，再查询产品2所在的行：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SET</span> <span class="token keyword">TRANSACTION</span> <span class="token keyword">ISOLATION</span> <span class="token keyword">LEVEL</span> <span class="token keyword">READ</span> <span class="token keyword">COMMITTED</span><span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> productId<span class="token punctuation">,</span> unitPrice
<span class="token keyword">FROM</span> Production<span class="token punctuation">.</span>Products
<span class="token keyword">WHERE</span> productId <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>READ COMMITTED是SQL Server默认的隔离级别，所以<strong>除非以前修改过会话的隔离级别，否则不需要显式地设置该隔离级别</strong>。执行该査询时，<strong>SELECT语句会被阻塞，因为这时它需要获取共享锁才能够进行读操作，而该共享锁请求与Connection 1中写操作持有的排他锁相冲突</strong>。</p>
<p>接下来，在 Connection1中运行以下代码，提交事务：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">COMMIT TRAN;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>与 READ UNCOMMITTED不同，<strong>在READ COMMITTED隔离级别下，不会读取脏数据</strong>，相反，<strong>只能读取已经提交过的修改</strong>。</p>
<p>按照<strong>锁的持有时间</strong>来说，在READ COMMITTED隔离级别中，<strong>读操作一完成，就立即释放资源上的共享锁</strong>。<strong>读操作不会在事务持续期间内保留共享锁</strong>；实际上，<strong>甚至在语句结束前也不能一直保留共享锁</strong>。<strong>这意味着在一个事务处理内部对相同数据资源的两个读操作之间，没有共享锁会锁定该资源</strong>。因此，其他事务可以在两个读操作之间更改数据资源，<strong>读操作因而可能每次得到不同的取值</strong>。这种现象称为<strong>不可重复读(non-repeatable read)或不一致的分析(inconsistent analysis)</strong>。<strong>在许多应用程序中，这种现象是可以接受的，但是也有些程序不允许这种现象发生</strong>。</p>
<p>操作完成后，在每个打开的连接中运行以下代码以清理测试数据：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> Production<span class="token punctuation">.</span>Products
	<span class="token keyword">SET</span> unitPrice <span class="token operator">=</span> <span class="token number">19.00</span>
<span class="token keyword">WHERE</span> productId <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<hr>
<h4 id="REPEATABLE-READ-可重复读"><a href="#REPEATABLE-READ-可重复读" class="headerlink" title="REPEATABLE READ 可重复读"></a>REPEATABLE READ 可重复读</h4><p>如果想保证<strong>在事务内进行的两个读操作之间，其他任何事务都不能修改由当前事务读取的数据</strong>，则需要把隔离级别升级为REPEATABLE READ。<strong>在这种隔离级别下，事务中的读操作不但需要获得共享锁才能读取数据，而且获得的共享锁将一直保持到事务完成为止</strong>。这意味着一旦获得数据资源上的共享锁以读取数据，在事务完成之前，没有其他事务能够获得排他锁以修改这一数据资源。这样，就可以保证实现可重复的读取，或一致的分析。</p>
<p>下面这个例子演示了如何实现可重复读。在Connection 1中运行以下代码，将会话的隔离级别设置为REPEATABLE READ，打开事务，再査询产品2所在的行：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
BEGIN TRAN;
	SELECT productId, unitPrice
	FROM Production.Products
	WHERE productId &#x3D; 2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Connection 1这时仍然持有产品2上的共享锁，因为在REPEATABLE READ隔离级别下，共享锁一直要保持到事务完成为止。在Connection 2中运行以下代码，尝试对产品2这一行进行修改：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> Production<span class="token punctuation">.</span>Products
	<span class="token keyword">SET</span> unitPrice <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1.00</span>
<span class="token keyword">WHERE</span> productId <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>注意，SQL Server会阻塞这一修改尝试，因为修改操作请求的排他锁与前面读操作授予的共享锁冲突。如果读操作是在READ UNCOMMITTED或READ COMMITTED隔离级别下运行的，事务此时将不再持有共享锁，尝试修改该行的操作应该能成功。</p>
<p>回到Connection 1，运行以下代码，再次査询产品2所在的行，并提交事务：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT productId, unitPrice
FROM Production.Products
WHERE productid &#x3D; 2;

COMMIT TRAN;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意，第二次查询产品2的单价得到的结果与第一次相同。现在读操作的事务已经提交了，共享锁也释放了，所以 Connection 2中的修改操作就能获得它正等待的排他锁，对行进行更新。</p>
<p>REPEATABLE READ隔离级别<strong>能够防止的另一种并发负面影响是丢失更新(lost update)</strong>，而较低的隔离级别则不能防止这种问题。<strong>丢失更新是指当两个事务读取了同一个值，然后基于最初读取的值进行计算，接着再更新该值，就会发生丢失更新的问题</strong>。因为在比REPEATABLE READ更低的隔离级别中，读取完数据之后就不再持有资源上的任何锁，两个事务都能更新这个值，而最后进行更新的事务则是“赢家”，覆盖由其他事务所作的更新，这将导致数据丢失。<strong>在REPEATABLE READ隔离级别下，两个事务在第一次读操作之后都将保留它们获得的共享锁，所以任何一个事务都不能获得为了更新数据而需要的排他锁。这种情况最终会导致死锁(deadlock),不过却避免了更新冲突</strong>。本章后面会详细介绍死锁问题。</p>
<p>操作完成后，运行以下代码以清理测试数据</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> Production<span class="token punctuation">.</span>Products
	<span class="token keyword">SET</span> unitPrice <span class="token operator">=</span> <span class="token number">19.00</span>
<span class="token keyword">WHERE</span> productId <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<hr>
<h4 id="SERIALIZABLE-可序列化"><a href="#SERIALIZABLE-可序列化" class="headerlink" title="SERIALIZABLE 可序列化"></a>SERIALIZABLE 可序列化</h4><p>在REPEATABLE READ隔离级别下运行的事务，读操作获得的共享锁将一直保持到事务完成为止。因此可以保证在事务中第一次读取某些行后，还可以重复读取这些行。但是，<strong>事务只锁定査询第一次运行时找到的那些数据资源(例如，行)，而不会锁定查询结果范围以外的其他行</strong>。因此，在同一事务中<strong>进行第二次读取之前，如果其他事务插入了新行，而且新行也能满足读操作的查询过滤条件，那么这些新行也会出现在第二次读操作返回的结果中</strong>。这些新行称为幻影(phantom)，这种读操作也称为<strong>幻读(phantom read)</strong>。</p>
<p>为了<strong>避免幻读</strong>，需要将隔离级别设置为更高级的SERIALIZABLE。大多数时候，SERIALIZABLE隔离级别的处理方式和 REPEATABLE READ类似：即读操作需要获得共享锁才能读取数据，并保留共享锁直到事务完成。不过，SERIALIZABLE隔离级别增加了一个新内容一一逻辑上，这个隔离级别会<strong>让读操作锁定满足查询搜索条件的键的整个范围</strong>。这就意味着读操作不仅锁定了满足査询搜索条件的现有的那些行，还<strong>锁定了未来可能满足查询搜索条件的行</strong>。或者更准确地说，<strong>如果其他事务试图增加能够满足读操作的査询搜索条件的新行，当前事务就会阻塞这样的操作</strong>。</p>
<p>以下例子演示了如何用SERIALIZABLE隔离级别来避免幻读。在Connection 1中运行以下代码，将会话的事务隔离级别设置为SERIALIZABLE，打开事务，查询产品分类等于1的所有产品：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SET</span> <span class="token keyword">TRANSACTION</span> <span class="token keyword">ISOLATION</span> <span class="token keyword">LEVEL</span> <span class="token keyword">SERIALIZABLE</span><span class="token punctuation">;</span>

<span class="token keyword">BEGIN</span> <span class="token keyword">TRAN</span><span class="token punctuation">;</span>
	<span class="token keyword">SELECT</span> productId<span class="token punctuation">,</span> productName<span class="token punctuation">,</span> categoryId<span class="token punctuation">,</span> unitPrice
	<span class="token keyword">FROM</span> Production<span class="token punctuation">.</span>Products
	<span class="token keyword">WHERE</span> categoryId <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在Connection 2中，运行以下代码，尝试插入一个分类等于1的新产品：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> Production<span class="token punctuation">.</span>Products
	<span class="token punctuation">(</span>productName<span class="token punctuation">,</span> supplierId<span class="token punctuation">,</span> categoryId<span class="token punctuation">,</span>
     unitPrice<span class="token punctuation">,</span> discontinued<span class="token punctuation">)</span>
<span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">'Product ABCDE'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">20.00</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>在所有低于SERIALIZABLE的隔离级别下，这样的插入操作将会成功</strong>。<strong>而在SERIALIZABLE隔离级别下，这样的操作将被阻塞</strong>。</p>
<p>回到Connection 1，运行以下代码，再次查询分类1包括的产品，并提交事务：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> productId<span class="token punctuation">,</span> productName<span class="token punctuation">,</span> categoryId<span class="token punctuation">,</span> unitPrice
<span class="token keyword">FROM</span> Production<span class="token punctuation">.</span>Products
<span class="token keyword">WHERE</span> categoryId <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">COMMIT</span> <span class="token keyword">TRAN</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>得到的输出结果和前面的一样，没有幻影行。现在读操作的事务已经提交了，共享键的范围锁也随之释放，所以Connection 2中的修改操作就获得了等候已久的排他锁，插入新行。</p>
<p>操作完成后，运行以下代码以清理测试数据：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">DELETE FROM Production.Products
WHERE productId &gt; 77;

DBCC CHECKIDENT (&#39;Production.Products&#39;, RESEED, 77);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>在所有打开的连接中运行以下代码，将会话的隔离级别设置为默认值：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SET TRANSACTION ISOLATION LEVEL READ COMMITTED;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<hr>
<h4 id="SNAPSHOT-快照"><a href="#SNAPSHOT-快照" class="headerlink" title="SNAPSHOT 快照"></a>SNAPSHOT 快照</h4><p>可以把<strong>事务开始时，可用的上一个提交版本</strong>保存在tempdb数据库中，这是SQL Server 2005引入的一个新功能。以这种<strong>行版本控制技术</strong>为基础，SQL Server增加了两个新的隔离级别<strong>SNAPSHOT</strong>和<strong>READ COMMITTED SNAPSHOT</strong>。<strong>SNAPSHOT隔离级别</strong>在逻辑上和<strong>SERIALIZABLE隔离级别</strong>类似，它们能解决或不能解决的一致性问题都一样；<strong>READ COMMITTED SNAPSHOT隔离级别</strong>和<strong>READ COMMITTED隔离级别</strong>类似。不过，<strong>在基于快照的隔离级别下，读操作不需要使用共享锁</strong>，所以即使请求的数据被其他事务以排他锁锁定，读操作也不会等待，而且仍然可以得到和SERIALIZABLE和READ COMMITTED隔离级别类似的一致性。<strong>如果行的目前版本与预期的不同，读操作可以从tempdb的版本库中获得预期的版本</strong>。</p>
<p>注意，<strong>如果启用任何一种基于快照的隔离级别，DELETE和UPDATE语句在做出修改前会把行的当前版本复制到tempdb数据库中</strong>；<strong>INSERT语句不需要在tempdb中进行版本控制，因为这时还没有行的旧版本</strong>。但是也应该特别注意：<strong>无论使用哪种基于快照的隔离级别，都会对数据更新和删除操作的性能产生负面影响</strong>。不过，<strong>读操作的性能通常会有所提高，因为读操作不用先获得共享锁，当数据被其他事务的排他锁锁定或其版本不是预期的时候，也不需要等待</strong>。接下来的部分就详细介绍基于快照的隔离级别，演示它们的行为方式。</p>
<hr>
<h5 id="SNAPSHOT-隔离级别"><a href="#SNAPSHOT-隔离级别" class="headerlink" title="SNAPSHOT 隔离级别"></a>SNAPSHOT 隔离级别</h5><p>在SNAPSHOT隔离级别下，<strong>当读取数据时，可以保证读操作读取的行是事务开始时可用的最后提交的版本</strong>。这意味着<strong>这种隔离级别可以保证读取的是已经提交过的数据，而且可以实现可重复读，也能确保不会幻读</strong>(就像SERIALIZABLE隔离级别一样)。不过，<strong>这一隔离级别使用的不是共享锁，而是行版本控制</strong>。如前所述，不论修改操作（主要是更新和删除数据）是否在某种基于快照的隔离级别下的会话中执行，<strong>快照隔离级别都会带来性能上的开销</strong>。因此，<strong>为了启用SNAPSHOT隔离级别，需要先在数据库级上设置相关选项</strong>（<strong>如果不做该项设置，虽然能设置SNAPSHOT隔离级别，但之后的语句执行会报错</strong>）。在任意打开的查询窗口中运行以下代码：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 查询数据库系统中的【所有数据库的快照隔离状态】</span>
<span class="token keyword">SELECT</span> name<span class="token punctuation">,</span> user_access<span class="token punctuation">,</span> user_access_desc<span class="token punctuation">,</span> snapshot_isolation_state<span class="token punctuation">,</span>
	snapshot_isolation_state_desc<span class="token punctuation">,</span> is_read_committed_snapshot_on 
<span class="token keyword">FROM</span> sys<span class="token punctuation">.</span><span class="token keyword">databases</span><span class="token punctuation">;</span>

<span class="token comment">-- 设置【允许快照隔离】</span>
<span class="token keyword">ALTER</span> <span class="token keyword">DATABASE</span> TSQLFundamentals2008 
<span class="token keyword">SET</span> ALLOW_SNAPSHOT_ISOLATION <span class="token keyword">ON</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>下面的例子演示了SNAPSHOT隔离级别的行为方式。在 Connection 1中运行以下代码，打开事务，更新产品2的价格，把它的当前价格(19.00)增加1.00，然后再查询该产品，显示更新后的新价格：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">BEGIN</span> <span class="token keyword">TRAN</span><span class="token punctuation">;</span>
	<span class="token keyword">UPDATE</span> Production<span class="token punctuation">.</span>Products
		<span class="token keyword">SET</span> unitPrice <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1.00</span>
    <span class="token keyword">WHERE</span> productId <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    
    <span class="token keyword">SELECT</span> productId<span class="token punctuation">,</span> unitPrice
    <span class="token keyword">FROM</span> Production<span class="token punctuation">.</span>Products
    <span class="token keyword">WHERE</span> productId <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意，即使Connection 1中的事务<strong>在默认的READ COMMITTED隔离级别下运行，SQL Server也必须在更新之前把行的一个版本（副本）(价格为19.00)复制到tempdb数据库</strong>。这是因为<strong>SNAPSHOT隔离级别是在数据库级启用的，如果使用SNAPSHOT隔离级别启动事务，在更新之前就会请求行的版本</strong>。例如，在Connection 2中运行以下代码，将隔离级别设置为SNAPSHOT，打开一个事务，查询产品2所在的行：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SET</span> <span class="token keyword">TRANSACTION</span> <span class="token keyword">ISOLATION</span> <span class="token keyword">LEVEL</span> <span class="token keyword">SNAPSHOT</span><span class="token punctuation">;</span>

<span class="token keyword">BEGIN</span> <span class="token keyword">TRAN</span><span class="token punctuation">;</span>
	<span class="token keyword">SELECT</span> productId<span class="token punctuation">,</span> unitPrice
	<span class="token keyword">FROM</span> Production<span class="token punctuation">.</span>Products
	<span class="token keyword">WHERE</span> productId <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果这个事务是在SERIALIZABLE隔离级别下运行的，那么查询将被阻塞。但因为现在是在NAPSHOT下运行的，<strong>能够得到行数据在事务启动时可用的最后提交的版本</strong>。这个版本(产品价格为19.00)不是当前的版本(价格为20.00)，SQL Server会从保存的行版本中得到合适的版本。<br>回到Connection 1,提交修改这一行的事务：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">COMMIT</span> <span class="token keyword">TRAN</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>此时，产品2所在行的价格为20.00，<strong>这个版本现在是已经提交的版本</strong>。但是，<strong>如果在Connection 2中再次读取数据，得到的将仍然是事务开始时可用的上一次提交的版本（价格为19.00)</strong>。在Connection 2中运行以下代码，再次读取数据，然后提交该事务：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">	<span class="token keyword">SELECT</span> productId<span class="token punctuation">,</span> unitPrice
	<span class="token keyword">FROM</span> Production<span class="token punctuation">.</span>Products
	<span class="token keyword">WHERE</span> productid <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	
<span class="token keyword">COMMIT</span> <span class="token keyword">TRAN</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>会得到价格还是19.00的输出（之前开启的事务在这次查完价格后才结束）。</p>
<p>继续在 Connection 2中运行以下代码，<strong>打开一个新的事务</strong>，査询数据，最后提交该事务：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">BEGIN</span> <span class="token keyword">TRAN</span><span class="token punctuation">;</span>
	<span class="token keyword">SELECT</span> productId<span class="token punctuation">,</span> unitPrice
	<span class="token keyword">FROM</span> Production<span class="token punctuation">.</span>Products
	<span class="token keyword">WHERE</span> productId <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">COMMIT</span> <span class="token keyword">TRAN</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这次，<strong>当事务开始时可用的上一次提交的版本是价格为20.00的版本</strong>。</p>
<p><strong>快照清理线程每隔1分钟会运行一次</strong>，现在由于没有事务需要价格为19.00的那个行版本了，所以清理线程下一次运行时会把这个行版本从 tempdb中删除掉。</p>
<p>操作完成后，运行以下代码以清理测试数据：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> Production<span class="token punctuation">.</span>Products
	<span class="token keyword">SET</span> unitPrice <span class="token operator">=</span> <span class="token number">19.00</span>
<span class="token keyword">WHERE</span> productId <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<hr>
<h5 id="冲突检测"><a href="#冲突检测" class="headerlink" title="冲突检测"></a>冲突检测</h5><p><strong>REPEATABLE READ和SERIALIZABLE隔离级别通过产生死锁状态而避免更新冲突</strong>，SNAPSHOT隔离级别也能够避免更新冲突，但与前面两种隔离级别不同，<strong>当检测到更新冲突时，SNAPSHOT隔离级别下的快照事务将因失败而终止</strong>。SNAPSHOT隔离级别<strong>通过检査保存的行版本，就能够检测出更新冲突</strong>。<strong>它能判断出在快照事务的一次读操作和一次写操作之间是否有其他事务修改过数据</strong>。</p>
<p>下面先演示一个没有发生更新冲突的例子，再演示一个发生了更新冲突的例子。在Connection 1中运行以下代码，将事务的隔离级别设置为SNAPSHOT，打开一个事务，读取产品2所在的行：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SET</span> <span class="token keyword">TRANSACTION</span> <span class="token keyword">ISOLATION</span> <span class="token keyword">LEVEL</span> <span class="token keyword">SNAPSHOT</span><span class="token punctuation">;</span>

<span class="token keyword">BEGIN</span> <span class="token keyword">TRAN</span><span class="token punctuation">;</span>
	<span class="token keyword">SELECT</span> productId<span class="token punctuation">,</span> unitPrice
	<span class="token keyword">FROM</span> Production<span class="token punctuation">.</span>Products
	<span class="token keyword">WHERE</span> productId <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>假设在读取到的数据的基础上进行了一些计算之后，仍然在Connection 1中运行以下代码，把先前查询到的产品的价格修改为20.00，再提交事务：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">    <span class="token keyword">UPDATE</span> Production<span class="token punctuation">.</span>Products
    <span class="token keyword">SET</span> unitPrice <span class="token operator">=</span> <span class="token number">20.00</span>
    <span class="token keyword">WHERE</span> productId <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

<span class="token keyword">COMMIT</span> <span class="token keyword">TRAN</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>在快照事务进行读取、计算、修改操作期间没有其他事务对行进行过修改：因此，没有发生更新冲突， SQL Server将允许更新操作执行</strong>。</p>
<p>运行以下代码，把产品2的价格修改回19.00：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> Production<span class="token punctuation">.</span>Products
	<span class="token keyword">SET</span> unitPrice <span class="token operator">=</span> <span class="token number">19.00</span>
<span class="token keyword">WHERE</span> productId <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>接下来，在Connection 1中再次运行以下代码，打开一个事务，读取产品2所在的行：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">BEGIN</span> <span class="token keyword">TRAN</span><span class="token punctuation">;</span>
	<span class="token keyword">SELECT</span> productId<span class="token punctuation">,</span> unitPrice
	<span class="token keyword">FROM</span> Production<span class="token punctuation">.</span>Products
	<span class="token keyword">WHERE</span> productId <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>显示产品2的当前价格是19.00。</p>
<p>这时，在Connection 2中运行以下代码，将产品2的价格修改为25.00：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> Production<span class="token punctuation">.</span>Products
<span class="token keyword">SET</span> unitPrice <span class="token operator">=</span> <span class="token number">25.00</span>
<span class="token keyword">WHERE</span> productId <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>假设根据刚才读取的价格(19.00)进行了一些计算之后，想在Connection 1中把产品的价格修改为20.00：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> Production<span class="token punctuation">.</span>Products
<span class="token keyword">SET</span> unitPrice <span class="token operator">=</span> <span class="token number">20.00</span>
<span class="token keyword">WHERE</span> productId <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>这次SQL Server<strong>检测到在读取和写入操作之间有另一个事务修改了数据</strong>；因此<strong>SQL Server让当前事务因失败而终止</strong>。当然，当检测到更新冲突时，可以使用<strong>错误处理代码</strong>尝试再次执行整个事务。</p>
<p>操作完成后，运行以下代码以清理测试数据：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> Production<span class="token punctuation">.</span>Products
<span class="token keyword">SET</span> unitPrice <span class="token operator">=</span> <span class="token number">19.00</span>
<span class="token keyword">WHERE</span> productId <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>最后关闭所有数据库上的连接。注意，如果没有关闭所有连接，可能导致例子的运行结果与本章所述的内容不一致。</strong></p>
<hr>
<h5 id="READ-COMMITTED-SNAPSHOT-隔离级别"><a href="#READ-COMMITTED-SNAPSHOT-隔离级别" class="headerlink" title="READ COMMITTED SNAPSHOT 隔离级别"></a>READ COMMITTED SNAPSHOT 隔离级别</h5><p>READ COMMITTED SNAPSHOT隔离级别也是<strong>基于行版本控制</strong>，但<strong>与SNAPSHOT隔离级别有所不同</strong>：在READ COMMITTED SNAPSHOT隔离级别下，读操作读取的数据行不是<strong>事务启动前最后提交的版本</strong>，而是<strong>语句启动前最后提交的版本</strong>。此外，READ COMMTTTED SNAPSHOT隔离级别<strong>不进行更新冲突检测</strong>。这样一来，<strong>READ COMMITTED SNAPSHOT的逻辑行为就与READ COMMITTED隔离级别非常类似，只不过读操作不用获得共享锁，当请求的资源被其他事务的排他锁锁定时，也不用等待</strong>。</p>
<p>要在数据库中启用READ COMMITTED SNAPSHOT隔离级别，需要打开一个和启用SNAPSHOT隔离级别不同的数据库选项。运行以下代码，以便在TSQLFundamentals2008数据库中启用READ COMMITTED SNAPSHOT隔离级别：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">ALTER DATABASE TSQLFundamentals2008 
SET READ_COMMITTED_SNAPSHOT ON;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>


<p>注意，<strong>要成功运行这一代码，当前连接必须是到TSQLFundamentals2008数据库的唯一连接</strong>。</p>
<p>激活这个数据库选项时有趣的一点是，<strong>与SNAPSHOT隔离级别不同，这个选项其实是把默认的READ COMMITTED隔离级别的含意变成了READ COMMITTED SNAPSHOT</strong>。这意味着<strong>当打开这个数据库选项时，除非显式地修改会话的隔离级别，否则READ COMMITTED SNAPSHOT将成为默认的隔离级别</strong>。</p>
<p>下面演示READ COMMITTED SNAPSHOT隔离级别的用法，先打开两个连接。</p>
<p>在Connection 1中运行以下代码，打开一个事务，更新产品2所在的行，再读取这一行，并一直保持事务打开：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> TSQLFundamentals2008<span class="token punctuation">;</span>

<span class="token keyword">BEGIN</span> <span class="token keyword">TRAN</span><span class="token punctuation">;</span>
	<span class="token keyword">UPDATE</span> Production<span class="token punctuation">.</span>Products
<span class="token keyword">SET</span> unitPrice <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1.00</span>
<span class="token keyword">WHERE</span> productid <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> productId<span class="token punctuation">,</span> unitPrice
<span class="token keyword">FROM</span> Production<span class="token punctuation">.</span>Products
<span class="token keyword">WHERE</span> productId <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>产品的价格已经变成了20.00。</p>
<p>在 Connection 2中，打开事务，读取产品2所在的行，并一直保持事务打开：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">BEGIN</span> <span class="token keyword">TRAN</span><span class="token punctuation">;</span>
	<span class="token keyword">SELECT</span> productId<span class="token punctuation">,</span> unitPrice
	<span class="token keyword">FROM</span> Production<span class="token punctuation">.</span>Products
	<span class="token keyword">WHERE</span> productId <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>得到的是语句启动之前最后提交的行版本(价格为19.00)。</p>
<p>在Connection 1中运行以下代码，提交事务：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">COMMIT</span> <span class="token keyword">TRAN</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这时在Connection 2中再运行以下代码，再次读取产品2所在的行，并提交事务：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">    <span class="token keyword">SELECT</span> productId<span class="token punctuation">,</span> unitPrice
    <span class="token keyword">FROM</span> Production<span class="token punctuation">.</span>Products
    <span class="token keyword">WHERE</span> productId <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">COMMIT</span> <span class="token keyword">TRAN</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>


<p>如果这段代码是在SNAPSHOT隔离级别下运行的，得到的价格将会是19.00；但是，因为现在代码是在READ COMMITTED SNAPSHOT隔离级别下(是连接该数据库的<strong>所有会话</strong>的隔离级别)运行，得到的是语句启动前最后提交的版本(价格为20.00)，而不是事务启动之前的版本(价格为19.00)。</p>
<p>回想一下，<strong>这种现象称为不可重复读或者不一致的分析</strong>。<br>操作完成后，运行以下代码以清理测试数据：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> Production<span class="token punctuation">.</span>Products
<span class="token keyword">SET</span> unitPrice <span class="token operator">=</span> <span class="token number">19.00</span>
<span class="token keyword">WHERE</span> productId <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>关闭所有连接，然后在一个新的连接中运行以下代码，以禁用TSQLFundamentals2008数据库中基于快照的隔离级别：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">ALTER DATABASE TSQLFundamentals2008 SET ALLOW_SNAPSHOT_ISOLATION OFF;
ALTER DATABASE TSQLFundamentals2008 SET READ_COMMITTED_SNAPSHOT OFF;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<hr>
<h4 id="隔离级别总结"><a href="#隔离级别总结" class="headerlink" title="隔离级别总结"></a>隔离级别总结</h4><p>下表总结了每种隔离级别能否解决各种逻辑一致性问题，以及隔离级别是否会检测更新冲突，是否使用了行版本控制。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>未提交读？</th>
<th>不可重复读？</th>
<th>丢失更新？</th>
<th>幻读？</th>
<th>检测更新冲突？</th>
<th>使用行版本控制？</th>
</tr>
</thead>
<tbody><tr>
<td>READ UNCOMMITED</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>READ COMMITTED</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>READ COMMITED SNAPSHOT</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>REPEATABLE READ</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>SNAPSHOT</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<hr>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁(deadlock)是指一种进程之间互相永久阻塞的状态，可能涉及两个或更多的进程。两个进程发生死锁的例子是，进程A阻塞了进程B，而进程B又阻塞了进程A。超过两个进程发生死锁的例子是，进程A阻塞了进程B，进程B阻塞了进程C，而进程C又阻塞了进程A。在任何一种情况下，<strong>SQL Server都可以检测到死锁，并选择终止其中一个事务以干预死锁状态。如果SQL Server不干预，死锁涉及到的进程将永远保持死锁状态。</strong></p>
<p>除非指定了其他方式，SQL Server会选择<strong>终止做过的操作最少的事务</strong>，因为这样<strong>可以让回滚开销降低到最少</strong>。不过，用户<strong>也可以自己指定死锁情况下会话的优先级</strong>。自从SQL Server 2005以后，可以将会话选项<code>DEADLOCK PRIORITY</code>设置为范围**(-10到10)之间的任一整数值**；而在SQL Server 2005之前的版本中，死锁优先级只有LOW和NORMAL两个可用的属性值。如果两个进程的死锁优先级不同，不管它们的回滚开销有多少，数据库引擎都会<strong>选择优先级较低的进程作为死锁牺牲品</strong>。<strong>如果两个进程的死锁优先级相同，则会选择回滚开销最低的进程作为死锁牺牲品</strong>。</p>
<p>下面的例子演示了一个简单的死锁。然后再介绍<strong>如何将系统中发生死锁的机会降至最低</strong>。</p>
<p>打开两个连接，确保都连接到TSQLFundamental2008数据库。在Connection 1中运行以下代码，打开一个新事务，更新Production.Products表中产品2的行，并保持事务一直打开：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">USE TSQLFundamentals2008;

BEGIN TRAN;
	UPDATE Production.Products
		SET unitPrice +&#x3D; 1.00
    WHERE productId &#x3D; 2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在Connection 2中运行以下代码，打开一个新事务，更新Sales.Orderdetails表中产品2的订单明细，并保持事务打开：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">BEGIN</span> <span class="token keyword">TRAN</span><span class="token punctuation">;</span>
    <span class="token keyword">UPDATE</span> Sales<span class="token punctuation">.</span>OrderDetails
        <span class="token keyword">SET</span> unitPrice <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1.00</span>
    <span class="token keyword">WHERE</span> productId <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>此时Connection 1中的事务持有Production.Products表中产品2这一行的排他锁，Connection 2中的事务持有Sales.OrderDetails表中产品2的订单明细行上的排他锁。两个査询都成功执行，还没有发生阻塞。</p>
<p>在Connection 1中运行以下代码，尝试在 Sales.OrderDetails表中査询产品2的订单明细，再提交事务：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">    <span class="token keyword">SELECT</span> orderId<span class="token punctuation">,</span> productId<span class="token punctuation">,</span> unitPrice
    <span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>OrderDetails
    <span class="token keyword">WHERE</span> productId <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

<span class="token keyword">COMMIT</span> <span class="token keyword">TRAN</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这段代码是在默认的READ COMMITTED隔离级别下运行的；因此Connection 1中的事务需要一个共享锁才能读数据。因为有其他事务持有同一资源上的排他锁，所以Connection1中的事务被阻塞。此时只是发生了阻塞而不是死锁。当然，要是Connection 2可以完成事务，释放所有的锁，则Connection1中的事务就能获得请求的锁。</p>
<p>接下来，在Connection 2中运行以下代码，尝试在Production.Products表中查询产品2，再提交事务：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">    <span class="token keyword">SELECT</span> productId<span class="token punctuation">,</span> unitPrice
    <span class="token keyword">FROM</span> Production<span class="token punctuation">.</span>Products
    <span class="token keyword">WHERE</span> productId <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    
<span class="token keyword">COMMIT</span> <span class="token keyword">TRAN</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Connection 2中的事务需要获得Production.Products表中产品2所在行上的共享锁，才能读取数据。所以这个请求和Connection 1中事务在同一资源上持有的排他锁冲突。<strong>这两个进程互相阻塞，发生了死锁</strong>。 <strong>SQL Server通常会在几秒钟内检测到死锁，并从这两个进程中选择一个作为死锁牺牲品，终止其事务。</strong></p>
<p>在本例中， SQL Server选择终止Connection 1中的事务。<strong>因为没有设置死锁优先级，而且两个事务进行的工作量也差不多一样，所以任何一个事务都有可能被终止</strong>。</p>
<p><strong>解除死锁要付出一定的系统开销，因为这个过程会涉及撤销已经执行过的处理</strong>。可以遵循一些最佳实践，将系统中发生死锁的机会降至最低：</p>
<ol>
<li>显然，事务处理的时间越长，持有锁的时间就越长，死锁的可能性也就越大。应该<strong>尽可能保持事务简短，把逻辑上可以不属于同一工作单元的操作移到事务以外</strong>。</li>
<li><strong>当事务以相反的顺序来访问资源时会发生死锁</strong>。例如，在上面的例子中，Connection 1先访问Production.Products表中的行，然后访问Sales.OrderDetails表中的行；而Connection 2先访问Sales.OrderDetails表中的行，然后访问Production.Products表中的行。<strong>如果两个事务按同样的顺序来访问资源，则不会发生这种类型的死锁。通过交换其中一个事务中的操作顺序，就可以避免发生这种类型的死锁（假设交换顺序不必改变程序的逻辑）</strong>。</li>
<li>上述列举的这个死锁例子有真实的逻辑冲突，因为两个事务都试图访问相同的行。不过，<strong>死锁发生时也经常没有真实的逻辑冲突</strong>，比如因为<strong>査询筛选条件缺少良好的索引支持而造成的死锁</strong>。例如，假设 Connection 2中的事务有两条语句要产品5进行筛选。既然Connection 1中的语句要处理产品2, Connection 2中的语句要处理产品5，所以它们不应该有任何冲突。但是，<strong>如果在表的productId列上没有索引来支持查询筛选，SQL Server就必须扫描（并锁定）表中的所有行</strong>。这样当然就会导致死锁。总之，良好的索引设计将有助于减少引发这种没有真正的逻辑冲突的死锁。</li>
</ol>
<p>操作完成以后，运行以下代码以清理测试数据：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> Production<span class="token punctuation">.</span>Products
	<span class="token keyword">SET</span> unitPrice <span class="token operator">=</span> <span class="token number">19.00</span>
<span class="token keyword">WHERE</span> productId <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

<span class="token keyword">UPDATE</span> Sales<span class="token punctuation">.</span>OrderDetails
	<span class="token keyword">SET</span> unitPrice <span class="token operator">=</span> <span class="token number">19.00</span>
<span class="token keyword">WHERE</span> productId <span class="token operator">=</span> <span class="token number">2</span>
	<span class="token operator">AND</span> orderId <span class="token operator">></span> <span class="token number">10500</span><span class="token punctuation">;</span>
	
<span class="token keyword">UPDATE</span> Sales<span class="token punctuation">.</span>OrderDetails
	<span class="token keyword">SET</span> unitPrice <span class="token operator">=</span> <span class="token number">15.20</span>
<span class="token keyword">WHERE</span> productId <span class="token operator">=</span> <span class="token number">2</span>
	<span class="token operator">AND</span> orderId <span class="token operator">&lt;</span> <span class="token number">10500</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h2 id="可编程对象"><a href="#可编程对象" class="headerlink" title="可编程对象"></a>可编程对象</h2><p>本章的目的旨在对这些可编程对象提供总体介绍，而不会深入到每个技术细节。阅读本章时应该着重理解可编程对象的逻辑处理和功能，不必尝试理解所有代码元素和它们的技术细节。有关可编程对象的细节和更深入的介绍，请参考“ Inside Microsoft SQL Server2008:T- SQL Programming”一书。</p>
<hr>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量用于临时保存数据值，以供在声明它们的同一批处理语句中引用。批处理稍后才会介绍，不过现在只要知道<strong>批处理是发送到SQL Server的一组单条或多条T-SQL语句，SQL Server会将批处理中的语句编译为单个可执行单元</strong>。</p>
<p>用<strong>DECLARE语句</strong>可以声明一个或多个变量，用SET语句可以把一个变量设置成指定的值。SQL Server 2008增加了对<strong>在同一语句中同时声明和初始化变量</strong>的支持。<strong>没有初始化的变量的默认值是NULL</strong>。</p>
<p>例如，以下代码先声明一个数据类型为INT的变量@i，再将它赋值为10：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DECLARE</span> <span class="token variable">@i</span> <span class="token keyword">AS</span> <span class="token keyword">INT</span><span class="token punctuation">;</span>
<span class="token keyword">SET</span> <span class="token variable">@i</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

<span class="token comment">-- SQL Server 2008新增加了对在同一语句中同时声明和初始化变量的支持</span>
<span class="token keyword">DECLARE</span> <span class="token variable">@i</span> <span class="token keyword">AS</span> <span class="token keyword">INT</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当为<strong>标量(scalar)变量</strong>赋值时，变量值必须是<strong>标量表达式的结果</strong>。表达式可以是标量子査询。例如，以下代码声明了一个变量@empName，再把一个标量子查询的结果赋值给这个变量，而由这个子査询返回ID等于3的雇员的全名：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> TSQLFundamentals2008<span class="token punctuation">;</span>

<span class="token keyword">DECLARE</span> <span class="token variable">@empName</span> <span class="token keyword">AS</span> NVARCHAR<span class="token punctuation">(</span><span class="token number">61</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">SET</span> <span class="token variable">@empName</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> firstName <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> lastName
                <span class="token keyword">FROM</span> HR<span class="token punctuation">.</span>Employees
                <span class="token keyword">WHERE</span> empId <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                
<span class="token keyword">SELECT</span> <span class="token variable">@empName</span> <span class="token keyword">AS</span> empName<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>SET语句每次只能对一个变量进行操作</strong>，所以如果需要把值赋值给多个变量（或列属性），就必须使用多个SET语句。<strong>当从同一行取出多个列的值时，这可能会带来一些不必要的开销</strong>。例如，以下代码使用两个单独的SET语句，把ID等于3的雇员的姓名分别赋值给两个变量：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DECLARE</span> <span class="token variable">@firstName</span> <span class="token keyword">AS</span> NVARCHAR<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token variable">@lastName</span> <span class="token keyword">AS</span> NVARCHAR<span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">SET</span> <span class="token variable">@firstName</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> firstName
                  <span class="token keyword">FROM</span> HR<span class="token punctuation">.</span>Employees
                  <span class="token keyword">WHERE</span> empId <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                  
<span class="token keyword">SET</span> <span class="token variable">@lastname</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> lastName
                 <span class="token keyword">FROM</span> HR<span class="token punctuation">.</span>Employees
                 <span class="token keyword">WHERE</span> empId <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                 
<span class="token keyword">SELECT</span> <span class="token variable">@firstName</span> <span class="token keyword">AS</span> firstName<span class="token punctuation">,</span> <span class="token variable">@lastName</span> <span class="token keyword">AS</span> lastName<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>SQL Server还支持一种<strong>非标准的赋值SELECT语句</strong>，允许在<strong>单独的语句中</strong>既査询数据也<strong>把从同一行中获得的多个值分配给多个变量</strong>。以下是这种用法的一个例子：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DECLARE</span> <span class="token variable">@firstName</span> <span class="token keyword">AS</span> NVARCHAR<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token variable">@lastName</span> <span class="token keyword">AS</span> NVARCHAR<span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> <span class="token variable">@firstName</span> <span class="token operator">=</span> firstName<span class="token punctuation">,</span>
	<span class="token variable">@lastName</span> <span class="token operator">=</span> lastName
<span class="token keyword">FROM</span> HR<span class="token punctuation">.</span>Employees
<span class="token keyword">WHERE</span> empId <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> <span class="token variable">@firstName</span> <span class="token keyword">As</span> firstName<span class="token punctuation">,</span> <span class="token variable">@lastName</span> <span class="token keyword">AS</span> lastName<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当满足条件的査询结果只有一行时，赋值SELECT语句的行为和我们预料的一样。但是注意，<strong>如果査询返回多个满足条件的结果行，这段代码也不会失败</strong>。<strong>对于每个满足条件的结果行，都会进行赋值：当访问每一行时，就会用当前行的值覆盖掉变量中的原有值</strong>。当赋值SELECT语句完成时，<strong>变量中保存的值是SQL Server随机访问到的最后一行中的值</strong>。</p>
<p><strong>SET语句比赋值SELECT语句更安全</strong>，因为<strong>它要求使用标量子査询来从表中提取数据</strong>。记住，如果在运行时，<strong>标量子查询返回了多个值，则査询会失败</strong>。</p>
<hr>
<h3 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h3><p>批处理是<strong>从客户端应用程序发送到SQL Server的一组单条或多条TSQL语句</strong>，SQL Server<strong>将批处理语句作为单个可执行的单元</strong>。批处理要经历的处理阶段有：<strong>分析（语法检査）、解析(检査引用的对象和列是否存在、是否具有访问权限)、优化（作为一个执行单元）</strong>。</p>
<p><strong>不要把事务和批处理搞混</strong>。事务是工作的<strong>原子工作单元</strong>，而<strong>一个批处理可以包含多个事务</strong>，一个事务也可以在多个批处理中的某些部分提交。当事务在执行中途被取消或回滚时， SQL Server会撤消自事务开始以来进行的部分活动，而不考虑批处理是从哪里开始的。</p>
<p>客户端应用程序的API(如ADO.NET)提供的方法可以把要执行的批处理代码提交到SQL Server。而诸如SQL Server Management Studio、SQLCMD以及OSQL之类的SQL Server实用工具则<strong>提供了一个客户端命令GO</strong>，可以发出<strong>一批T-SQL语句结束的信号</strong>。注意，<strong>GO命令是客户端工具的命令，而不是T-SQL服务器的命令</strong>。</p>
<hr>
<h4 id="批处理是语句分析的单元"><a href="#批处理是语句分析的单元" class="headerlink" title="批处理是语句分析的单元"></a>批处理是语句分析的单元</h4><p>批处理是作为一个单元而进行分析和执行的一组命令。如果分析成功，SQL Server接着就会尝试执行批处理。如果批处理中存在语法错误，整个批处理就不会提交到SQL Server执行。例如，以下代码包含3个批处理，其中第二个存在语法错误（第二个査询中的FOM应该是FROM)：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- Valid batch</span>
<span class="token keyword">PRINT</span> <span class="token string">'First batch'</span><span class="token punctuation">;</span>
<span class="token keyword">USE</span> TSQLFundamentals2008<span class="token punctuation">;</span>
GO

<span class="token comment">-- Invalid batch</span>
<span class="token keyword">PRINT</span> <span class="token string">'Second batch'</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> custId <span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Customers<span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> orderId FOM Sales<span class="token punctuation">.</span>Orders<span class="token punctuation">;</span>
GO

<span class="token comment">-- Valid batch</span>
<span class="token keyword">PRINT</span> <span class="token string">'Third batch'</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> empId <span class="token keyword">FROM</span> HR<span class="token punctuation">.</span>Employees<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>因为第2个批处理存在语法错误，所以该批处理不会提交到 SQL Server执行。而<strong>第1个和第3个批处理能够通过语法检查</strong>，因而可以提交到 SQL Server执行。即（同一个会话中，执行多个批处理，<strong>前面批处理的出错不会影响之后批处理的执行</strong>）。</p>
<hr>
<h4 id="批处理和变量"><a href="#批处理和变量" class="headerlink" title="批处理和变量"></a>批处理和变量</h4><p><strong>变量是属于定义它们的批处理的局部变量</strong>，如果试图引用在其他批处理中定义的变量，SQL Server引擎将会报告引用的变量还没有定义。</p>
<hr>
<h4 id="不能在同一批处理中编译的语句"><a href="#不能在同一批处理中编译的语句" class="headerlink" title="不能在同一批处理中编译的语句"></a>不能在同一批处理中编译的语句</h4><p>下列语句<strong>不能在同一批处理中和其他语句同时编译</strong>： <code>CREATE DEFAULT</code>、 <code>CREATE FUNCTION</code>、 <code>CREATE PROCEDURE</code>、 <code>CREATE RULE</code>、 <code>CREATE SCHEMA</code>、 <code>CREATE TRIGGER</code>及<code>CREATE VIEW</code>。例如，以下代码包含一个IF语句，之后在同一批处理中跟着一个CREATE VIEW语句，因此这样的批处理是无效的：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'Sales.MyView'</span><span class="token punctuation">,</span> <span class="token string">'V'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> 
	<span class="token keyword">DROP</span> <span class="token keyword">VIEW</span> Sales<span class="token punctuation">.</span>MyView<span class="token punctuation">;</span>

<span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> Sales<span class="token punctuation">.</span>MyView
<span class="token keyword">AS</span>
	<span class="token keyword">SELECT</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>orderDate<span class="token punctuation">)</span> <span class="token keyword">AS</span> orderYear<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">As</span> numOrders
	<span class="token keyword">FROM</span> sales<span class="token punctuation">.</span>Orders
	<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>orderDate<span class="token punctuation">)</span><span class="token punctuation">;</span>
GO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>为了避开这一问题，<strong>可以在IF语句之后添加一个GO命令，从而把IF和CREATE VIEW语句分隔到不同的批处理中</strong>。</p>
<hr>
<h4 id="批处理是语句解析的单元"><a href="#批处理是语句解析的单元" class="headerlink" title="批处理是语句解析的单元"></a>批处理是语句解析的单元</h4><p>批处理是<strong>语句解析的单元</strong>。这意味着<strong>检查数据对象和列是否存在，是在批处理级上进行的</strong>。当设计批处理的边界时，应该牢记这一事实。<strong>如果对数据对象的架构定义进行了修改，并试图在同一批处理中对该数据对象进行处理，那么 SQL Server可能还不知道架构定义发生了变化，因而无法执行数据处理语句，报告解析错误</strong>。下面将通过一个例子来演示这个问题，再对此推荐能够避免这一问题的最佳实践。</p>
<p>运行以下代码，在tempdb数据库中创建一个T1表，它包含一个列col1:</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">USE tempdb;
IF OBJECT_ID(&#39;dbo.T1&#39;, &#39;U&#39;) IS NOT NULL 
	DROP TABLE dbo.T1;
CREATE TABLE dbo.T1(col1 INT);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>接着，向T1表中新增一个col2列，并在同一个批处理中查询该新列：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>T1 <span class="token keyword">ADD</span> col2 <span class="token keyword">INT</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> col1<span class="token punctuation">,</span> col2 <span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>T1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>


<p>即使这段代码看起来可能相当有效，但批处理在解析期间还是会失败。</p>
<p>当<strong>解析</strong>SELECT语句时，T1表还只有一个列，对col2列的引用将导致错误。避免这种问题的最佳实践就是<strong>把DDL语句和DML语句分隔到不同的批处理中</strong>。</p>
<hr>
<h4 id="GO-n-选项"><a href="#GO-n-选项" class="headerlink" title="GO n 选项"></a>GO n 选项</h4><p>SQL Server 2005对GO命令这个客户端工具进行了增强，让它可以<strong>支持一个正整数参数</strong>，表示GO<strong>之前的批处理将执行指定的次数</strong>。<strong>当需要重复执行批处理时，就可以使用这个新选项</strong>。为了演示增强的GO命令，先在tmepdb数据库中创建一个T1表，它只有一个标识列：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'dbo.T1'</span><span class="token punctuation">,</span> <span class="token string">'U'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> 
	<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>T1<span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>T1<span class="token punctuation">(</span>col1 <span class="token keyword">INT</span> <span class="token keyword">IDENTITY</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>接着，运行以下代码，<strong>阻止DML语句在生成的结果中默认显示受影响的行数</strong>：</p>
<pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SET NOCOUNT ON;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>最后，运行以下代码，<strong>定义一个由INSERT DEFAULT VALUES语句组成的批处理，再执行100次</strong>：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>T1 <span class="token keyword">DEFAULT</span> <span class="token keyword">VALUES</span><span class="token punctuation">;</span>
GO <span class="token number">100</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>


<p>记住，GO是一个客户端命令，而不是服务器端的T-SQL命令。这意味着，<strong>无论连接到的数据库引擎的版本是什么，只要使用的客户端工具是SQL Server 2005或更高版本中的，就可以支持GO n命令</strong>。</p>
<hr>
<h3 id="流程控制元素"><a href="#流程控制元素" class="headerlink" title="流程控制元素"></a>流程控制元素</h3><h4 id="IF-…-ELSE-流程控制元素"><a href="#IF-…-ELSE-流程控制元素" class="headerlink" title="IF … ELSE 流程控制元素"></a>IF … ELSE 流程控制元素</h4><p>IF…ELSE元素用于根据条件来控制代码的执行流程。如果条件取值为TRUE，则执行指定的语句或语句块；如果条件取值为FALSE或UNKNOWN，则执行指定的另一语句或语句块（此部分为可选的）。</p>
<p>例如，以下代码<strong>检査今天是否是一年的最后一天</strong>（今天的年份和明天的年份不同）。如果是，代码就打印输出消息，说今天是一年的最后一天；如果不是，代码就打印输出消息，说今天不是一年的最后一天：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">IF</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span><span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>DATEADD<span class="token punctuation">(</span><span class="token keyword">day</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">PRINT</span> <span class="token string">'Today is the last day of the year.'</span>
<span class="token keyword">ELSE</span>
	<span class="token keyword">PRINT</span> <span class="token string">'Today is not the last day of the year.'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个例子中，<strong>用PRINT语句来指示代码的哪一部分被执行，哪一部分没有被执行</strong>。当然，也可以指定其他任何语句。</p>
<p>记住，T-SQL使用的是三值逻辑，当条件取值为 FALSE或 UNKNOWN时都可以激活ELSE语句块。如果条件取值可能为 FALSE或 UNKNOWN(例如，涉及到NULL值)，而且对每种情况需要进行不同的处理时，必须用IS NULL谓词对NULL值进行显式地测试。</p>
<p>如果需要控制的流程分支超过两个，则可以使用嵌套的IF…ELSE元素。例如，以下代码对3种情况进行不同的处理：</p>
<ol>
<li>今天是一年的最后一天；</li>
<li>今天是一个月的最后一天，但不是一年的最后一天；</li>
<li>今天不是一个月的最后一天。</li>
</ol>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">IF</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span><span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>DATEADD<span class="token punctuation">(</span><span class="token keyword">day</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">PRINT</span> <span class="token string">'Today is the last day of the year.'</span>
<span class="token keyword">ELSE</span> <span class="token keyword">IF</span> <span class="token keyword">MONTH</span><span class="token punctuation">(</span><span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">MONTH</span><span class="token punctuation">(</span>DATEADD<span class="token punctuation">(</span><span class="token keyword">day</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">PRINT</span> <span class="token string">'Today is the last day of the month but not the last day of the year.'</span>
<span class="token keyword">ELSE</span>
	<span class="token keyword">PRINT</span> <span class="token string">'Today is not the last day of the month.'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果需要<strong>在IF或ELSE部分运行多条语句</strong>，则可以使用<strong>语句块</strong>。<strong>语句块的边界是用一对BEGIN和END关键字标识的</strong>。例如，如果今天是一个月的第1天，则对TSQLFundamentals2008样例数据库进行完整备份；如果今天是一个月的最后1天，则对TSQLFundamentals2008样例数据库进行差异备份（只保存上一次完整备份以来做过的更新），以下代码可以实现这样的备份策略：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">IF</span> <span class="token keyword">DAY</span><span class="token punctuation">(</span><span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">BEGIN</span>
	<span class="token keyword">PRINT</span> <span class="token string">'Today is the first day of the month.'</span><span class="token punctuation">;</span>
	<span class="token keyword">PRINT</span> <span class="token string">'Starting a full database backup.'</span><span class="token punctuation">;</span>
	<span class="token keyword">BACKUP</span> <span class="token keyword">DATABASE</span> TSQLFundamentals2008
		<span class="token keyword">TO</span> <span class="token keyword">DISK</span> <span class="token operator">=</span> <span class="token string">'C:\Temp\TSQLFundamenta1s2008_full.BAK'</span> <span class="token keyword">WITH</span> INIT<span class="token punctuation">;</span>
	<span class="token keyword">PRINT</span> <span class="token string">'Finished full database backup'</span><span class="token punctuation">;</span>
<span class="token keyword">END</span>
<span class="token keyword">ELSE</span> <span class="token keyword">IF</span> <span class="token keyword">MONTH</span><span class="token punctuation">(</span><span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">MONTH</span><span class="token punctuation">(</span>DATEADD<span class="token punctuation">(</span><span class="token keyword">day</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">BEGIN</span>
	<span class="token keyword">PRINT</span> <span class="token string">'Today is the last day of the month.'</span>
	<span class="token keyword">PRINT</span> <span class="token string">'Starting a differential database backup.'</span><span class="token punctuation">;</span>
	<span class="token keyword">BACKUP</span> <span class="token keyword">DATABASE</span> TSQLFundamentals2008
		<span class="token keyword">TO</span> <span class="token keyword">DISK</span> <span class="token operator">=</span><span class="token string">'C:\Temp\TSQLFundamentals2008_Diff.BAK'</span> <span class="token keyword">WITH</span> DIFFERENTIAL<span class="token punctuation">;</span>
    <span class="token keyword">PRINT</span> <span class="token string">'Finished differential database backup.'</span><span class="token punctuation">;</span>
<span class="token keyword">END</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>注意，以上代码中的BACKUP DATABASE语句假设C:\Temp这个目录已经存在。</p>
<hr>
<h4 id="WHILE-流程控制元素"><a href="#WHILE-流程控制元素" class="headerlink" title="WHILE 流程控制元素"></a>WHILE 流程控制元素</h4><p>T-SQL提供的WHILE流程控制元素可以用于循环执行代码。当在WHILE关键字后指定的条件取值为TRUE时， WHILE元素可以重复执行一条语句或语句块。当指定的条件取值为FALSE或UNKNOWN时，循环将会终止。</p>
<p>T-SQL没有提供执行预定循环次数的内建元素，不过，用 WHILE循环和一个变量可以容易地模拟这样的元素。例如，以下代码演示了如何编写一个执行10次的循环：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DECLARE</span> <span class="token variable">@i</span> <span class="token keyword">AS</span> <span class="token keyword">INT</span><span class="token punctuation">;</span>
<span class="token keyword">SET</span> <span class="token variable">@i</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">WHILE</span> <span class="token variable">@i</span> <span class="token operator">&lt;=</span> <span class="token number">10</span>
<span class="token keyword">BEGIN</span>
	<span class="token keyword">PRINT</span> <span class="token variable">@i</span><span class="token punctuation">;</span>
	<span class="token keyword">SET</span> <span class="token variable">@i</span> <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">END</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果想在循环体内部的某一处<strong>退出当前循环</strong>，继续执行循环体之后的语句，则可以使用<strong>BREAK命令</strong>。例如，以下代码当变量@i的值等于6时，就会退出循环：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DECLARE</span> <span class="token variable">@i</span> <span class="token keyword">AS</span> <span class="token keyword">INT</span><span class="token punctuation">;</span>
<span class="token keyword">SET</span> <span class="token variable">@i</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">WHILE</span> <span class="token variable">@i</span> <span class="token operator">&lt;=</span> <span class="token number">10</span>
<span class="token keyword">BEGIN</span>
	<span class="token keyword">IF</span> <span class="token variable">@i</span> <span class="token operator">=</span> <span class="token number">6</span> <span class="token keyword">BREAK</span><span class="token punctuation">;</span>
	<span class="token keyword">PRINT</span> <span class="token variable">@i</span><span class="token punctuation">;</span>
	<span class="token keyword">SET</span> <span class="token variable">@i</span> <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">END</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果想在循环体内的某处<strong>忽略当前循环的剩余处理，继续进行下一次循环</strong>，则可以使用<strong>CONTINUE命令</strong>。例如，以下代码演示了如何在第6次进入循环体时，忽略从IF语句之后直到循环体结束之前出现的其他操作：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DECLARE</span> <span class="token variable">@i</span> <span class="token keyword">AS</span> <span class="token keyword">INT</span><span class="token punctuation">;</span>
<span class="token keyword">SET</span> <span class="token variable">@i</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">WHILE</span> <span class="token variable">@i</span> <span class="token operator">&lt;=</span> <span class="token number">10</span>
<span class="token keyword">BEGIN</span>
	<span class="token keyword">SET</span> <span class="token variable">@i</span> <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">IF</span> <span class="token variable">@i</span> <span class="token operator">=</span> <span class="token number">6</span> COUNTINUE<span class="token punctuation">;</span>
	<span class="token keyword">PRINT</span> <span class="token variable">@i</span><span class="token punctuation">;</span>
<span class="token keyword">END</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h4 id="使用-IF-和-WHILE-的一个例子"><a href="#使用-IF-和-WHILE-的一个例子" class="headerlink" title="使用 IF 和 WHILE 的一个例子"></a>使用 IF 和 WHILE 的一个例子</h4><p>以下代码组合使用了IF和WHILE元素。这个例子的目的是要在 tempdb数据库中创建1个dbo.Nums表，再为这个表填充1,000行数据，每行中的列n依次从1到1000中的取一个值：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SET</span> NOCOUNT <span class="token keyword">ON</span><span class="token punctuation">;</span>
<span class="token keyword">USE</span> tempdb<span class="token punctuation">;</span>
<span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'dbo.Nums'</span><span class="token punctuation">,</span> <span class="token string">'U'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> 
	<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Nums<span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Nums<span class="token punctuation">(</span>n <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
GO

<span class="token keyword">DECLARE</span> <span class="token variable">@i</span> <span class="token keyword">AS</span> <span class="token keyword">INT</span><span class="token punctuation">;</span>
<span class="token keyword">SET</span> <span class="token variable">@i</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">WHILE</span> <span class="token variable">@i</span> <span class="token operator">&lt;=</span> <span class="token number">1000</span>
<span class="token keyword">BEGIN</span>
	<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>Nums<span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token variable">@i</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">SET</span> <span class="token variable">@i</span> <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">END</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h3 id="游标-cursor"><a href="#游标-cursor" class="headerlink" title="游标 cursor"></a>游标 cursor</h3><p>在第2章“单表査询”一章中曾经介绍过，<strong>不带ORDER BY子句的査询返回的是一个集合（或多集）</strong>，而<strong>带有ORDER BY子句的査询返回的是一种ANSI称为游标（cursor）的对象，因为这种结果的行之间具有固定的顺序，所以不是关系的结果</strong>。在第2章讨论的上下文中，游标这一术语的使用仅限于表达一种概念。T-SQL也支持一种称为游标的对象，可以用它来<strong>处理査询返回的结果集中的各行</strong>，以指定的顺序<strong>一次只处理一行</strong>。这种处理方式与使用基于集合的查询（不带游标的普通査询）相反，<strong>普通的查询是把集合或多集作为一个整体来处理，不依赖任何顺序</strong>。</p>
<p>这里要强调的是，<strong>在默认情况下应该使用基于集合的查询，只在有令人信服的理由时才考虑使用游标</strong>。这一建议基于以下几个原因：</p>
<ul>
<li>首先也是最重要的，如果使用游标，就<strong>严重违背了关系模型</strong>，关系模型要求按照集合来考虑问题。</li>
<li>其次，游标逐行对记录进行操作会带来一定的开销。和基于集合的操作相比，游标<strong>分别对每一记录进行操作，这肯定会带来一定的额外开销</strong>。</li>
<li>第三，使用游标，需要为解决方案的物理操作编写很多代码，换句话说，<strong>得写很多代码来描述如何处理数据</strong>（声明游标、打开游标、循环遍历游标记录、关闭游标、释放游标）。而使用基于集合的解决方案，则主要关注于问题的逻辑方面，也就是说，只要描述要获取什么，而不必描述如何获取它们。因此，与基于集合的解决方案相比，<strong>基于游标的解决方案通常代码更长，可读性更低，也更加难以维护</strong>。</li>
</ul>
<p>对于大多数人来说，当开始学习SQL时，就马上能按集合的方式来考虑问题可能并不容易。与关系模型需要的思维方式相比，从游标的角度来考虑问题（以固定的顺序一次只处理一条记录）对大多数人来说可能更直观。结果，<strong>游标无形中被广泛使用，但大多数情况下是错误地使用；也就是说，使用游标的地方，往往也有更好的基于集合的解决方案存在</strong>。请在头脑中有意地努力保持基于集合的状态，真正地按集合来考虑问题。虽然这样做可能要多花些时间（可能要几年），但是，只要你驾驭了这种基于关系模型的语言，就找到了考虑问题所需的正确途径。</p>
<p>使用游标，就像是用鱼杆钩鱼，一次只能钩到一条鱼一样。另一方面，使用集合，就像是用渔网捕鱼，一次能捕到整整一网鱼。再打个比方，考虑有两种橘子包装工厂，一种是旧式的，另一种是新式的。工厂需要按3种不同的大小(小、中、大)把橘子分装到不同的盒子中。旧式工厂是以游标模式进行处理的，传送带把橘子带进来，在每条传送带的末端由专人负责检査每个橘子，根据橘子的大小把它放到正确的盒子中。当然，这种处理方式非常慢。此外，处理顺序在这里也很重要：如果传送带送过来的橘子是已经按大小排序的，处理起来就更容易了，这样就能把传送带的速度设置得更高。新式工厂是以集合模式进行处理的：所有橘子都放在一个大容器中，容器底部有一个带有小孔的网格。机器可以抖动这个容器，只有小橘子才能通过网格上的小孔。机器接着把橘子移到一个带有中型孔的容器中，再抖动容器，这时只有体积中等的橘子才能通过底部的孔。最后容器中剩下的就是大橘子。</p>
<p>即使你确信基于集合的解决方案是你的默认选择，理解一些例外也很重要，<strong>总会有应该使用游标的时候</strong>。一个例子是<strong>需要为某个表或视图中的每一行应用特定的操作</strong>。例如，可能需要为 SQL Server实例中的每个数据库（或数据库中的每个表）执行某种管理性任务。在这种情况下，用游标来<strong>循环遍历数据库名或表名</strong>，每次遍历为每个对象执行相关的任务，就变得有意义了。在后面的“动态SQL”一节将提供这种用法的例子。</p>
<p>应该考虑使用游标的另一个例子是当<strong>基于集合的解决方案执行情况不好，用基于集合的各种调整方法也无济于事</strong>时。如前所述，基于集合的解决方案通常要快得多，但是<strong>在某些情况下，基于游标的解决方案会更快</strong>。这样的情况通常是些<strong>计算型的操作</strong>，对于相应的基于集合的解决方案，即使在经过 SQL Server(SQL Server 2008及其早期版本)目前的优化处理以后，<strong>如果按固定顺序一次处理一行的游标方式涉及到的数据访问比前者要少得多，则使用游标会更加有效</strong>。<strong>连续聚合( running aggregate)就是这样的一个例子</strong>。在第4章“子查询”的“连续聚合”一节中曾经提供过一种使用子查询实现的基于集合的解决方案。性能优化已经超出了本书的讨论范围，所以在此不详细介绍为什么和基于集合的解决方案相比，用游标来实现连续聚合是目前更加有效的方法。如果准备处理T-SQL查询的性能优化问题，可以在<em>Inside Microsoft SQL Server2008: T- SQL Querying</em>一书中找到相关的细节。在这里只是希望读者明白，在大多数情况下，基于集合的解决方案在速度上通常比游标解决方案要快得多，但是在某些情况下，因为能进行更多的优化，因而游标执行起来仍然更快。</p>
<p>正如本章介绍所说的，本章只是提供对可编程对象的一个概览。所以接下来演示一个游标的例子可能更合适。<br>使用游标通常涉及以下步骤：</p>
<ol>
<li>在某个查询的基础上<strong>声明</strong>游标；</li>
<li><strong>打开</strong>游标；</li>
<li>从第1个游标记录中<strong>把列值提取到指定的变量</strong>；</li>
<li>当还<strong>没有超出游标的最后一行</strong>时(<code>@@FETCH_ STATUS</code>函数的<strong>返回值是0</strong>)，<strong>循环遍历</strong>游标记录：在每一次遍历中，从当前游标记录中把列值提取到指定的变量，再为当前行执行相应的处理；</li>
<li><strong>关闭</strong>游标；</li>
<li><strong>释放</strong>游标。</li>
</ol>
<p>下面这个例子使用游标来计算Sales.CustOrders视图中<strong>每个客户每个月的连续总订货量</strong>：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SET</span> NOCOUNT <span class="token keyword">ON</span><span class="token punctuation">;</span>
<span class="token keyword">USE</span> TSQLFundamentals2008<span class="token punctuation">;</span>

<span class="token keyword">DECLARE</span> <span class="token variable">@Result</span> <span class="token keyword">TABLE</span>
<span class="token punctuation">(</span>
    custId <span class="token keyword">INT</span><span class="token punctuation">,</span>
    orderMonth <span class="token keyword">DATETIME</span><span class="token punctuation">,</span>
    qty <span class="token keyword">INT</span><span class="token punctuation">,</span>
    runqty <span class="token keyword">INT</span><span class="token punctuation">,</span>
    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>custId<span class="token punctuation">,</span> orderMonth<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">DECLARE</span> <span class="token variable">@custId</span> <span class="token keyword">INT</span><span class="token punctuation">,</span> <span class="token variable">@prvCustId</span> <span class="token keyword">INT</span><span class="token punctuation">,</span>
	<span class="token variable">@orderMonth</span> <span class="token keyword">DATETIME</span><span class="token punctuation">,</span> <span class="token variable">@qty</span> <span class="token keyword">INT</span><span class="token punctuation">,</span>
	<span class="token variable">@runQty</span> <span class="token keyword">INT</span><span class="token punctuation">;</span>

<span class="token keyword">DECLARE</span> C <span class="token keyword">CURSOR</span> FAST_FORWARD <span class="token comment">/*read only, forward only */</span> <span class="token comment">-- 声明游标</span>
<span class="token keyword">FOR</span>
	<span class="token keyword">SELECT</span> custId<span class="token punctuation">,</span> orderMonth<span class="token punctuation">,</span> qty <span class="token comment">-- 从Custorders视图中按照客户ID和订单月份的顺序返回基本数据行</span>
	<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>CustOrders
	<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> custId<span class="token punctuation">,</span> orderMonth<span class="token punctuation">;</span>
	
<span class="token keyword">OPEN</span> C <span class="token comment">-- 打开游标</span>

<span class="token keyword">FETCH</span> <span class="token keyword">NEXT</span> <span class="token keyword">FROM</span> C <span class="token keyword">INTO</span> <span class="token variable">@custId</span><span class="token punctuation">,</span> <span class="token variable">@orderMonth</span><span class="token punctuation">,</span> <span class="token variable">@qty</span><span class="token punctuation">;</span> <span class="token comment">-- 取值到指定的变量</span>

<span class="token keyword">SELECT</span> <span class="token variable">@prvCustId</span> <span class="token operator">=</span> <span class="token variable">@custId</span><span class="token punctuation">,</span> <span class="token variable">@runQty</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">-- 既查询，又赋值</span>

<span class="token keyword">WHILE</span> @<span class="token variable">@FETCH_STATUS</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">-- 循环遍历</span>
<span class="token keyword">BEGIN</span>
	<span class="token keyword">IF</span> <span class="token variable">@custId</span> <span class="token operator">!=</span> <span class="token variable">@prvCustId</span>
		<span class="token keyword">SELECT</span> <span class="token variable">@prvCustId</span> <span class="token operator">=</span> <span class="token variable">@custId</span><span class="token punctuation">,</span> <span class="token variable">@runQty</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	
	<span class="token keyword">SET</span> <span class="token variable">@runQty</span> <span class="token operator">+</span><span class="token operator">=</span> <span class="token variable">@qty</span><span class="token punctuation">;</span>
	
	<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token variable">@Result</span> 
	<span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token variable">@custId</span><span class="token punctuation">,</span> <span class="token variable">@orderMonth</span><span class="token punctuation">,</span> <span class="token variable">@qty</span><span class="token punctuation">,</span> <span class="token variable">@runQty</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">FETCH</span> <span class="token keyword">NEXT</span> <span class="token keyword">FROM</span> C <span class="token keyword">INTO</span> <span class="token variable">@custId</span><span class="token punctuation">,</span> <span class="token variable">@orderMonth</span><span class="token punctuation">,</span> <span class="token variable">@qty</span><span class="token punctuation">;</span>
	
<span class="token keyword">CLOSE</span> C<span class="token punctuation">;</span> <span class="token comment">-- 关闭游标</span>

<span class="token keyword">DEALLOCATE</span> C<span class="token punctuation">;</span> <span class="token comment">-- 释放游标</span>

<span class="token keyword">SELECT</span> custId<span class="token punctuation">,</span>
	<span class="token keyword">CONVERT</span><span class="token punctuation">(</span><span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span> orderMonth<span class="token punctuation">,</span> <span class="token number">121</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> orderMonth<span class="token punctuation">,</span>
	qty<span class="token punctuation">,</span>
	runQty
<span class="token keyword">FROM</span> <span class="token variable">@Result</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> custId<span class="token punctuation">,</span> orderMonth<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>代码首先根据一个查询声明了一个游标，该查询用于从Custorders视图中按照客户ID和订单月份的顺序返回基本数据行；之后通过循环来遍历每个记录。代码会跟踪客户的当前连续总订货量，并把其值保存在变量@runQty中，并在每次找到一个新客户时重置这个变量。对于查询结果中返回的每一行，代码把当前月份的订货量(@qty)和变量@runQty相加，就可以计算出当前月份的连续总订货量，再把客户ID、订单月份、当前月份的订货量、以及连续总订货量作为一行插入到<strong>表变量@Result</strong>中。当代码处理完所有的游标记录后，再查询表变量以显示生成的连续聚合值。</p>
<hr>
<h3 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h3><p>有时需要把数据临时保存到表中，而且在某些情况下，你可能并不想使用水久性的表。例如，假设你需要让数据只对当前会话可见，或者甚至只对当前批处理可见。另一个例子是，假设你想让数据对所有用户都可见，允许他们看到完整的DDL和进行所有DML访问，但却没有在任何用户数据库中创建表的权限。<br>在这种情况下，使用临时表可能会更方便。 SQL Server支持三种类型的临时表：<strong>局部临时表</strong>、<strong>全局临时表</strong>及<strong>表变量</strong>。接下来的内容就分别介绍这三种临时表。</p>
<hr>
<h4 id="局部临时表"><a href="#局部临时表" class="headerlink" title="局部临时表"></a>局部临时表</h4><p>要创建局部临时表，只需要在命名时<strong>以单个<code>#</code>作为前缀</strong>，例如<code>#T1</code>。所有三种类型的<strong>临时表都是在tempdb数据库中创建</strong>的。</p>
<p>局部临时表只对<strong>创建它的会话</strong>在<strong>创建级</strong>和<strong>调用堆栈内部级（内部的过程、函数、触发器、以及动态批处理）可见</strong>。<strong>当创建级例程弹出调用堆栈，SQL Server就会自动删除相应的临时表</strong>。例如，假设一个存储过程Proc 1调用了另一个存储过程Proc 2，而Proc 2又调用了另一个存储过程Proc 3，Proc 3又调用了存储过程Proc 4。Proc 2在调用Proc 3之前创建了一个临时表<code>#T1</code>。这时表<code>#T1</code>对Proc 2、Proc 3和Proc 4是可见的，而对Proc 1是不可见的，<strong>当Proc 2完成时， SQL Server就会自动删除这个临时表</strong>。如果临时表是<strong>在会话最外层嵌套的一个特殊的批处理</strong>(<code>@@NESTLEVEL</code>函数的返回值是0)中创建的，则这个表对所有随后的批处理也是可见的，<strong>只有当创建会话从SQL Server实例断开时SQL Server才会自动删除它</strong>。</p>
<p>SQL Server内部会为临时表名称<strong>增加一个后缀</strong>，<strong>使表名称在tempdb数据库中保持唯一</strong>。并且<strong>只有你的会话才可以访问你的局部临时表</strong>。</p>
<p>可以使用临时表的一个明显场合是，当你的处理<strong>需要把中间结果临时保存起来</strong>（如在一个循环中），以供以后查询这些临时数据。</p>
<p>另一种场合是<strong>需要多次访问某个开销昂贵的处理结果</strong>。例如，假设需要对TSQLFundamentals2008数据库中的Sales.Orders和Sales.OrderDetails表进行连接，按订单年份对订货量进行聚合，之后再对聚合数据的两个实例进行连接，以比较每年的总订货量和前一年的总订货量。样例数据库中的Orders和OrderDetails表非常小，但是在实践中，这些表包含的数据可能达到数百万行。一种选择是使用表表达式，但记住<strong>表表达式是虚拟的</strong>。开销昂贵的工作涉及扫描所有数据、连接Orders和OrderDetails表、对数据进行再次聚合。所以，<strong>让所有开销昂贵的的工作只进行一次（把结果保存到一个局部临时表中），再对临时表的两个实例进行连接，这样做具有一定意义，尤其是因为开销昂贵的操作的结果是个非常小的集合，每个订单年份只有一行记录</strong>。</p>
<p>以下代码演示了使用局部临时表实现的解决方案：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> TSQLFundamentals2008<span class="token punctuation">;</span>

<span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'tempdb.dbo.#MyOrderTotalsByYear'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
	<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span><span class="token comment">#MyOrderTotalsByYear;</span>
GO

<span class="token keyword">SELECT</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>O<span class="token punctuation">.</span>orderDate<span class="token punctuation">)</span> <span class="token keyword">AS</span> orderYear<span class="token punctuation">,</span>
	<span class="token function">SUM</span><span class="token punctuation">(</span>OD<span class="token punctuation">.</span>qty<span class="token punctuation">)</span> <span class="token keyword">As</span> qty
<span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span><span class="token comment">#MyOrderTotalsByYear</span>
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders <span class="token keyword">AS</span> O
	<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> Sales<span class="token punctuation">.</span>OrderDetails <span class="token keyword">AS</span> OD
		<span class="token keyword">ON</span> OD<span class="token punctuation">.</span>orderId <span class="token operator">=</span> O<span class="token punctuation">.</span>orderId
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>orderDate<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> Cur<span class="token punctuation">.</span>orderYear<span class="token punctuation">,</span> Cur<span class="token punctuation">.</span>qty <span class="token keyword">AS</span> curYearQty<span class="token punctuation">,</span> Prv<span class="token punctuation">.</span>qty <span class="token keyword">AS</span> prvYearQty
<span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span><span class="token comment">#MyOrderTotalsByYear AS Cur</span>
	<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> dbo<span class="token punctuation">.</span><span class="token comment">#MyOrderTotalsByYear AS Prv</span>
<span class="token keyword">ON</span> Cur<span class="token punctuation">.</span>orderYear <span class="token operator">=</span> Prv<span class="token punctuation">.</span>orderYear <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h4 id="全局临时表"><a href="#全局临时表" class="headerlink" title="全局临时表"></a>全局临时表</h4><p>如果创建的是全局临时表，则它<strong>对其他所有会话都可见</strong>。当<strong>创建临时表的会话断开数据库的连接，而且也没有活动在引用全局临时表时， SQL Server会自动删除相应的全局临时表</strong>。要创建全局临时表，只需要在命名时用<strong>两个</strong><code>#</code>作为前缀，如<code>##T1</code>。</p>
<p>当需要和所有人共享临时数据时，就可以用全局临时表。访问全局临时表不需要任何特殊的权限，所有人都可以获取完整的DDL和DML访问。当然，<strong>每个人都可以完全访问也意味着任何人都可以删除这个表，所以也应该谨慎考虑全局临时表的副作用</strong>。</p>
<p>例如，以下代码创建了一个全局临时表<code>##Globals</code>，它包含id和val两个列：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span><span class="token comment">##Globals</span>
<span class="token punctuation">(</span>
	id sysName <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
	val SQL_VARIANT <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个表在这里是想模仿全局变量( SQL Server不支持全局变量)。列id的数据类型是<strong>sysname</strong>( SQL Server在内部用这个类型来<strong>代表标识符</strong>)，列val的数据类型是<strong>SQL_VARIANT</strong>(一种通用的类型，<strong>差不多可以保存任何基础类型的值</strong>)。</p>
<p>任何人都可以向全局临时表中插入数据行。例如，运行以下代码，在该临时表中插入代表变量i的一行，并将它的值初始化为整数10：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span><span class="token comment">##Globals(id, val) VALUES('i', CAST(10 AS INT));</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>任何人都能够修改和检索全局临时表中的数据。例如，在任何会话中运行以下代码，就可以查询到变量i的当前值：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> val <span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span><span class="token comment">##Globals WHERE id = 'i';</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果需要<strong>在每次SQL Server启动时都创建一个全局临时表</strong>，而且也<strong>不想让SQL Server自动删除它</strong>，则需要<strong>从一个标识为启动过程(startup procedure)的存储过程中创建全局临时表</strong>。相关的细节，可以参阅 SQL Server联机丛书的“自动执行存储过程（Automatic Execution of Stored Procedures)。</p>
<hr>
<h4 id="表变量"><a href="#表变量" class="headerlink" title="表变量"></a>表变量</h4><p>表变量和局部临时表在某些方面有相同之处，也有不同之处。声明表变量的方式和声明其他变量类似，使用的都是DECLARE语句。<br>和使用局部临时表一样，表变量在tempdb数据库中也有对应的表作为其物理表示，而不是像通常所理解的那样，以为表变量只在内存中存在。和局部临时表类似，表变量也只对创建它的会话可见，但<strong>允许访问的范围更有限，它只对当前批处理可见</strong>。<strong>表变量对调用堆栈中当前批处理的内部批处理是不可见的，对会话中随后的批处理也是不可见的</strong>。<br>如果回滚一个显式事务，在事务中对临时表所做的更改也将回滚：不过，通过语句<strong>对表变量进行的更改，如果在事务中已经完成了，则不会被回滚</strong>。只有通过活动语句进行的更改，而且操作失败或在完成之前被终止了，这样的更改才会被撤消。<br>临时表和表变量在性能优化方面也有区别，但这些内容超出了本书的讨论范围。现在只能说，<strong>从性能上考虑，对于少量的数据（只有几行），使用表变量更有意义，否则，应该使用临时表</strong>。<br>例如，以下代码没有使用局部临时表，而是使用表变量来比较每个订单年份和前一年的总订货量： </p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DECLARE</span> <span class="token variable">@MyOrderTotalsByYear</span> <span class="token keyword">TABLE</span> 
<span class="token punctuation">(</span>
	orderYear <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
	qty <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token variable">@MyOrderTotalsByYear</span><span class="token punctuation">(</span>orderYear<span class="token punctuation">,</span> qty<span class="token punctuation">)</span>
	<span class="token keyword">SELECT</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>O<span class="token punctuation">.</span>orderDate<span class="token punctuation">)</span> <span class="token keyword">AS</span> orderYear<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>OD<span class="token punctuation">.</span>qty<span class="token punctuation">)</span> <span class="token keyword">AS</span> qty 
	<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders <span class="token keyword">AS</span> O 
		<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> Sales<span class="token punctuation">.</span>OrderDetails <span class="token keyword">AS</span> OD 
			<span class="token keyword">ON</span> OD<span class="token punctuation">.</span>orderId <span class="token operator">=</span> O<span class="token punctuation">.</span>orderId 
	<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>orderDate<span class="token punctuation">)</span><span class="token punctuation">;</span> 

<span class="token keyword">SELECT</span> Cur<span class="token punctuation">.</span>orderyear<span class="token punctuation">,</span> Cur<span class="token punctuation">.</span>qty <span class="token keyword">AS</span> curYearQty<span class="token punctuation">,</span> Prv<span class="token punctuation">.</span>qty <span class="token keyword">AS</span> prvYearQty 
<span class="token keyword">FROM</span> <span class="token variable">@MyOrderTotalsByYear</span> <span class="token keyword">AS</span> Cur 
	<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> <span class="token variable">@MyOrderTotalsByYear</span> <span class="token keyword">AS</span> Prv 
		<span class="token keyword">ON</span> Cur<span class="token punctuation">.</span>orderYear <span class="token operator">=</span> Prv<span class="token punctuation">.</span>orderYear <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h4 id="表类型"><a href="#表类型" class="headerlink" title="表类型"></a>表类型</h4><p>SQL Server 2008引入了对表类型的支持。通过创建表类型，可以<strong>把表的定义保存到数据库中，以 后在定义表变量、存储过程和用户定义函数的输入参数时，可以将表类型作为表的定义而重用</strong>。<br>例如， 以下代码在TSQLFundamentals2008数据库中创建了一个表类型dbo.OrderTotalsByYear：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> TSQLFundamentals2008<span class="token punctuation">;</span>

<span class="token keyword">IF</span> TYPE_ID<span class="token punctuation">(</span><span class="token string">'dbo.OrderTotalsByYear'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
	<span class="token keyword">DROP</span> <span class="token keyword">TYPE</span> dbo<span class="token punctuation">.</span>OrderTotalsByYear<span class="token punctuation">;</span>
	
<span class="token keyword">CREATE</span> <span class="token keyword">TYPE</span> dbo<span class="token punctuation">.</span>OrderTotalsByYear <span class="token keyword">AS</span> <span class="token keyword">TABLE</span> 
<span class="token punctuation">(</span>
    orderYear <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
    qty <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p> <strong>创建好表类型以后，每当需要根据表类型的定义来声明表变量时，就不需要重复表定义代码，只要简单的将变量的类型指定为dbo.OrderTotalsByYear就可以</strong>，如下所示： </p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DECLARE</span> <span class="token variable">@MyOrderTotalsByYear</span> <span class="token keyword">AS</span> dbo<span class="token punctuation">.</span>OrderTotalsByYear<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p> 作为一个更复杂的例子，以下代码先声明了一个变量<code>@MyOrderTotalsByYear</code>，其数据类型为新定义的表类型；再查询Orders和OrderDetails表，按订单年份计算总订货量；再把查询的结果保存到表变量中；最后査询表变量，以显示它的内容：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DECLARE</span> <span class="token variable">@MyOrderTotalsByYear</span> <span class="token keyword">AS</span> dbo<span class="token punctuation">.</span>MyOrderTotalsByYear<span class="token punctuation">;</span>

<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token variable">@MyOrderTotalsByYear</span><span class="token punctuation">(</span>orderYear<span class="token punctuation">,</span> qty<span class="token punctuation">)</span>
	<span class="token keyword">SELECT</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>O<span class="token punctuation">.</span>orderDate<span class="token punctuation">)</span> <span class="token keyword">AS</span> orderYear<span class="token punctuation">,</span>
		<span class="token function">SUM</span><span class="token punctuation">(</span>OD<span class="token punctuation">.</span>qty<span class="token punctuation">)</span> <span class="token keyword">AS</span> qty
    <span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders <span class="token keyword">AS</span> O
    	<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> Sales<span class="token punctuation">.</span>OrderDetails <span class="token keyword">AS</span> OD	
    		<span class="token keyword">ON</span> OD<span class="token punctuation">.</span>orderId <span class="token operator">=</span> O<span class="token punctuation">.</span>orderId 
    <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>orderDate<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
<span class="token keyword">SELECT</span> orderYear<span class="token punctuation">,</span> qty 
<span class="token keyword">FROM</span> <span class="token variable">@MyOrderTotalsByYear</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>表变量的表类型<strong>只是为了有助于精简代码</strong>，不过从功能概念上来说，其实并没有引入什 么新功能。 但是如前所述，<strong>表类型也可以作为存储过程和函数的输入参数的类型</strong>，这种非常有用的功能从概念上来说算是新的。</p>
<hr>
<h3 id="动态-SQL"><a href="#动态-SQL" class="headerlink" title="动态 SQL"></a>动态 SQL</h3><p>SQL Server允许<strong>用字符串来动态构造T-SQL代码的一个批处理</strong>，接着再执行这个批处理。<br>这种功能称为动态SQL(dynamic SQL)。SQL Server提供了两种执行动态SQL的方法：使用<code>EXEC</code>( EXECUTE的缩写)命令和使用<code>sp_ executesql</code>存储过程。<br>动态SQL可以用于以下几种用途： </p>
<ul>
<li>自动化管理任务。<br>  例如，对于数据库实例中的每个数据库，査询其元数据，为其执行<code>BACKUP DATABASE</code>语句。</li>
<li>改善特定任务的性能。<br>  例如，构造参数化的特定查询，以重用以前缓存过的执行计划（稍后对此详细介绍）。</li>
<li>在对实际数据进行查询的基础上，构造代码元素。<br>  例如，当事先不知道在 PIVOT运算符的IN子句中应该出现哪些元素时，动态构造PIVOT査询。<br>  注意：当把用户的输入拼接为代码中的一部分时，要特别小心。黑客们经常会试图注入(inject) 你不想运行的代码。<strong>要防止SQL注入，最好的办法就是避免将用户的输入拼接为代码 的一部分(例如，通过使用参数)</strong>。但是如果你确实需要将用户的输入拼接为代码的一 部分，<strong>务必要对用户的输入进行彻底检查</strong>，看看有没有SQL注入的企图。 SQL Server 联机丛书中的“SQL注入( SQL Injection)”是一篇介绍这方 面内容的优秀文章。</li>
</ul>
<hr>
<h4 id="EXEC-命令"><a href="#EXEC-命令" class="headerlink" title="EXEC 命令"></a>EXEC 命令</h4><p>EXEC命令是T-SQL中最早提供的一种用于执行动态SQL的方法。<strong>EXEC接受一个字符串作为在圆括号中输入的参数，执行字符串中包含的批处理代码</strong>。EXEC命令的输入既支持普通字符，也支持Unicode字符。<br>首先以一个非常基本的用EXEC调用动态SQL的例子作为开始。以下例子在变量<code>@sql</code>中保存了一个字符串，该字符串中包含一条PRINT语句，再用EXEC命令调用保存在变量中的批处理代码：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DECLARE</span> <span class="token variable">@sql</span> <span class="token keyword">AS</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">SET</span> <span class="token variable">@sql</span> <span class="token operator">=</span> <span class="token string">'PRINT ''This message was printed by a dynamic SQL batch.'';'</span><span class="token punctuation">;</span>
<span class="token keyword">EXEC</span><span class="token punctuation">(</span><span class="token variable">@sql</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>注意，以上代码中对于字符串中的字符串，<strong>需要用两个单引号来代表一个单引号</strong>。<br>下面这个例子使用游标对INFORMATION_SCHEMA.TABLES视图进行查询，以获取TSQLFundamentals2008数据库中表的名称。 对于每个表，代码将构造和执行一个批处理代码，对当前表调用<code>sp_spaceused</code>存储过程以获取其磁盘空间使用信息：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> TSQLFundamentals2008<span class="token punctuation">;</span> 

<span class="token keyword">DECLARE</span> <span class="token variable">@sql</span> NVARCHAR<span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token variable">@schemaName</span> sysName<span class="token punctuation">,</span>
	<span class="token variable">@tableName</span> sysName<span class="token punctuation">;</span>

<span class="token keyword">DECLARE</span> C <span class="token keyword">CURSOR</span> FAST_FORWARD <span class="token keyword">FOR</span>
	<span class="token keyword">SELECT</span> TABLE_SCHEMA<span class="token punctuation">,</span> TABLE_NAME
	<span class="token keyword">FROM</span> INFORMATION_SCHEMA<span class="token punctuation">.</span><span class="token keyword">TABLES</span> 	
	<span class="token keyword">WHERE</span> TABLE_TYPE <span class="token operator">=</span> <span class="token string">'BASE TABLE'</span><span class="token punctuation">;</span>

<span class="token keyword">OPEN</span> C 

<span class="token keyword">FETCH</span> <span class="token keyword">NEXT</span> <span class="token keyword">FROM</span> C <span class="token keyword">INTO</span> <span class="token variable">@schemaName</span><span class="token punctuation">,</span> <span class="token variable">@tableName</span><span class="token punctuation">;</span> 

<span class="token keyword">WHILE</span> @<span class="token variable">@fetch_status</span> <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">BEGIN</span> 	
	<span class="token keyword">SET</span> <span class="token variable">@sql</span> <span class="token operator">=</span> <span class="token string">'EXEC sp_spaceused '''</span> 
				<span class="token operator">+</span> QUOTENAME<span class="token punctuation">(</span><span class="token variable">@schemaName</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'.'</span> 
				<span class="token operator">+</span> QUOTENAME<span class="token punctuation">(</span><span class="token variable">@tableName</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">''';'</span><span class="token punctuation">;</span>
	
	<span class="token keyword">EXEC</span><span class="token punctuation">(</span><span class="token variable">@sql</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		
	
	<span class="token keyword">FETCH</span> <span class="token keyword">NEXT</span> <span class="token keyword">FROM</span> C 
	<span class="token keyword">INTO</span> <span class="token variable">@schemaName</span><span class="token punctuation">,</span> <span class="token variable">@tableName</span><span class="token punctuation">;</span>
<span class="token keyword">END</span> 

<span class="token keyword">CLOSE</span> C<span class="token punctuation">;</span>

<span class="token keyword">DEALLOCATE</span> C<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在以上代码中，你可能会对<code>QUOTENAME</code>函数的使用感到好奇，这个函数用于<strong>分隔输入的值</strong>。 <code>QUOTENAME</code>的<strong>第二个参数用于指定用作分隔符的单字符字符串</strong>，如果不指定这个参数，则<strong>默认使用方括号</strong>。所以，如果<code>@tableName</code>的值是<code>&#39;My Table&#39;</code>，则<code>QUOTENAME(@tableName)</code>将返回<code>&#39;[My Table]&#39;</code>，<strong>使变量值成为有效的标识符</strong>。<br>这段代码会<strong>显示出数据库中所有表的磁盘空间使用信息</strong>。</p>
<hr>
<h4 id="sp-executesql-存储过程"><a href="#sp-executesql-存储过程" class="headerlink" title="sp_executesql 存储过程"></a>sp_executesql 存储过程</h4><p><code>sp_executesql</code>存储过程是继EXEC命令之后引入的另一种执行动态SQL的方法。从<code>sp_executesql</code>的调用接口来说，<strong>使用这个存储过程更安全和更灵活，因为它支持输入和 输出参数</strong>。注意，与EXEC命令不同的是，<code>sp_executesql</code>存储过程<strong>只支持使用Unicode 字符串作为其输入的批处理代码</strong>。<br>正因为在动态SQL代码中可以使用输入和输出参数，这样就有助于写出更安全和更有效的代码。从安全性的角度来说，在代码中出现的参数并不是代码的一部分，而只是表达式中的运算对象。所以，通过使用参数，就可以不必受SQL注入的困扰了。<br><code>sp_executes</code>存储过程的<strong>执行性能要比EXEC命令更好</strong>，因为<strong>它的参数化有助于重用缓存过的执行计划</strong>。<strong>执行计划是SQL Server为查询生成的物理处理计划，包含了一组指 令，说明要访问哪些对象、以什么顺序、使用哪个索引、如何访问它们、使用什么连接算法、等等</strong>。为 了简化处理，<strong>如果要重用以前缓存过的执行计划，必须满足的条件之一就是査询字符串应该和缓存中已经存在的执行计划的查询字符串相同。所以，有效重用查询执行计划最好的方法就是使用带有参数的存储过程。这样一来，即使参数值发生了 变化，可查询字符串仍然保持相同</strong>。但如果你出于自己的原因而决定使用特定的代码， 而不使用存储过程，至少你仍然可以尽可能地使用参数。只不过如果使用<code>sp_ executesql</code>存储过程，则会增加重用执行计划的机会。<br><code>sp_executesql</code>存储过程有<strong>两个输入参数</strong>和<strong>一个参数赋值部分</strong>。在第一个参数<code>@stmt</code>中，需要<strong>指定包含想要运行的批处理代码的Unicode字符串</strong>。第二个参数<code>@params</code>是一个Unicode字符串，包含<code>@stmt</code>中<strong>所有输入和输出参数的声明</strong>。<strong>接着为输入和输出参数指定取值，各参数之间用逗号分隔</strong>。<br>下面这个例子构造了一个对 Sales.Orders表进行查询的批处理代码，在其查询过滤条件中使用了一个输入参数<code>@orderId</code>：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DECLARE</span> <span class="token variable">@sql</span> NVARCHAR<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">SET</span> <span class="token variable">@sql</span> <span class="token operator">=</span> <span class="token string">'SELECT orderId, custId, empId, orderDate
			FROM Sales.Orders
            WHERE orderId = @orderId;'</span><span class="token punctuation">;</span>		
            
<span class="token keyword">EXEC</span> sp_executes 
	<span class="token variable">@stmt</span> <span class="token operator">=</span> <span class="token variable">@sql</span><span class="token punctuation">,</span>
	<span class="token variable">@params</span> <span class="token operator">=</span> <span class="token string">'@orderId AS INT'</span><span class="token punctuation">,</span>
	<span class="token variable">@orderId</span> <span class="token operator">=</span> <span class="token number">10248</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>代码中将输入参数的取值指定为10248，<strong>即使采用不同的值再运行这段代码，代码字符串仍然保持相同</strong>，这样就<strong>可以增加重用以前缓存过的执行计划的机会</strong>。<br>为了使用输出参数，只需要简单地<strong>在参数声明部分和参数赋值部分同时指定OUTPUT关键字</strong>。下面的例子演示了输出参数的用法。这段代码将查询INFORMATION_SCHEMA.TABLES视图，获取数据库中表和视图名称的列表，再使用游标来循环遍历对象名称。<strong>在每次循环中，代码会构造一个动态SQL批处理，以查询当前对象中的行数，并把査询结果保存在一个输出参数@n中</strong>。之后，将输出参数@n中的值传递到局部变量<code>@numRows</code>（该参数被指定为输出参数）。在循环结尾，代码将对象名称和当前对象的行数作为一个新行插入到表变量@Counts中。当代码循环遍历完游标记 录后，再查询表变量，以显示计数结果。以下是例子的完整代码：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DECLARE</span> <span class="token variable">@Counts</span> <span class="token keyword">TABLE</span> 
<span class="token punctuation">(</span>	
    schemaName sysName <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    tableName sysName <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    numRows <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>schemaName<span class="token punctuation">,</span> tableName<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">DECLARE</span> <span class="token variable">@sql</span> NVARCHAR<span class="token punctuation">(</span><span class="token number">350</span><span class="token punctuation">)</span><span class="token punctuation">,</span>	
	<span class="token variable">@schemaName</span> sysName<span class="token punctuation">,</span>
	<span class="token variable">@tableName</span> sysName<span class="token punctuation">,</span>
	<span class="token variable">@numRows</span> <span class="token keyword">INT</span><span class="token punctuation">;</span>
	
<span class="token keyword">DECLARE</span> C <span class="token keyword">CURSOR</span> FAST_FORWARD <span class="token keyword">FOR</span>
	<span class="token keyword">SELECT</span> TABLE_SCHEMA<span class="token punctuation">,</span> TABLE_NAME 
	<span class="token keyword">FROM</span> INFORMATION_SCHEMA<span class="token punctuation">.</span><span class="token keyword">TABLES</span><span class="token punctuation">;</span> 
	
<span class="token keyword">OPEN</span> C 

<span class="token keyword">FETCH</span> <span class="token keyword">NEXT</span> <span class="token keyword">FROM</span> C <span class="token keyword">INTO</span> <span class="token variable">@schemaName</span><span class="token punctuation">,</span> <span class="token variable">@tablename</span><span class="token punctuation">;</span>

<span class="token keyword">WHILE</span> @<span class="token variable">@fetch_status</span> <span class="token operator">=</span> <span class="token number">0</span> 
<span class="token keyword">BEGIN</span>
	<span class="token keyword">SET</span> <span class="token variable">@sql</span> <span class="token operator">=</span> <span class="token string">'SET @n = (SELECT COUNT(*) FROM '</span>
				<span class="token operator">+</span> QUOTENAME<span class="token punctuation">(</span><span class="token variable">@schemaName</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'.'</span>
                <span class="token operator">+</span> QUOTENAME<span class="token punctuation">(</span><span class="token variable">@tableName</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">');'</span><span class="token punctuation">;</span>
                
	<span class="token keyword">EXEC</span> sp_executesql 
		<span class="token variable">@stmt</span> <span class="token operator">=</span> <span class="token variable">@sql</span><span class="token punctuation">,</span>
		<span class="token variable">@params</span> <span class="token operator">=</span> <span class="token string">'@n AS INT OUTPUT'</span><span class="token punctuation">,</span>
        <span class="token variable">@n</span> <span class="token operator">=</span> <span class="token variable">@numRows</span> OUTPUT<span class="token punctuation">;</span>
        
    <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token variable">@Counts</span><span class="token punctuation">(</span>schemaName<span class="token punctuation">,</span> tableName<span class="token punctuation">,</span> numRows<span class="token punctuation">)</span>
    	<span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token variable">@schemaName</span><span class="token punctuation">,</span> <span class="token variable">@tableName</span><span class="token punctuation">,</span> <span class="token variable">@numRows</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
    	
    <span class="token keyword">FETCH</span> <span class="token keyword">NEXT</span> <span class="token keyword">FROM</span> C <span class="token keyword">INTO</span> <span class="token variable">@schemaName</span><span class="token punctuation">,</span> <span class="token variable">@tableName</span><span class="token punctuation">;</span> 
<span class="token keyword">END</span> 

<span class="token keyword">CLOSE</span> C<span class="token punctuation">;</span>

<span class="token keyword">DEALLOCATE</span> C<span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> schemaName<span class="token punctuation">,</span> tableName<span class="token punctuation">,</span> numRows 
<span class="token keyword">FROM</span> <span class="token variable">@Counts</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h4 id="在-PIVOT-中使用动态-SQL"><a href="#在-PIVOT-中使用动态-SQL" class="headerlink" title="在 PIVOT 中使用动态 SQL"></a>在 PIVOT 中使用动态 SQL</h4><p>如前所述，在静态査询中，必须事先知道在 PIVOT运算符的IN子句中应该指定哪些值。以下是一个使用PIVOT运算符进行静态査询的例子：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> shipperId<span class="token punctuation">,</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>orderDate<span class="token punctuation">)</span> <span class="token keyword">AS</span> orderYear<span class="token punctuation">,</span> freight
      <span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders<span class="token punctuation">)</span> <span class="token keyword">AS</span> D
	<span class="token keyword">PIVOT</span><span class="token punctuation">(</span><span class="token function">SUM</span><span class="token punctuation">(</span>freight<span class="token punctuation">)</span> <span class="token keyword">FOR</span> orderYear <span class="token operator">IN</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2006</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2007</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2008</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> P<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p> 这个例子査询 Sales.Orders表，对数据进行透视转换，以便返回的数据中以送货人ID作为行，以订单年份作为列，在每个送货人和订单年份的交叉位置上是总的运费。<br>对于静态查询，必须事先知道在PIVOT运算符的IN子句中应该指定哪些值（在以上例子中是订单年份）。这意味着对于不同的年份，都得调整代码。相反，也可以从数据中查询不同的订单年份，根据查询到的年份来构造一个动态SOL代码的批处理，再执行这个动态SQL批处理，如下所示：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DECLARE</span> <span class="token variable">@sql</span> NVARCHAR<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token variable">@orderYear</span> <span class="token keyword">INT</span><span class="token punctuation">,</span>	
	<span class="token variable">@first</span> <span class="token keyword">INT</span><span class="token punctuation">;</span>
	
<span class="token keyword">DECLARE</span> C <span class="token keyword">CURSOR</span> FAST_FORWARD <span class="token keyword">FOR</span> 
	<span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span><span class="token punctuation">(</span><span class="token keyword">YEAR</span><span class="token punctuation">(</span>orderDate<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> orderYear
    <span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders 
    <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> orderer<span class="token punctuation">;</span> 
    
<span class="token keyword">SET</span> <span class="token variable">@first</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">SET</span> <span class="token variable">@sql</span> <span class="token operator">=</span> <span class="token string">'SELECT *
			FROM (SELECT shipperId, YEAR(orderDate) AS orderYear, freight 
            	  FROM Sales.Orders) AS D
            	PIVOT(SUM(freight) FOR orderYear IN('</span><span class="token punctuation">;</span>
            	
<span class="token keyword">OPEN</span> C 

<span class="token keyword">FETCH</span> <span class="token keyword">NEXT</span> <span class="token keyword">FROM</span> C <span class="token keyword">INTO</span> <span class="token variable">@orderYear</span><span class="token punctuation">;</span> 

<span class="token keyword">WHILE</span> @<span class="token variable">@fetch_status</span> <span class="token operator">=</span> <span class="token number">0</span> 
<span class="token keyword">BEGIN</span> 	
	<span class="token keyword">IF</span> <span class="token variable">@first</span> <span class="token operator">=</span> <span class="token number">0</span>
    	<span class="token keyword">SET</span> <span class="token variable">@sq1</span> <span class="token operator">=</span> <span class="token variable">@sql</span> <span class="token operator">+</span> <span class="token string">','</span><span class="token punctuation">;</span>
    <span class="token keyword">ELSE</span>
    	<span class="token keyword">SET</span> <span class="token variable">@first</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>		
    	
    <span class="token keyword">SET</span> <span class="token variable">@sql</span> <span class="token operator">=</span> <span class="token variable">@sql</span> <span class="token operator">+</span> QUOTENAME<span class="token punctuation">(</span><span class="token variable">@orderYear</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">FETCH</span> <span class="token keyword">NEXT</span> <span class="token keyword">FROM</span> C <span class="token keyword">INTO</span> <span class="token variable">@orderYear</span><span class="token punctuation">;</span>     
<span class="token keyword">END</span> 

<span class="token keyword">CLOSE</span> C<span class="token punctuation">;</span>

<span class="token keyword">DEALLOCATE</span> C<span class="token punctuation">;</span> 

<span class="token keyword">SET</span> <span class="token variable">@sql</span> <span class="token operator">=</span> <span class="token variable">@sql</span> <span class="token operator">+</span> <span class="token string">')) AS P;'</span><span class="token punctuation">;</span>

<span class="token keyword">EXEC</span> sp_executesql <span class="token variable">@stmt</span> <span class="token operator">=</span> <span class="token variable">@sql</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h3 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h3><p>例程( routine)是<strong>为了计算结果或执行任务而对代码进行封装的一种编程对象</strong>。SQL Server支持三 种例程：用户定义函数、存储过程，以及触发器。<br>从 SQL Server 2005开始，开发程序例程时可以选择是用T-SQL开发，还是用NET代码在集成到产品中的公共语言运行时(CLR, Common Language Runtime)的基础上进行开发。因为本书的重点是T-SQL，所以这里演示的例子将使用T-SQL。一般来说，当任务主要<strong>涉及数据处理时，T-SQL通常是更好的选择</strong>。当任务侧重于交互逻辑、字符串处理、或计算密集的操作时，NET通常是更好的选择。 </p>
<hr>
<h4 id="用户定义函数"><a href="#用户定义函数" class="headerlink" title="用户定义函数"></a>用户定义函数</h4><p>用户定义函数(UDF, user- defined function)的目的是要封装计算的逻辑处理，有可能需要基于输入的参数，并返回结果。<br>SQL Server支持两种用户定义函数：标量UDF和表值UDF。<strong>标量UDF只返回单个数据值。而表值UDF则返回一个表</strong>。使用UDF的优点之一是可以在査询中集成UDF。<strong>对于査询中返回单个值的表达式，在其出现的位置上，也能够使用标量UDF(例如，在SELECT列表中）。表值UDF只能在査询的FROM子句中出现</strong>。这里将提供一个标量UDF的例子。<br>UDF不允许有任何副作用。这一规定明显的含义是<strong>UDF不能对数据库中的任何架构或数据进行修改</strong>。此外，其他一些引起副作用的操作则不那么明显。例如，调用<code>RAND</code>函数<strong>返回一个随机值</strong>，或调用<code>NEWID</code>函数<strong>返回一个全局唯一标识符(GUID)</strong>，就有副作用。每当调用<code>RAND</code>函数，<strong>但不指定种子值</strong>时， SQL Server就会<strong>根据以前对RAND的调用而生成一个随机的种子值</strong>。因此，当调用<code>RAND</code>函数时， SQL Server内部<strong>需要保存相关的信息</strong>。与之类似，每当调用<code>NEWID</code>函数时，系统也需要设置某种信息，以便下一次调用<code>NEWID</code>时使用。因为RAND和NEWD函数 都有副作用，所以在UDF中不允许使用它们。<br>例如，以下代码创建了一个用户定义函数<code>dbo.fn_age</code>，对于给定出生日期（@birthDate参数）和事件日期（@eventDate），这个函数可以返回某个人在事件日期当时的年龄：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> TSQLFundamentals2008<span class="token punctuation">;</span>

<span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'dbo.fn_age'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> 	
	<span class="token keyword">DROP</span> <span class="token keyword">FUNCTION</span> dbo<span class="token punctuation">.</span>fn_age<span class="token punctuation">;</span> 
GO

<span class="token keyword">CREATE</span> <span class="token keyword">FUNCTION</span> dbo<span class="token punctuation">.</span>fn_age
<span class="token punctuation">(</span>	
    <span class="token variable">@birthDate</span> <span class="token keyword">DATETIME</span><span class="token punctuation">,</span>	
    <span class="token variable">@eventDate</span> <span class="token keyword">DATETIME</span>
<span class="token punctuation">)</span>  
<span class="token keyword">RETURNS</span> <span class="token keyword">INT</span> 
<span class="token keyword">AS</span>
<span class="token keyword">BEGIN</span> 	
	<span class="token keyword">RETURN</span> DATEDIFF<span class="token punctuation">(</span><span class="token keyword">year</span><span class="token punctuation">,</span> <span class="token variable">@birthDate</span><span class="token punctuation">,</span> <span class="token variable">@eventDate</span><span class="token punctuation">)</span>
    		<span class="token operator">-</span> <span class="token keyword">CASE</span> <span class="token keyword">WHEN</span> <span class="token number">100</span> <span class="token operator">*</span> <span class="token keyword">MONTH</span><span class="token punctuation">(</span><span class="token variable">@eventDate</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">DAY</span><span class="token punctuation">(</span><span class="token variable">@eventDate</span><span class="token punctuation">)</span> 
            	<span class="token operator">&lt;</span> <span class="token number">100</span> <span class="token operator">*</span> <span class="token keyword">MONTH</span><span class="token punctuation">(</span><span class="token variable">@birthDate</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">DAY</span><span class="token punctuation">(</span><span class="token variable">@birthDate</span><span class="token punctuation">)</span> 				
                <span class="token keyword">THEN</span> <span class="token number">1</span> <span class="token keyword">ELSE</span> O
              <span class="token keyword">END</span>  
<span class="token keyword">END</span> 
GO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个函数按照年份来计算生日年份和事件年份的差值，以作为其年龄，如果事件日期的月份和天数小于出生日期的月份和天数，则还需要在差值中再减去1。表达式<code>100 * month + day</code>是<strong>拼接月份和天数的一种简单技巧</strong>。<br>注意，一个函数体内可以包含多个RETURN子句，也可以包含流程控制代码、计算代码， 等等。但是函数必须由一个RETURN子句返回一个值。<br>为了演示在查询中使用UDF，以下代码对HR.Employees表进行查询，在SELECT列表中调用<code>fn_age</code>函数以计算每个雇员在查询当天的年龄：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> empId<span class="token punctuation">,</span> firstName<span class="token punctuation">,</span> lastName<span class="token punctuation">,</span> birthDate<span class="token punctuation">,</span>	
	dbo<span class="token punctuation">.</span>fn_age<span class="token punctuation">(</span>birthDate<span class="token punctuation">,</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> age
<span class="token keyword">FROM</span> HR<span class="token punctuation">.</span>Employees<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<hr>
<h4 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h4><p>存储过程是封装了T-SQL代码的服务器端例程。<strong>存储过程可以有输入和输出参数，可以返回多个査询的结果集，也允许调用具有副作用的代码。通过存储过程不但可以对数据进行修改，也可以对数据库架构进行修改</strong>。<br>和使用特定的普通代码相比，使用存储过程可以获得以下好处：</p>
<ul>
<li>存储过程可以<strong>封装逻辑处理</strong>。</li>
<li>通过存储过程可以<strong>更好地控制安全性</strong>。<br>  可以授予用户执行某个存储过程的权限，而 不是授予用户直接执行底层操作的权限。例如，假设现在想允许特定用户可以删除数据库中的客户数据， 但是不想授予他们直接从Customers表中删除数据行的权限。而且还需要确保删除客户的请求是有效的（例如，检査客户是否有延期交货的订单、 是否有未清的债务等等），也可能需要对请求进行审核。<strong>不是授权直接删除Customers表中的客户，而是通过能够处理这一任务的某个存储过程进行授权，这样就可以确保执行所有要求的检查和审核处理</strong>。此外，存储过程也<strong>有助于避免SQL注入，尤其是从客户端通过参数来替换特殊的SQL的注入形式</strong>。 </li>
<li>在存储过程中可以<strong>整合所有的错误处理</strong>，当有错误发生时，默默地进行纠正错误的操作。错误处理将在本章后面介绍。 </li>
<li>存储过程<strong>可以提高执行性能</strong>。<br>  在前面曾经讨论过重用以前缓存过的执行计划的内容。存储过程在默认情况下是重用执行计划的，而 SQL Server对其他特殊计划的重用有更多的限制。此外，存储过程计划失效的速度也没有其他特殊计划的失效速度那么快。</li>
<li>使用存储过程的另一个好处是<strong>可以减少网络通信流量</strong>。<br>  客户端应用程序只需要向SQL Server服务器提交存储过程的名称和参数。服务器会处理存储过程的所有代码，向调用者只返回输出结果。对于处理过程的中间步骤，不需要任何往返的网络 通信流量。<br>  作为一个简单的例子，以下代码创建了一个存储过程Sales. usp_GetCustomerOrders。该存储过程接受一个客户ID（@custId）和一个日期范围（@fromDate和@toDate）作为输入参数，返回Sales.Orders表中由指定客户在指定日期范围内所下的订单组成的结果集，同时也将受査询影响的行为作为输出参数(@numRows) 。</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> TSQLFundamentals2008<span class="token punctuation">;</span>

<span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'SALES.usp_GetCustomerOrders'</span><span class="token punctuation">,</span> <span class="token string">'P'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
	<span class="token keyword">DROP</span> <span class="token keyword">PROC</span> Sales<span class="token punctuation">.</span>usp_GetCustomerOrders<span class="token punctuation">;</span> 
GO

<span class="token keyword">CREATE</span> <span class="token keyword">PROC</span> Sales<span class="token punctuation">.</span>usp_GetCustomerOrders
	<span class="token variable">@custId</span> <span class="token keyword">INT</span><span class="token punctuation">,</span>
	<span class="token variable">@fromDate</span> <span class="token keyword">DATETIME</span> <span class="token operator">=</span> <span class="token string">'19000101'</span><span class="token punctuation">,</span>
    <span class="token variable">@toDate</span> <span class="token keyword">DATETIME</span> <span class="token operator">=</span> <span class="token string">'99991231'</span><span class="token punctuation">,</span>
    <span class="token variable">@numRows</span> <span class="token keyword">INT</span> OUTPUT 
<span class="token keyword">AS</span> 
<span class="token keyword">SET</span> NOCOUNT <span class="token keyword">ON</span><span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> orderId<span class="token punctuation">,</span> custId<span class="token punctuation">,</span> empId<span class="token punctuation">,</span> orderDate 
<span class="token keyword">FROM</span> Sales<span class="token punctuation">.</span>Orders 
<span class="token keyword">WHERE</span> custId <span class="token operator">=</span> <span class="token variable">@custId</span> 	
	<span class="token operator">AND</span> orderDate <span class="token operator">>=</span> <span class="token variable">@fromDate</span>	
	<span class="token operator">AND</span> orderDate <span class="token operator">&lt;</span> <span class="token variable">@toDate</span><span class="token punctuation">;</span> 
	
<span class="token keyword">SET</span> <span class="token variable">@numRows</span> <span class="token operator">=</span> @<span class="token variable">@rowCount</span><span class="token punctuation">;</span>
GO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当执行这个存储过程时，如果没有在@fromDate参数中指定任何值，则存储过程将使用默认的1900001；如果没有在@toDate参数中指定任何值，则存储过程将使用默认的99991231。注意关键字OUTPUT的使用，它用于标识参数@numRows是一个输出参数。命令<code>SET NOCOUNT ON</code>用于禁止显示DML语句(如存储过程中的SELECT语句)影响了多少行的消息。<br>下面这个例子执行该存储过程，请求由客户ID等于1的客户在2007年中下过的所有订单。代码将输出参数@numRows的值提取到局部变量@rc中，再返回这个变量的值，以显示查询影响了多少行记录：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DECLARE</span> <span class="token variable">@rc</span> <span class="token keyword">INT</span><span class="token punctuation">;</span>

<span class="token keyword">EXEC</span> Sales<span class="token punctuation">.</span>usp_GetCustomerOrders
	<span class="token variable">@custId</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token variable">@fromDate</span> <span class="token operator">=</span> <span class="token string">'20070101'</span><span class="token punctuation">,</span>
    <span class="token variable">@toDate</span> <span class="token operator">=</span> <span class="token string">'20080101'</span><span class="token punctuation">,</span>	
    <span class="token variable">@numRows</span> <span class="token operator">=</span> <span class="token variable">@rc</span> OUTPUT<span class="token punctuation">;</span>	
    
<span class="token keyword">SELECT</span> <span class="token variable">@rc</span> <span class="token keyword">AS</span> numRows<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当然，这只是一个非常基础的例子，用存储过程能做其他更多的事情。</p>
<hr>
<h4 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h4><p>触发器是一种<strong>特殊的存储过程</strong>，一种<strong>不能被显式执行，而必须依附于一个事件的过程</strong>。<strong>只要事件发生，就会调用触发器，运行它的代码</strong>。SQL Server支持把触发器和两种类型的事件相关联：<strong>数据操作事件(如INSERT)和数据定义事件(如CREATE TABLE)</strong>，和这两种事件关联的触发器分别称为DML触发器和DDL触发器。<br>触发器有很多用途，包括审核数据、实施不能通过约束而实现的完整性规则、实施一定的策略，等等。<br><strong>可以把触发器看成是某个事务的一个组成部分，该事务包含能够触发触发器的事件</strong>。在 触发器的代码中执行ROLLBACK TRAN命令将会导致触发器内发生的所有更改，以及和触发器关联的事务中进行的所有更改都发生回滚。<br>在 SQL Server中，触发器是<strong>按照语句触发的，而不是按照被修改的行而触发</strong>。</p>
<hr>
<h5 id="DML-触发器"><a href="#DML-触发器" class="headerlink" title="DML 触发器"></a>DML 触发器</h5><p>SQL Server支持两种DML触发器：<strong>AFTER触发器</strong>和<strong>INSTEAD OF触发器</strong>。 AFTER触发器是在与之关联的事件完成后才触发的，<strong>只能在持久化的表上定义这种触发器</strong>。 INSTEAD OF触发器的触发是为了代替与之关联的事件操作，<strong>可以在持久化的表或视图上定义这种类型的触发器</strong>。<br>在触发器代码中，可以访问称为<strong>inserted</strong>和<strong>deleted</strong>的两个表，它们<strong>包含导致触发器触发的修改操作而影响的记录行</strong>。inserted表包含当执行INSERT和UPDATE语句时受影响行的<strong>新数据的镜像</strong>。 deleted表则包含当执行DELETE和UPDATE语句时受影响行的<strong>旧数据的镜像</strong>。对于INSTEAD OF触发器，inserted和deleted表包含导致触发器触发的修改操作打算要影响的行。<br>下面演示一个简单的AFTER触发器的例子，对插入到表的数据进行审核。运行以下代码，在tempdb数据库中创建表dbo.T1和表dbo.T1_Audit，用表dbo.T1_Audit保存对T1表的插入进行审核后的信息：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> tempdb<span class="token punctuation">;</span>

<span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'dbo.T1_Audit'</span><span class="token punctuation">,</span> <span class="token string">'U'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
	<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>T1_Audit<span class="token punctuation">;</span> 
<span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'dbo.T1'</span><span class="token punctuation">,</span> <span class="token string">'U'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
	<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>T1<span class="token punctuation">;</span> 
	
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>T1
<span class="token punctuation">(</span>	
    keyCol <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
    dataCol <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>  

<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>T1_Audit
<span class="token punctuation">(</span>	
    audit_lsn <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">IDENTITY</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>	
    dt <span class="token keyword">DATETIME</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span><span class="token punctuation">(</span><span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    login_name sysName <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span><span class="token punctuation">(</span>SUSER_SNAME<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    keyCo1 <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span> 
    dataCol <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在审核表中，audit_Isn列具有标识属性，由它代表审核日志的序列号。dt列代表插入操作发生的日期和时间，并使用<strong>默认的表达式</strong><code>CURRENT_TIMESTAMP</code>。login_name列代表执行插入操作的登录用户的用户名，该插入操作使用默认的表达式<code>SUSER_SNAME()</code>。<br>接下来，运行以下代码，在T1表上创建AFTER INSERT触发器trg_T1_insert_audit，以审核插入操作：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> trg_T1_insert_audit <span class="token keyword">ON</span> dbo<span class="token punctuation">.</span>T1 <span class="token keyword">AFTER</span> <span class="token keyword">INSERT</span>
<span class="token keyword">AS</span>
<span class="token keyword">SET</span> NOCOUNT <span class="token keyword">ON</span><span class="token punctuation">;</span>

<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>T1_Audit<span class="token punctuation">(</span>keyCol<span class="token punctuation">,</span> dataCol<span class="token punctuation">)</span> 	
	<span class="token keyword">SELECT</span> keyCol<span class="token punctuation">,</span> dataCol <span class="token keyword">FROM</span> inserted<span class="token punctuation">;</span>
GO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到，触发器只是简单地把对inserted表的查询结果插入到审核表。在INSERT语句中没有显式列出的审核表中的列值是由前面讲述的几个默认表达式生成的。为了测试触发器，请运行以下代码： </p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>T1<span class="token punctuation">(</span>keyCol<span class="token punctuation">,</span> dataCol<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>T1<span class="token punctuation">(</span>keyCol<span class="token punctuation">,</span> dataCol<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>T1<span class="token punctuation">(</span>keyCol<span class="token punctuation">,</span> dataCol<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token string">'g'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>每条语句成功执行后，都会触发触发器</strong>。接下来，査询审核表：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> audit_lsn<span class="token punctuation">,</span> dt<span class="token punctuation">,</span> login_name<span class="token punctuation">,</span> keyCol<span class="token punctuation">,</span> dataCol
<span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>Tl_Audit<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>只有dt和login_name列的值反映的是你运行插入语句时的日期和时间，以及连接到SQL Server使用的登录用户名。</p>
<hr>
<h5 id="DDL-触发器"><a href="#DDL-触发器" class="headerlink" title="DDL 触发器"></a>DDL 触发器</h5><p>SQL Server 2005引入了对DDL触发器的支持，它们可以用于在数据库中执行审核、增强策略、变化管理等任务。<br>SQL Server支持在两个作用域内创建DDL触发器（<strong>数据库作用域</strong>和<strong>服务器作用域</strong>），这要取决于事件的作用域。例如，对于具有数据库作用域的事件(如CREATE TABLE)，可以创建数据库作用域内的触发器；对于具有服务器作用域的事件（如CREATE DATABASE)，可以创建服务器作用域内的触发器。SQL Server只支持AFTER类型的DDL触发器，而不支持BEFORE或INSTEAD OF类型的DDL触发器。<br>在触发器中，通过查询<code>EVENTDATA</code>函数(该函数<strong>将事件信息作为XML值返回</strong>)，可以<strong>获取关于导致触发器触发的事件信息</strong>。再用<strong>XQuery表达式</strong>从XML值中提取各种事件属性，如提交时间、事件类型、 登录名称等。<br>下面演示一个DDL触发器的例子，对数据库中所有的DDL活动进行审核。首先，运行以下代码，创建一个名为testdb的数据库，再使用它：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> master<span class="token punctuation">;</span> 

<span class="token keyword">IF</span> DB_ID<span class="token punctuation">(</span><span class="token string">'testdb'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> 
	<span class="token keyword">DROP</span> <span class="token keyword">DATABASE</span> testdb<span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> testdb<span class="token punctuation">;</span>
GO
<span class="token keyword">USE</span> testdb<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接下来，运行以下代码，创建表dbo. AuditDDLEvents，用它来保存审核信息：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'dbo.AuditDDLEvents'</span><span class="token punctuation">,</span> <span class="token string">'U'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>	
	<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>AuditDDLEvents<span class="token punctuation">;</span>
	
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>AuditDDLEvents
<span class="token punctuation">(</span>
    audit_lsn <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">IDENTITY</span><span class="token punctuation">,</span>
    pastTime <span class="token keyword">DATETIME</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    eventType sysName <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    loginName sysName <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    schemaName sysName <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    objectName sysName <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    targetObjectName sysName <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    eventData XML <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>	
    <span class="token keyword">CONSTRAINT</span> PK_AuditDDLEvents <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>audit_lsn<span class="token punctuation">)</span> 
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意这个表中有个名为eventData的列，它的<strong>数据类型为XML</strong>。除了可以保存触发器从事件信息中提取到的单个属性，<strong>在eventData列中也可以保存完整的事件信息</strong>。<br>运行以下代码，在数据库上通过<strong>事件组DDL_DATABASE_LEVEL_EVENTS</strong>来创建审核触发器trg_audit_ddl_events，这个事件组代表数据库级上的所有DDL事件：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> trg_audit_ddl_events 	
	<span class="token keyword">ON</span> <span class="token keyword">DATABASE</span> <span class="token keyword">FOR</span> DDL_DATABASE_LEVEL_EVENTS 
<span class="token keyword">AS</span>
<span class="token keyword">SET</span> NOCOUNT <span class="token keyword">ON</span><span class="token punctuation">;</span>

<span class="token keyword">DECLARE</span> <span class="token variable">@eventData</span> <span class="token keyword">AS</span> XML<span class="token punctuation">;</span>
<span class="token keyword">SET</span> <span class="token variable">@eventData</span> <span class="token operator">=</span> eventData<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>AuditDDLEvents<span class="token punctuation">(</span> 	
    postTime<span class="token punctuation">,</span> eventType<span class="token punctuation">,</span> loginName<span class="token punctuation">,</span> schemaName<span class="token punctuation">,</span>	
    objectName<span class="token punctuation">,</span> targetObjectName<span class="token punctuation">,</span> eventData<span class="token punctuation">)</span>
<span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token variable">@eventData.value</span><span class="token punctuation">(</span><span class="token string">'(/EVENT_INSTANCE/PostTime)[1]'</span><span class="token punctuation">,</span> <span class="token string">'VARCHAR(23)'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
       <span class="token variable">@eventData.value</span><span class="token punctuation">(</span><span class="token string">'(/EVENT_INSTANCE/EventType)[1]'</span><span class="token punctuation">,</span> <span class="token string">'sysName'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
       <span class="token variable">@eventData.value</span><span class="token punctuation">(</span><span class="token string">'(/EVENT_INSTANCE/LoginName)[1]'</span><span class="token punctuation">,</span> <span class="token string">'sysName'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
       <span class="token variable">@eventData.value</span><span class="token punctuation">(</span><span class="token string">'(/EVENT_INSTANCE/SchemaName)[1]'</span><span class="token punctuation">,</span> <span class="token string">'sysName'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
       <span class="token variable">@eventData.value</span><span class="token punctuation">(</span><span class="token string">'(/EVENT_INSTANCE/ObjectName)[1]'</span><span class="token punctuation">,</span> <span class="token string">'sysName'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
       <span class="token variable">@eventData.value</span><span class="token punctuation">(</span><span class="token string">'(/EVENT_INSTANCE/TargetObjectName)[1]'</span><span class="token punctuation">,</span> <span class="token string">'sysName'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
       <span class="token variable">@eventData</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
GO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>触发器代码首先把从<code>EVENTDATA</code>函数获得的事件信息保存到变量@eventData中。接着<strong>使用 Xquery表达式</strong>，通过<code>.value</code>方法提取事件信息的各属性，并把这些属性和完整事件信息的XML值作为新行插入到审核表中。<br>为了测试这个触发器，运行以下包含了几条DDL语句的代码： </p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>T1<span class="token punctuation">(</span>Col1 <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>T1 <span class="token keyword">ADD</span> co12 <span class="token keyword">INT</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>T1 <span class="token keyword">ALTER</span> <span class="token keyword">COLUMN</span> Col2 <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">NONCLUSTERED</span> <span class="token keyword">INDEX</span> idx1 <span class="token keyword">ON</span> dbo<span class="token punctuation">.</span>T1<span class="token punctuation">(</span>co12<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>接着，执行以下代码查询审核表：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> dbo<span class="token punctuation">.</span>AuditDDLEvents<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>操作完成后，运行以下代码以清理测试数据：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> master<span class="token punctuation">;</span>
<span class="token keyword">IF</span> DB_ID<span class="token punctuation">(</span><span class="token string">'testdb'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> 	
	<span class="token keyword">DROP</span> <span class="token keyword">DATABASE</span> testdb<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<hr>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>SQL Server提供了在T-SQL代码中用于处理错误的工具。进行错误处理的主要工具是种称为<code>TRY...CATCH</code>的结构，它是在SQL Server 2005中引入的。SQL Server也提供了 一组函数，调用它们可以获得 有关错误的信息。本节将先用一个基本的例子作为开始， 演示<code>TRY...CATCH</code>结构的使用，接着再用一个更详细的例子来演示错误函数的用法。<br>当使用<code>TRY...CATCH</code>结构时，通常是把T-SQL代码放在TRY块中（放在<code>BEGIN TRY</code>和<code>END TRY</code>关键字之间），而把错误处理代码放在紧接其后的CATCH块中（放在<code>BEGIN CATCH</code>和<code>END CATCH</code>关键字之间）。如果TRY块中的代码没有错误， SQL Server就 会简单地忽 略 CATCH块。如果TRY块发生了错误，流程控制就会转移到相应的CATCH块。注意，如果TRY…CATCH块捕获并处理了错误，则对于调用者来说，它不会看到有错误发生。<br>运行以下代码，它演示了在TRY块中没有发生错误的情形：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">BEGIN</span> TRY 	
	<span class="token keyword">PRINT</span> <span class="token number">10</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>	
	<span class="token keyword">PRINT</span> <span class="token string">'No error'</span><span class="token punctuation">;</span>
<span class="token keyword">END</span> TRY 
<span class="token keyword">BEGIN</span> CATCH 	
	<span class="token keyword">PRINT</span> <span class="token string">'Error'</span><span class="token punctuation">;</span>
<span class="token keyword">END</span> CATCH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p> TRY块中的所有代码都成功完成：因此，CATCH块将被忽略。接下来，运行一段类似的代码，但这次有条语句中除法运算的除数为0，这会发生错误： </p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">BEGIN</span> TRY 	
	<span class="token keyword">PRINT</span> <span class="token number">10</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">PRINT</span> <span class="token string">'NO error'</span><span class="token punctuation">;</span>
<span class="token keyword">END</span> TRY 
<span class="token keyword">BEGIN</span> CATCH 	
	<span class="token keyword">PRINT</span> <span class="token string">'Error'</span><span class="token punctuation">;</span>
<span class="token keyword">END</span> CATCH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当TRY块中第一条PRINT语句因为除数为零而引发错误时，控制流程就会转移到相应的CATCH块。 而原来TRY块中的第二条PRINT语句则不会执行。<br>通常，在CATCH块中进行的错误处理会涉及检査导致错误的原因，采取某种处理操作SQL Server可以通过一组函数来反馈有关错误的信息。<code>ERROR_NUMBER</code>函数将<strong>返回一个整数，代表错误的错误号，这可能算是最重要的一个错误函数</strong>。CATCH块通常包含一些流程控制代码，通过检査错误号来决定应该采取什么处理操作。<code>ERROR_MESSAGE</code>函数将<strong>返回错误的消息文本</strong>。<strong>要得到错误号和错误消息的列表，可以查询sys.messages目录视图</strong>。<code>ERROR_SEVERITY</code>和<code>ERROR_STATE</code>函数可以分别返回<strong>错误的严重级别</strong>和<strong>状态号</strong>。<code>ERROR_LINE</code>函数可以<strong>返回发生错误的行号</strong>。最后，<code>ERROR_PROCEDURE</code>函数可以<strong>返回发生错误的存储过程或触发器的名称</strong>，如果在过程中没有发生错误，则返回NULL。<br>接下来演示一个更详细的，使用错误函数进行错误处理的例子。首先运行以下代码，在tempdb数据库中创建一个名为dbo.Employees的表： </p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">USE</span> tempdb<span class="token punctuation">;</span>

<span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'dbo.Employees'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> 	
	<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Employees<span class="token punctuation">;</span> 
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> dbo<span class="token punctuation">.</span>Employees 
<span class="token punctuation">(</span>	
    empId <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>	
    empName <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>	
    mgrId <span class="token keyword">INT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span> 	
    <span class="token keyword">CONSTRAINT</span> PK_Employees <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>empId<span class="token punctuation">)</span><span class="token punctuation">,</span>	
    <span class="token keyword">CONSTRAINT</span> CHK_Employees_empid <span class="token keyword">CHECK</span><span class="token punctuation">(</span>empid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>	
    <span class="token keyword">CONSTRAINT</span> FK_Employees_Employees
    	<span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>mgrId<span class="token punctuation">)</span> 
    		<span class="token keyword">REFERENCES</span> dbo<span class="token punctuation">.</span> Employees<span class="token punctuation">(</span>empId<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>以下代码在TRY块中向Employees表插入一个新行，如果发生错误，则演示如何在CATCH块中检査<code>ERROR_NUMBER</code>函数，以识别发生了什么错误。代码也会打印输出其他错误函数的返回值，以简单地演示在发生错误时有什么可以利用的信息：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">BEGIN</span> TRY 	
	<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>Employees<span class="token punctuation">(</span>empId<span class="token punctuation">,</span> empName<span class="token punctuation">,</span> mgrId<span class="token punctuation">)</span>
    	<span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'Empl'</span><span class="token punctuation">,</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 	
    <span class="token comment">-- Also try with empId = 0, 'A', NULL </span>
<span class="token keyword">END</span> TRY 
<span class="token keyword">BEGIN</span> CATCH 	
	<span class="token keyword">IF</span> ERROR_NUMBER<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2627</span> 	
	<span class="token keyword">BEGIN</span> 		
		<span class="token keyword">PRINT</span> <span class="token string">'	Handling PK violation...'</span><span class="token punctuation">;</span>	
	<span class="token keyword">END</span>	
	<span class="token keyword">ELSE</span> <span class="token keyword">IF</span> ERROR_NUMBER<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">547</span>
    <span class="token keyword">BEGIN</span>
    	<span class="token keyword">PRINT</span> <span class="token string">'	Handling CHECK/FK constraint violation...'</span><span class="token punctuation">;</span>	
    <span class="token keyword">END</span>	
    <span class="token keyword">ELSE</span> <span class="token keyword">IF</span> ERROR_NUMBER<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">515</span>
    <span class="token keyword">BEGIN</span> 		
    	<span class="token keyword">PRINT</span> <span class="token string">'	Handling NULL violation...'</span><span class="token punctuation">;</span>	
    <span class="token keyword">END</span>	
    <span class="token keyword">ELSE</span> <span class="token keyword">IF</span> ERROR_NUMBER<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">245</span>
    <span class="token keyword">BEGIN</span>
    	<span class="token keyword">PRINT</span> <span class="token string">'	Handling conversion error...'</span><span class="token punctuation">;</span>
    <span class="token keyword">END</span>	
    <span class="token keyword">ELSE</span>
    <span class="token keyword">BEGIN</span>
        <span class="token keyword">PRINT</span> <span class="token string">'	Handling unknown error...'</span><span class="token punctuation">;</span>	
    <span class="token keyword">END</span>
    
    <span class="token keyword">PRINT</span> <span class="token string">'	Error Number: '</span> <span class="token operator">+</span> CAST<span class="token punctuation">(</span>ERROR_NUMBER<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">PRINT</span> <span class="token string">'	Error Message: '</span> <span class="token operator">+</span> ERROR_MESSAGE<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
    <span class="token keyword">PRINT</span> <span class="token string">'	Error Severity: '</span> <span class="token operator">+</span> CAST<span class="token punctuation">(</span>ERROR_SEVERITY<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
    <span class="token keyword">PRINT</span> <span class="token string">'Error State: '</span> <span class="token operator">+</span> CAST<span class="token punctuation">(</span>ERROR_STATE<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
    <span class="token keyword">PRINT</span> <span class="token string">'Error Line: '</span> <span class="token operator">+</span> CAST<span class="token punctuation">(</span>ERROR_LINE<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
    <span class="token keyword">PRINT</span> <span class="token string">'Error Proc: '</span> <span class="token operator">+</span> <span class="token keyword">COALESCE</span><span class="token punctuation">(</span>ERROR_PROCEDURE<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'Not within proc'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    
<span class="token keyword">END</span> CATCH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当第一次运行这段代码时，新的行可以成功地插入到Employees表，因此将忽略CATCH 块。<br>当第二次运行同一段代码时，INSERT语句将会失败，流程控制转移到CATCH块，可以识别出发生的错误是主键冲突。<br>要査看其他错误的效果，可以用0、’A’、以及NULL作为雇员ID来运行这段代码。<br>出于演示的目的，当识别出错误以后，采用PRNT语句作为错误处理操作。当然，错误处理通常包含的不会仅仅只是打印输出一条消息，指示遇到了什么错误。<br>注意，<strong>可以创建一个存储过程，以封装可以重用的错误处理代码</strong>，如下所示：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">IF</span> OBJECT_ID<span class="token punctuation">(</span><span class="token string">'dbo.usp_err_messages'</span><span class="token punctuation">,</span> <span class="token string">'P'</span><span class="token punctuation">)</span> <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> 
	<span class="token keyword">DROP</span> <span class="token keyword">PROC</span> dbo<span class="token punctuation">.</span>usp_err_messages<span class="token punctuation">;</span>
GO

<span class="token keyword">CREATE</span> <span class="token keyword">PROC</span> dbo<span class="token punctuation">.</span>usp_err_messages 
<span class="token keyword">AS</span>
<span class="token keyword">SET</span> NOCOUNT <span class="token keyword">ON</span><span class="token punctuation">;</span> 

<span class="token keyword">IF</span> ERROR_NUMBER<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2627</span> 
<span class="token keyword">BEGIN</span> 
	<span class="token keyword">PRINT</span> <span class="token string">'Hand]ing PK violation...'</span><span class="token punctuation">;</span>
<span class="token keyword">END</span>
<span class="token keyword">ELSE</span> <span class="token keyword">IF</span> ERROR_NUMBER<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">547</span> 
<span class="token keyword">BEGIN</span> 
	<span class="token keyword">PRINT</span> <span class="token string">'Handling CHECK/FK constraint violation...'</span><span class="token punctuation">;</span>
<span class="token keyword">END</span> 
<span class="token keyword">ELSE</span> <span class="token keyword">IF</span> ERROR_NUMBER<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">515</span> 
<span class="token keyword">BEGIN</span> 
	<span class="token keyword">PRINT</span> <span class="token string">'Handling NULL violation...'</span><span class="token punctuation">;</span>
<span class="token keyword">END</span>
<span class="token keyword">ELSE</span> <span class="token keyword">IF</span> ERROR_NUMBER<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">245</span> 
<span class="token keyword">BEGIN</span> 
	<span class="token keyword">PRINT</span> <span class="token string">'Handling conversion error...'</span><span class="token punctuation">;</span>
<span class="token keyword">END</span> 
<span class="token keyword">ELSE</span> 
<span class="token keyword">BEGIN</span> 
	<span class="token keyword">PRINT</span> <span class="token string">'Handling unknown error...'</span><span class="token punctuation">;</span>
<span class="token keyword">END</span> 

<span class="token keyword">PRINT</span> <span class="token string">'Error Number: '</span> <span class="token operator">+</span> CAST<span class="token punctuation">(</span>ERROR_NUMBER<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">PRINT</span> <span class="token string">'Error Message: '</span> <span class="token operator">+</span> ERROR_MESSAGE<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">PRINT</span> <span class="token string">'Error Severity: '</span> <span class="token operator">+</span> CAST<span class="token punctuation">(</span>ERROR_SEVERITY<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">PRINT</span> <span class="token string">'Error State: '</span> <span class="token operator">+</span> CAST<span class="token punctuation">(</span>ERROR_STATE<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">PRINT</span> <span class="token string">'Error Line: '</span> <span class="token operator">+</span> CAST<span class="token punctuation">(</span>ERROR_LINE<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">PRINT</span> <span class="token string">'Error Proc: '</span> <span class="token operator">+</span> <span class="token keyword">COALESCE</span><span class="token punctuation">(</span>ERROR_PROCEDURE<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'Not within proc'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
GO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在 CATCH块中，只需要简单地执行这个存储过程：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">BEGIN</span> TRY 
	<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> dbo<span class="token punctuation">.</span>Employees<span class="token punctuation">(</span>empId<span class="token punctuation">,</span> empName<span class="token punctuation">,</span> mgrId<span class="token punctuation">)</span> 
		<span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'Empl'</span><span class="token punctuation">,</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">END</span> TRY 
<span class="token keyword">BEGIN</span> CATCH 
	<span class="token keyword">EXEC</span> dbo<span class="token punctuation">.</span>usp_err_messages<span class="token punctuation">;</span> 
<span class="token keyword">END</span> CATCH<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这样一来，就可以只在数据库中的一个地方对可重用的错误处理代码进行维护。 </p>
<hr>
<h2 id="SSMS使用技巧"><a href="#SSMS使用技巧" class="headerlink" title="SSMS使用技巧"></a>SSMS使用技巧</h2><ol>
<li>如果在SQL Server Management Studio中编写代码时<strong>需要查找关于某个语法元素的帮助</strong>，则可以先确保光标位于该代码元素的某处，再按<code>Shift</code>+<code>F1</code>组合键。这样将加载联机丛书，并为那个元素打开其语法页（假设存在这样 的帮助条目）。</li>
<li>当<strong>复制或剪切代码</strong>时，如果在突出选择代码之前，按下<code>ALt</code>键，井在选择过程中ー直按住At键，则<strong>可以选择任意一个矩形区域，而不必非得从代码行的起始位置进行选择</strong>，<strong>这在代码注释行特别有用</strong>。</li>
<li>如果把一个表的 Columns（列）文件夹拖到查询窗口，SQL Server将列出这个表的所有列，列名之间用逗号隔开。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hunter1023.github.io/2021/04/16/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hunter">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talk is cheap">
      <meta itemprop="description" content="Tough times never last, but tough people do.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Talk is cheap">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/16/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">多线程详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-17 01:45:12" itemprop="dateCreated datePublished" datetime="2021-04-17T01:45:12+08:00">2021-04-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-23 23:29:13" itemprop="dateModified" datetime="2025-01-23T23:29:13+08:00">2025-01-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%85%A8%E6%A0%88/" itemprop="url" rel="index"><span itemprop="name">Java全栈</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%85%A8%E6%A0%88/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h2><ul>
<li><p><strong>普通方法调用和多线程</strong></p>
<p>  普通方法调用：主线程调用<code>run()</code>方法，<strong>主线程执行</strong><code>run()</code>；<strong>只有主线程一条执行路径</strong></p>
<p>  <strong>多线程</strong>：主线程调用<code>start()</code>方法，<strong>子线程执行</strong><code>run()</code>；多条执行路径，主线程和子线程<strong>并行交替执行</strong></p>
</li>
<li><p>程序、<strong>进程Process</strong>和<strong>线程Thread</strong></p>
<ul>
<li>程序是指令和数据的有序集合，是一个静态的概念</li>
</ul>
</li>
<li><p>进程是程序的<strong>一次执行过程</strong>，是一个动态的概念。<strong>进程是资源分配的单位</strong>。</p>
<ul>
<li><p><strong>一个进程中可以包含若干个线程</strong>，<strong>线程是CPU调度和执行的单位</strong>。</p>
<p>  如视频中同时听声音，看图像，看弹幕。</p>
</li>
</ul>
<p>  很多多线程是模拟出来的，<strong>真正的多线程</strong>是指<strong>有多个CPU，如服务器</strong>。
  </p>
</li>
<li><p>在<strong>程序运行时</strong>，即使没有自己创建线程，<strong>后台也会有多个线程</strong>，如<strong>主线程</strong>，<strong>gc线程</strong></p>
</li>
<li><p><code>main()</code>称之为<strong>主线程</strong>，为<strong>系统的入口</strong>，用于<strong>执行整个程序</strong></p>
</li>
<li><p>在一个进程中，如果开辟了多个线程，<strong>线程的运行由调度器安排调度</strong>，调度器是与操作系统紧密相关的，<strong>先后顺序是不能人为干预的</strong>。</p>
</li>
<li><p><strong>对同一份资源操作</strong>时，会存在<strong>资源抢夺</strong>的问题，需要加入<strong>并发控制</strong></p>
</li>
<li><p>线程会带来额外的开销，如<strong>CPU调度时间</strong>，<strong>并发控制开销</strong></p>
</li>
<li><p>每个线程<strong>在自己的工作内存交互</strong>，<strong>内存控制不当会造成数据不一致</strong></p>
</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/04/16/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hunter1023.github.io/2021/04/15/%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hunter">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talk is cheap">
      <meta itemprop="description" content="Tough times never last, but tough people do.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Talk is cheap">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/15/%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">异常机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-16 00:45:46" itemprop="dateCreated datePublished" datetime="2021-04-16T00:45:46+08:00">2021-04-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-23 23:29:13" itemprop="dateModified" datetime="2025-01-23T23:29:13+08:00">2025-01-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%85%A8%E6%A0%88/" itemprop="url" rel="index"><span itemprop="name">Java全栈</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%85%A8%E6%A0%88/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h2><p>软件程序在运行过程中，可能会遇到各种异常问题<code>Exception</code>，<strong>影响正常的程序执行流程</strong>。如： </p>
<ul>
<li>文件找不到</li>
<li>网络连接失败</li>
<li>非法参数</li>
</ul>
<hr>
<h2 id="异常的简单分类"><a href="#异常的简单分类" class="headerlink" title="异常的简单分类"></a>异常的简单分类</h2><ul>
<li><p><strong>检查性</strong>异常</p>
<p>  <strong>最具代表性</strong>的检查性异常是<strong>用户错误或问题引起的异常</strong>。这是程序员<strong>无法预见的</strong>，在<strong>编译时不能被简单地忽略</strong>。例如：要<strong>打开一个不存在的文件</strong>。</p>
</li>
<li><p><strong>运行时</strong>异常</p>
<p>  运行时异常是可能被程序员避免的异常，<strong>可以在编译时被忽略</strong>。</p>
</li>
<li><p><strong>错误Error</strong></p>
<p>  错误不是异常，而是<strong>脱离程序员控制</strong>的<strong>问题</strong>。错误<strong>在代码中通常被忽略</strong>。例如：<strong>栈溢出</strong>时，错误就发生了，这在编译时也检查不到。</p>
</li>
</ul>
<hr>
<h2 id="异常体系结构"><a href="#异常体系结构" class="headerlink" title="异常体系结构"></a>异常体系结构</h2><ul>
<li>Java<strong>把异常当作对象</strong>来处理，并定义一个基类<code>java.lang.Throwable</code><strong>作为所有异常的超类</strong></li>
<li>Java API中已经定义了许多异常类，这些异常分为<strong>两大类</strong>：<strong>错误Error</strong>和<strong>异常Exception</strong></li>
</ul>
<hr>
<h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><ul>
<li><p>Error类对象<strong>由JVM生成并抛出</strong>，大<strong>多数错误与代码编写者所执行的操作无关</strong>。</p>
</li>
<li><p>Java<strong>虚拟机运行错误(Virtual MachineError)</strong></p>
<p>  当JVM不再有继续执行操作所需的<strong>内存资源</strong>时，将出现OutOfMemoryError。这样的情况发生时，<strong>JVM一般会选择线程终止</strong>。</p>
</li>
<li><p>还有的Error<strong>发生在虚拟机试图执行应用时</strong></p>
<ul>
<li>类定义错误(NoClassDefFoundError)</li>
<li>链接错误(LinkageError)</li>
</ul>
<p>  这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。</p>
</li>
</ul>
<hr>
<h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><ul>
<li><p>在Exception分支中有一个重要的子类RuntimeException</p>
<ul>
<li>ArrayIndexOutOfBoundsException</li>
<li>NullPointerException</li>
<li>ArithmeticException</li>
<li>MissingResourceException</li>
<li>ClassNotFoundException</li>
</ul>
<p>  这些异常一般是由<strong>程序逻辑错误引起</strong>的，程序应该从逻辑角度尽可能避免这类异常的发生。</p>
</li>
</ul>
<hr>
<h2 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h2><p>异常处理的五个关键字：</p>
<ol>
<li><p><code>try</code></p>
</li>
<li><p><code>catch</code></p>
</li>
<li><p><code>finally</code></p>
</li>
<li><p><code>throw</code></p>
<p> <strong>主动抛出</strong>异常，<strong>一般在方法中使用</strong>。</p>
</li>
<li><p><code>throws</code></p>
<p> 如果<strong>方法中出现处理不了的异常</strong>，<strong>在方法上抛出异常</strong></p>
</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// IDEA中，Ctrl + ALt + T 可以对选中的代码迅速创建异常处理</span>
<span class="token keyword">try</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 监控区域</span>
    <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ArithmeticException</span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// catch 想要捕获的异常类型</span>
    
<span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果要捕捉多种异常，要按范围从小到大排序</span>
    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印错误的栈信息</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
    
<span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 可以不要</span>
    <span class="token comment">// 里边的内容，无论是否捕获异常，都执行</span>
<span class="token punctuation">&#125;</span>


<span class="token comment">/* 如果方法中出现处理不了的异常，在方法上抛出异常
	算数异常属于运行时异常，实际会自行抛出，不用特意写出throws，当前只是为了举例
*/</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> test <span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ArithmeticException</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ArithmeticException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//主动抛出异常，一般在方法中使用</span>
    <span class="token punctuation">&#125;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token operator">/</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><ul>
<li><p>使用Java<strong>内置的异常类</strong>可以描述在编程时出现的<strong>大部分异常情况</strong>。除此之外，用户还可以自定义异常。<strong>用户自定义异常类，只需继承Exception类即可</strong>。</p>
</li>
<li><p>自定义异常类的步骤</p>
<ol>
<li>创建自定义异常类</li>
<li>在方法中通过<strong>throw关键字</strong>抛出异常对象</li>
<li>如果当前抛出异常的方法中处理异常，可以使用try-catch语句捕获并处理；否则在方法的声明处通过throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作</li>
<li>在出现异常方法的调用者中捕获并处理异常</li>
</ol>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 自定义的异常类</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyException</span> <span class="token keyword">extends</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> detail<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">MyException</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>detail <span class="token operator">=</span> a<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 异常的打印信息</span>
        <span class="token keyword">return</span> <span class="token string">"MyException&#123;"</span> <span class="token operator">+</span>
                <span class="token string">"detail="</span> <span class="token operator">+</span> detail <span class="token operator">+</span>
                <span class="token char">'&#125;'</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>



<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span>

    <span class="token comment">// 可能会存在异常的方法</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">MyException</span> <span class="token punctuation">&#123;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"传递的参数为："</span> <span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">></span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">MyException</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 抛出</span>
        <span class="token punctuation">&#125;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"OK"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
            <span class="token function">test</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">MyException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// 增加一些处理异常的代码</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"MyException："</span> <span class="token operator">+</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 会被调用toString方法</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h2 id="实际应用中的经验总结"><a href="#实际应用中的经验总结" class="headerlink" title="实际应用中的经验总结"></a>实际应用中的经验总结</h2><ul>
<li>处理<strong>运行时异常</strong>时，采用逻辑去<strong>合理规避</strong>，同时<strong>辅助<code>try-catch</code>处理</strong></li>
<li>在<strong>多重catch块</strong>后面，可以加一个<code>catch(Exception e)</code>来<strong>处理可能被遗漏的异常</strong></li>
<li>对于<strong>不确定的代码</strong>，也可以加上<code>try-catch</code>，处理<strong>潜在的异常</strong></li>
<li>尽量去<strong>处理异常</strong>，切忌只是简单调用<code>printStackTrace()</code>打印输出，没有多少意义</li>
<li>具体如何处理异常，要根据不同的业务需求和异常类型决定</li>
<li><strong>尽量添加<code>finally</code>语句</strong>去<strong>释放占用的资源</strong></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hunter1023.github.io/2021/04/09/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hunter">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talk is cheap">
      <meta itemprop="description" content="Tough times never last, but tough people do.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Talk is cheap">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/09/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">面向对象编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-10 01:23:02" itemprop="dateCreated datePublished" datetime="2021-04-10T01:23:02+08:00">2021-04-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-23 23:29:13" itemprop="dateModified" datetime="2025-01-23T23:29:13+08:00">2025-01-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%85%A8%E6%A0%88/" itemprop="url" rel="index"><span itemprop="name">Java全栈</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%85%A8%E6%A0%88/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h2><ul>
<li>面向对象编程 (<strong>OOP</strong>, Object-Oriented Programming)</li>
<li>面向对象的本质就是<strong>以类的方式组织代码，以对象的方式组织(封装)数据</strong></li>
<li>抽象</li>
<li>三大特性<ul>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ul>
</li>
</ul>
<hr>
<h2 id="类与对象的关系"><a href="#类与对象的关系" class="headerlink" title="类与对象的关系"></a>类与对象的关系</h2><ul>
<li><p>类是一种抽象的数据类型，它是<strong>对某一类事物的整体描述&#x2F;定义</strong>，但是并不能代表某一个具体的事物</p>
</li>
<li><p>对象是抽象概念的具体实例</p>
</li>
<li><p>从<strong>认识论</strong>的角度是<strong>先有对象后有类</strong>。对象是具体的事物，类是对对象的抽象。</p>
</li>
<li><p>从<strong>代码运行</strong>角度是<strong>先有类后有对象</strong>。类是对象的模板。</p>
</li>
</ul>
<hr>
<h2 id="创建与初始化对象"><a href="#创建与初始化对象" class="headerlink" title="创建与初始化对象"></a>创建与初始化对象</h2><ul>
<li><p>使用<strong>new关键字</strong>创建对象</p>
<p>  创建对象除了会<strong>分配内存空间</strong>之外，还会<strong>给创建好的对象进行默认的初始化</strong>以及<strong>对类中构造器的调用</strong>。</p>
</li>
</ul>
<hr>
<h3 id="构造器详解"><a href="#构造器详解" class="headerlink" title="构造器详解"></a>构造器详解</h3><ul>
<li><p>类中的<strong>构造器</strong>也称为<strong>构造方法</strong>，<strong>创建对象的时候必定会被调用</strong>。</p>
<ul>
<li><p><strong>使用new关键字，本质是在调用构造器</strong>；</p>
</li>
<li><p>一个类中即使<strong>什么内容都不写</strong>，它也<strong>会存在一个构造方法</strong>；</p>
</li>
</ul>
</li>
<li><p>构造器的两个特点：</p>
<ol>
<li>必须<strong>和类的名字相同</strong></li>
<li>必须<strong>没有返回类型</strong>，也<strong>不能写void</strong></li>
</ol>
</li>
<li><p><strong>一旦定义了有参数的构造方法，无参构造方法必须显式定义才会有效</strong></p>
</li>
</ul>
<hr>
<h2 id="创建对象的内存分析"><a href="#创建对象的内存分析" class="headerlink" title="创建对象的内存分析"></a>创建对象的内存分析</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>hunter<span class="token punctuation">.</span>oop</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Pet</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"叫了一声"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>hunter<span class="token punctuation">.</span>oop</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Application</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">Pet</span> dog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Pet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dog<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"旺财"</span><span class="token punctuation">;</span>
        dog<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
        dog<span class="token punctuation">.</span><span class="token function">shout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Pet</span> cat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Pet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://i.loli.net/2021/04/11/xkcVIFANoUKOLfG.png" alt="创建对象的内存示意图"></p>
<p><a href="https://hunter1023.github.io/2021/04/02/Java%E6%95%B0%E7%BB%84%E8%AF%A6%E8%A7%A3/#Java%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90">Java内存分析</a></p>
<hr>
<pre><code>## 封装
</code></pre>
<ul>
<li><p>程序设计要追求<strong>高内聚、低耦合</strong></p>
<ul>
<li><strong>高内聚</strong>：尽可能类的<strong>每个方法只完成一件事</strong></li>
<li><strong>低耦合</strong>：尽可能减少类的中的<strong>方法调用其他方法</strong></li>
</ul>
<p>  从<strong>类的角度</strong>看：减少类内部对其他类的调用</p>
<p>  从<strong>功能模块角度</strong>看：减少模块之间的交互复杂度</p>
</li>
<li><p><strong>封装</strong></p>
<p>  封装就是对<strong>方法的实现细节进行隐藏</strong>。它是一种<strong>防止外界调用端去访问对象内部实现细节</strong>的手段。</p>
</li>
<li><p><strong>属性私有，提供公开接入的方法(getters&#x2F;setters)</strong></p>
<p>  <strong>代码更容易理解与维护，同时加强了代码的安全性。</strong></p>
</li>
</ul>
<hr>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li><p>继承的本质是<strong>对某一批类的抽象</strong>，从而实现对现实世界更好的建模。</p>
</li>
<li><p>子类是父类的扩展(extends)</p>
<ul>
<li>子类继承了父类，就会<strong>拥有父类的全部方法和属性(private除外)</strong></li>
<li><strong>被<code>final</code>修饰的类无法被继承</strong></li>
</ul>
</li>
<li><p>继承是类和类之间的一种关系，此外还有依赖、组合、聚合等</p>
</li>
<li><p>Object类</p>
<p>  在Java中，<strong>所有的类都默认直接或间接继承Object类</strong>。</p>
</li>
<li><p>Java<strong>类只有单继承，没有多继承</strong></p>
<p>  <strong>一个子类只能有一个父类</strong></p>
</li>
</ul>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><ul>
<li><p><code>super();</code></p>
<p>  调用<strong>父类的构造器</strong>，必须要在<strong>子类构造器的第一行</strong>。</p>
<p>  <strong>如果父类定义了有参数的构造方法，且没有显式定义无参构造方法，那么子类就不能定义无参构造</strong>。<strong>因此定义有参构造方法之前，最好先显式定义无参构造。</strong></p>
</li>
<li><p>super<strong>只能出现在子类的方法或构造方法中</strong></p>
</li>
<li><p>不能同时用<code>super</code>和<code>this</code>调用构造方法</p>
<p>  <strong>因为两者都要求自己在第一行，会冲突。</strong></p>
</li>
</ul>
<h4 id="super和this的比较"><a href="#super和this的比较" class="headerlink" title="super和this的比较"></a>super和this的比较</h4><ul>
<li><p>this表示本身调用者这个对象</p>
</li>
<li><p>super表示父类对象，<strong>只能在继承后使用</strong></p>
</li>
<li><p>构造方法</p>
<p>  <code>this()</code>：本类的构造方法，可以简化代码的编写</p>
<p>  <code>super()</code>：父类的构造方法</p>
</li>
</ul>
<hr>
<h3 id="重写-Override"><a href="#重写-Override" class="headerlink" title="重写 Override"></a>重写 Override</h3><p><a href="https://hunter1023.github.io/2021/03/30/Java%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD">方法的重载</a></p>
<p>重写<strong>需要有继承关系</strong>，是<strong>子类对父类非静态的方法进行重写</strong>，与属性无关。</p>
<ul>
<li><p>方法名必须相同</p>
</li>
<li><p>参数列表必须相同</p>
</li>
<li><p>修饰符：<strong>范围可以扩大，但不能缩小</strong></p>
<p>  public &gt; protected &gt; default &gt; private</p>
</li>
<li><p><strong>抛出的异常：范围可以缩小，但不能扩大</strong></p>
<p>  Exception &gt; ClassNotFoundException</p>
</li>
<li><p><strong>静态方法和非静态方法区别很大</strong></p>
<ul>
<li><p><strong>静态</strong>方法：方法的调用只和<strong>左边定义的数据类型</strong>有关（不会被重写）</p>
  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A.test()"</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>


<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"B.test()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>


<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Application</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        
        <span class="token class-name">B</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        b<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印 B.test()</span>
        
        <span class="token class-name">A</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        a<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印 A.test()</span>
    <span class="token punctuation">&#125;</span>
    
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>非静态方法：<strong>重写</strong></p>
  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A.test()"</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>


<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"B.test()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>


<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Application</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        
        <span class="token class-name">B</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        b<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印 B.test()</span>
        
        <span class="token class-name">A</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        a<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印 B.test()</span>
    <span class="token punctuation">&#125;</span>
    
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p><strong>为什么需要重写</strong></p>
<p>  父类的功能子类不一定需要或不一定满足</p>
</li>
</ul>
<hr>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul>
<li><p>多态就是同一方法可以根据发送对象的不同而采用多种不同的行为方式</p>
<p>  一个对象的<strong>实际类型是确定的</strong>，但<strong>指向的引用类型可以不确定</strong>。</p>
  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Student extends Person</span>
<span class="token class-name">Student</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token class-name">Person</span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 父类可以指向子类，但不能调用子类独有的方法</span>
<span class="token class-name">Object</span> s3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

s2<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果子类重写了父类的方法，会执行子类的方法</span>
<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">)</span> s2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果是子类有的，而父类没有的方法，必须进行强制类型转换</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</li>
<li><p>一个对象的实际类型是确定的，但可以指向对象的引用的类型有很多</p>
</li>
<li><p>多态存在的条件</p>
<ol>
<li>有继承关系</li>
<li>子类重写了父类方法</li>
<li><strong>父类引用指向子类对象</strong> <code>Father f = new Son();</code></li>
</ol>
</li>
<li><p><strong>多态是方法的多态</strong>，属性没有多态</p>
<ol>
<li><strong>静态方法(static)<strong>的调用只和</strong>左边定义的数据类型</strong>有关</li>
<li><strong>常量(final)<strong>的调用也只和</strong>左边定义的数据类型</strong>有关</li>
<li><strong>private方法</strong>的调用也只和<strong>左边定义的数据类型</strong>有关</li>
</ol>
</li>
</ul>
<hr>
<h3 id="关键词-instanceof"><a href="#关键词-instanceof" class="headerlink" title="关键词 instanceof"></a>关键词 instanceof</h3><p>关键词<code>instanceof</code>用于判断一个对象是什么类型</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Object > String</span>
<span class="token comment">// Object > Person > Teacher</span>
<span class="token comment">// Object > Person > Student</span>
<span class="token class-name">Object</span> object <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>object <span class="token keyword">instanceof</span> <span class="token class-name">Student</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>object <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>object <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>object <span class="token keyword">instanceof</span> <span class="token class-name">Teacher</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>object <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>

<span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person <span class="token keyword">instanceof</span> <span class="token class-name">Student</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>person <span class="token keyword">instanceof</span> <span class="token class-name">Teacher</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
<span class="token comment">// System.out.println(person instanceof String); // 编译报错</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>System.out.println(X instanceof Y);</code>语句能否编译通过<strong>要看X与Y之间是否有继承关系</strong>。</p>
<hr>
<h3 id="引用类型的类型转换"><a href="#引用类型的类型转换" class="headerlink" title="引用类型的类型转换"></a>引用类型的类型转换</h3> <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Person</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">)</span> obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">go</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 要使用【子类特有的方法】需要【强制类型转换】</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ul>
<li>引用类型的<strong>类型转换可能会丢失自己本来的一些方法</strong>：<ul>
<li><strong>子类转换为父类</strong>是向上转型</li>
<li><strong>父类转换为子类</strong>为向下转型，属于<strong>强制转换</strong></li>
</ul>
</li>
<li>引用类型的类型转换是<strong>为了方便方法的调用</strong>，<strong>减少代码冗余</strong></li>
</ul>
<hr>
<h2 id="static关键字详解"><a href="#static关键字详解" class="headerlink" title="static关键字详解"></a>static关键字详解</h2><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">publica <span class="token keyword">class</span> <span class="token class-name">ClassName</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#123;</span>
        <span class="token comment">// 代码块（匿名代码块）</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 静态代码块</span>
    <span class="token punctuation">&#125;</span>
    
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p><strong>静态代码块</strong></p>
<p>  <strong>加载类</strong>时就<strong>执行(只执行一次)</strong></p>
</li>
<li><p><strong>匿名代码块</strong></p>
<ul>
<li><strong>创建对象</strong>时<strong>自动创建</strong>，且<strong>在构造器之前创建</strong></li>
<li>运用场景：<strong>赋一些初始值</strong></li>
</ul>
</li>
</ul>
<hr>
<h2 id="静态导入包"><a href="#静态导入包" class="headerlink" title="静态导入包"></a>静态导入包</h2><p>为了方便，想<strong>不加类名来使用工具类的静态方法</strong>，需要通过<strong>静态(static)导入包</strong>来实现：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token keyword">static</span> <span class="token import static"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token static">random</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Application</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ul>
<li><p><code>abstract</code>修饰符可以修饰方法，也可以修饰类。</p>
<p>  如果修饰方法，方法就是抽象方法；如果修饰类，类就是抽象类。</p>
</li>
<li><p>抽象类中<strong>可以没有抽象方法</strong>，但<strong>有抽象方法的类一定要声明为抽象类</strong></p>
<p>  抽象类中<strong>可以有普通的方法</strong></p>
</li>
<li><p>抽象类<strong>不能用<code>new</code>关键字来创建对象</strong>，它是用来让子类继承的</p>
<p>  抽象类不能被创建对象，但<strong>有构造器</strong>。<strong>那么构造方法的作用是什么</strong>？</p>
<p>  <strong>抽象类的构造方法</strong>可以用来<strong>初始化抽象类内部声明的通用变量</strong>，并被各种实现使用。</p>
</li>
<li><p><strong>抽象方法</strong></p>
<p>  <strong>只有方法的声明，没有方法的实现</strong>，实现交由子类来实现。</p>
</li>
<li><p><strong>子类继承抽象类</strong>，就必须要<strong>实现抽象类没有实现的抽象方法</strong>，<strong>否则该子类也要声明为抽象类</strong></p>
</li>
</ul>
<hr>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul>
<li><p>普通类：只有具体实现</p>
</li>
<li><p>抽象类：<strong>具体实现</strong>和**规范(抽象方法)**都有</p>
</li>
<li><p>接口：<strong>只有规范</strong>，自己无法写方法。<strong>使约束和实现分离</strong>，<strong>面向接口编程</strong>。</p>
<p>  <strong>声明接口</strong>的关键字是<code>interface</code></p>
</li>
<li><p>接口就是规范，<strong>定义的是一组规则</strong>，让不同的人实现。</p>
</li>
<li><p><strong>OO(Object-Oriented)的精髓</strong>就是<strong>对对象的抽象</strong>，<strong>最能体现这一点的就是接口</strong>。</p>
<p>  <strong>设计模式</strong>所研究的，实际上就是<strong>如何合理地去抽象</strong>。</p>
</li>
<li><p>接口中<strong>定义属性和方法</strong></p>
<p>  <strong>属性</strong>是<strong>常量</strong> <code>public static final</code>，<strong>但一般不会在接口中定义属性</strong>；<strong>方法</strong>是<strong>抽象</strong>的<code>public abstract</code>。因此<strong>接口中定义的属性和方法的修饰符可以省略</strong>。</p>
</li>
<li><pre><code class="language-java">  public interface UserService &#123;
      
      // 接口中的所有定义的方法其实都是抽象的 public abstract，因此修饰符可省略
      void run();
  
  &#125;
  <pre class="line-numbers language-none"><code class="language-none">	
- **类只能单继承，但接口可以多继承（可以实现多个接口）**

	- 类通过关键字&#96;implements&#96;**实现接口**。**实现了接口的类，必须重写接口中的方法**。

	- **实现接口的类的命名**通常以&#96;Impl&#96;结尾。

	&#96;&#96;&#96;java
	
	&#x2F;&#x2F; 类可以通过implements实现多个接口
	public class UserServiceImpl implements UserService, TimeService &#123;
	
	    @Override
	    public void add(String name) &#123;
	
	    &#125;
	
	    @Override
	    public void timer() &#123;
	
	    &#125;
	&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
<li><p><strong>接口中没有构造方法</strong>(<strong>抽象类有构造方法</strong>)</p>
</li>
</ul>
<hr>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul>
<li>内部类就是<strong>在一个类的内部再定义一个类</strong></li>
</ul>
<hr>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Outer</span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> id <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">out</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是外部类的方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Inner</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">in</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是内部类的方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">// 获得外部类的私有属性</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getID</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>


<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Application</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

        <span class="token class-name">Outer</span> outer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Outer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">//通过外部类来实例化内部类</span>
        <span class="token class-name">Outer<span class="token punctuation">.</span>Inner</span> inner <span class="token operator">=</span> outer<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        inner<span class="token punctuation">.</span><span class="token function">in</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        inner<span class="token punctuation">.</span><span class="token function">getID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Outer</span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> id <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">out</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是外部类的方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Inner</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">in</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是内部类的方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">// 无法获得外部类的私有属性，因为静态类会先加载，非静态属性只有创建对象时才会生成；改成静态属性后，可以访问</span>
        <span class="token comment">/*
        public void getID() &#123;
            System.out.println(id);
        &#125;
        */</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>局部内部类<strong>位于方法中</strong></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Outer</span> <span class="token punctuation">&#123;</span>
	
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 局部内部类</span>
		<span class="token keyword">class</span> <span class="token class-name">Inner</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">in</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>没有类的名称，<strong>必须借助接口或者父类</strong>。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">//没有名字初始化类，不用将实例保存到变量中</span>
        <span class="token keyword">new</span> <span class="token class-name">Apple</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token comment">// 变成了实现了接口的类(匿名内部类)</span>
    <span class="token class-name">UserService</span> userService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name">Apple</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">interface</span> <span class="token class-name">UserService</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<hr>
<ul>
<li><p><strong>一个Java类中可以有多个class类</strong>，但<strong>只能有一个</strong><code>public class</code></p>
  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Outer</span> <span class="token punctuation">&#123;</span>
    
<span class="token punctuation">&#125;</span>


<span class="token comment">// 可以作为测试类，对public class类进行测试</span>
<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<hr>
<h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><code>java.lang.Object</code>类是Java语言中<strong>所有类的父类</strong>，其中描述的所有方法，子类都可以使用。如果一个类没有特别指定父类，则<strong>默认继承自Object类</strong>。</p>
<hr>
<h4 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString 方法"></a>toString 方法</h4><p><strong>直接打印对象的变量名，其实就是调用toString方法（对象在堆内存中的地址值）</strong>。但是Object默认的toString方法<strong>获取对象的地址值其实没有多少意义和可读性。</strong></p>
<p><strong>自定义的类，一般会重写toString方法，获取对象的属性</strong>。</p>
<hr>
<h4 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals 方法"></a>equals 方法</h4><h5 id="默认地址比较"><a href="#默认地址比较" class="headerlink" title="默认地址比较"></a>默认地址比较</h5><p>Object默认的equals方法为：使用<code>==</code>运算符<strong>比较对象地址</strong>，<strong>只要不是同一个对象，结果必然为false</strong>。</p>
<h5 id="对象内容比较"><a href="#对象内容比较" class="headerlink" title="对象内容比较"></a>对象内容比较</h5><p>如果希望进行对象的内容比较，则可以重写equals方法。equals方法<strong>隐含着一个多态（传入的是Object类的对象）</strong>：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>可选：<ul>
<li>添加一个判断，传递的参数obj如果是this本身，直接返回true，<strong>提高程序效率</strong></li>
<li>添加一个判断，传递的参数obj如果是null，直接返回false，<strong>提高程序效率</strong></li>
</ul>
</li>
<li>添加一个判断，防止类型转换异常ClassCastException</li>
<li>使用强制类型转换，把obj类转换成需要的类型</li>
<li>再比较两个对象的属性</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//idea自动生成的equals方法的重写</span>
<span class="token annotation punctuation">@override</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> o<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// this本身</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> o<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// o是null值 或 不能进行类型转换（反射技术，等效于 (o instanceof 当前对象的类型) ）</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    当前类 x <span class="token operator">=</span> <span class="token punctuation">(</span>当前类<span class="token punctuation">)</span> o<span class="token punctuation">;</span> <span class="token comment">// 强制类型转换</span>
    <span class="token keyword">return</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>strAttribute<span class="token punctuation">,</span> o<span class="token punctuation">.</span>strAttribute<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>intAttribute <span class="token operator">==</span> o<span class="token punctuation">.</span>intAttribute<span class="token punctuation">;</span> <span class="token comment">// strAttribute.equals(o.strAttribute) 是Object的equals方法，容易抛出空指针异常；因此采用Objects类的equals方法</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h4 id="clone-方法"><a href="#clone-方法" class="headerlink" title="clone 方法"></a>clone 方法</h4><p>clone方法可以<strong>实现对象的复制</strong>。<code>clone</code>方法<strong>要求子类实现<code>java.lang.Clonable</code>接口</strong>，从而在子类中实现对象的复制。</p>
<p><strong>浅克隆</strong>：对象在复制时<strong>仅复制基本类型的属性值到新对象中</strong>，<strong>引用的变量不会被复制</strong>。</p>
<p><strong>深度克隆</strong>：<strong>不仅复制基本类型的属性值到新对象中</strong>，<strong>引用的变量本身也会被复制</strong>。</p>
<h5 id="实现深度克隆"><a href="#实现深度克隆" class="headerlink" title="实现深度克隆"></a>实现深度克隆</h5><p>要实现深度克隆，需要<strong>重写clone方法</strong>。</p>
<hr>
<h3 id="Objects-类"><a href="#Objects-类" class="headerlink" title="Objects 类"></a>Objects 类</h3><p>JDK 1.7添加了一个<code>java.util.Objects</code>工具类，它提供了一些方法来操作对象，这些方法是**null-save（空指针安全）**的，<strong>用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象</strong>。</p>
<p>在比较两个对象的时候，<strong>Object的equals方法容易抛出空指针异常</strong>，而Object<strong>s</strong>类中的equals方法就优化了这个问题：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> a<span class="token punctuation">,</span> <span class="token class-name">Object</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">.</span><span class="token function">euqals</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<hr>
<h3 id="日期时间类"><a href="#日期时间类" class="headerlink" title="日期时间类"></a>日期时间类</h3><h4 id="Date-类"><a href="#Date-类" class="headerlink" title="Date 类"></a>Date 类</h4><p><code>java.util.Date</code>类表示<strong>特定的瞬间</strong>，精确到<strong>毫秒</strong>。</p>
<ul>
<li>构造方法：<ul>
<li><code>public Date()</code></li>
<li><code>public Date(long date)</code>：分配Date对象并初始化此对象，以表示自从标准基准时间（<strong>1970年1月1日00:00:00 GMT</strong>）以来的<strong>指定毫秒数</strong>。</li>
</ul>
</li>
</ul>
<p>简单来说，使用无参构造，可以自动设置<strong>当前系统时间</strong>的毫秒时刻，指定long类型可以<strong>自定义</strong>毫秒时刻；输出Date类时，会<strong>自动转换为日期格式</strong>。</p>
<ul>
<li><p>成员方法：</p>
<p>  <code>long getTime()</code>：把当对象表示的时间<strong>转换为毫秒值</strong></p>
</li>
</ul>
<hr>
<h4 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h4><p><code>java.text.DateFormat</code>是日期&#x2F;时间格式化子类的<strong>抽象类</strong>，可以通过这个类<strong>完成日期和文本之间的转换</strong>，即在Date对象和String对象之间来回转换。</p>
<ul>
<li><p><strong>格式化</strong></p>
<p>  <strong>按照指定的格式</strong>，从Date对象转换为String对象；<code>String format(Date date)</code>；</p>
</li>
<li><p><strong>解析</strong></p>
<p>  <strong>按照指定的格式</strong>，从String对象转换为Date对象；<code>Date parse(String source)</code></p>
</li>
</ul>
<hr>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p>由于DateFormat为抽象类，因此需要常用的子类<code>java.text.SimpleDateFormat</code>。这个类<strong>需要指定格式化或解析的格式</strong>。</p>
<p>构造方法为：<code>public SimpleDateFormat(String pattern)</code>。</p>
<p>参数pattern是一个字符串，代表日期时间的自定义格式，常用的格式规则如下：</p>
<table>
<thead>
<tr>
<th>标识字母（<strong>区分大小写</strong>）</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>y</td>
<td>年</td>
</tr>
<tr>
<td>M</td>
<td>月</td>
</tr>
<tr>
<td>d</td>
<td>日</td>
</tr>
<tr>
<td>H</td>
<td>时</td>
</tr>
<tr>
<td>m</td>
<td>分</td>
</tr>
<tr>
<td>s</td>
<td>秒</td>
</tr>
</tbody></table>
<p>格式中的<strong>字母不能更改</strong>，但<strong>连接的符号可以改变</strong>。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 1. 创建SimpleDateFormat对象，构造方法中传递指定的格式</span>
<span class="token class-name">SimpleDateFormat</span> sdf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy年MM月dd日 HH时mm分ss秒"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>格式化</p>
<p>  调用SimpleDateFormat对象中的<strong>format方法</strong>，按照构造方法中指定的模式，把Date日期格式化为符合模式的字符串</p>
  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Date</span> date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> d <span class="token operator">=</span> sdf<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>解析</p>
<p>  调用SimpleDateFormat对象中的<strong>parse方法</strong>，把<strong>符合构造方法中的格式的字符串</strong>解析为Date对象。</p>
<p>  ​    注意：parse方法声明了一个<strong>ParseExceptoion</strong>，如果字符串和构造方法的格式不一样，就会抛出异常。</p>
  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Date</span> date <span class="token operator">=</span> sdf<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"2021/07/31 22:26:33"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
</ul>
<hr>
<h4 id="Calendar-类"><a href="#Calendar-类" class="headerlink" title="Calendar 类"></a>Calendar 类</h4><p><code>java.util.Calendar</code><strong>在Date类之后出现</strong>，是一个抽象类，替换掉了很多Date的方法。该类<strong>将所有可能用到的时间信息封装为静态成员变量，方便获取</strong>。</p>
<table>
<thead>
<tr>
<th>字段值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>YEAR</td>
<td>年</td>
</tr>
<tr>
<td>MONTH</td>
<td>月(<strong>0-11</strong>)</td>
</tr>
<tr>
<td>WEEK_OF_YEAR</td>
<td>一年中的第几周</td>
</tr>
<tr>
<td>WEEK_OF_MONTH</td>
<td>一个月中的第几周</td>
</tr>
<tr>
<td><strong>DATE</strong><br />DAY_OF_MONTH</td>
<td>日</td>
</tr>
<tr>
<td>DAY_OF_WEEK</td>
<td>一周中的第几天</td>
</tr>
<tr>
<td>DAY_OF_YEAR</td>
<td>一年中的第几天</td>
</tr>
<tr>
<td>HOUR</td>
<td>时</td>
</tr>
<tr>
<td>MINUTE</td>
<td>分</td>
</tr>
<tr>
<td>SECOND</td>
<td>秒</td>
</tr>
<tr>
<td>MILLISECOND</td>
<td>毫秒</td>
</tr>
</tbody></table>
<hr>
<h5 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h5><p>Calendar类无法直接创建对象使用，它<strong>有一个静态方法</strong><code>getInstance()</code>，该方法<strong>使用默认时区和语言环境</strong>返回Calendar类的<strong>子类对象</strong>。</p>
<hr>
<h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><ul>
<li><code>public int get(int field)</code>：返回给定日历字段的值（参数使用Calendar类的<strong>静态成员变量</strong>）</li>
<li><code>public void set(int field, int value)</code>：将给定的日历字段设置为给定值</li>
<li><code>public void set(int year, int month, int day)</code>：同时设置年月日</li>
<li><code>public abstract void add(int field, int amount)</code>：根据日历的规则，为给定的日历字段添加或减去指定的时间量</li>
<li><code>public Date getTime()</code>：返回一个表示此Calendar时间值（<strong>从历元到现在的毫秒偏移量</strong>）的Date对象</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Calendar</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Calendar</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> year <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Calender</span><span class="token punctuation">.</span><span class="token constant">YEAR</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>year<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<hr>
<h3 id="Math-类"><a href="#Math-类" class="headerlink" title="Math 类"></a>Math 类</h3><hr>
<h3 id="BigInteger-类"><a href="#BigInteger-类" class="headerlink" title="BigInteger 类"></a>BigInteger 类</h3><hr>
<h3 id="BigDecimal-类"><a href="#BigDecimal-类" class="headerlink" title="BigDecimal 类"></a>BigDecimal 类</h3><hr>
<h3 id="System-类"><a href="#System-类" class="headerlink" title="System 类"></a>System 类</h3><p><code>java.lang.system</code>类中提供了大量的<strong>静态</strong>方法，可以<strong>获取与系统相关的信息或系统级操作</strong>，在System类的API文档中，常用的方法有：</p>
<ul>
<li><code>public static long currentTimeMills()</code>：返回以毫秒为单位的当前时间（和DATE类能达到相同的效果），<strong>可以用来测试程序的效率</strong></li>
<li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中<ul>
<li>src 源数组</li>
<li>srcPos 起始位置</li>
<li>dest 目标数组</li>
<li>destPos 目标数组中的起始位置</li>
<li>length 要复制的数组长度</li>
</ul>
</li>
</ul>
<hr>
<h4 id="currentTimeMills-方法"><a href="#currentTimeMills-方法" class="headerlink" title="currentTimeMills 方法"></a>currentTimeMills 方法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">long</span> s <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMills</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">long</span> e <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMills</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"程序共耗时："</span> <span class="token operator">+</span> <span class="token punctuation">(</span>e <span class="token operator">-</span> s<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"毫秒"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h4 id="arraycopy-方法"><a href="#arraycopy-方法" class="headerlink" title="arraycopy 方法"></a>arraycopy 方法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> src <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dest <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> dest<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>dest<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h3 id="StringBuilder-类"><a href="#StringBuilder-类" class="headerlink" title="StringBuilder 类"></a>StringBuilder 类</h3><p>又称为字符串缓冲区，可以提高字符串的操作效率（<strong>看作一个长度可变的字符串</strong>）。<strong>底层是一个初始长度为16的数组</strong>，但是没有被final修饰，因此长度可变。</p>
<hr>
<h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><code>public StringBuilder()</code>：构造一个空的StringBuilder容器</li>
<li><code>public StringBuilder(String str)</code>：构造一个StringBuilder容器，并将字符串添加进去</li>
</ul>
<hr>
<h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li><p><code>public StringBuilder append(...)</code>：添加<strong>任意类型数据</strong>，会将其内容转换为字符串形式，并返回当前对象自身，因此<strong>无需接收返回值</strong></p>
</li>
<li><p><code>public String toString()</code>：将当前StringBuilder对象<strong>转换为String对象</strong></p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hunter1023.github.io/2021/04/01/Java%E6%95%B0%E7%BB%84%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hunter">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talk is cheap">
      <meta itemprop="description" content="Tough times never last, but tough people do.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Talk is cheap">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/01/Java%E6%95%B0%E7%BB%84%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Java数组详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-02 01:08:25" itemprop="dateCreated datePublished" datetime="2021-04-02T01:08:25+08:00">2021-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-23 23:29:13" itemprop="dateModified" datetime="2025-01-23T23:29:13+08:00">2025-01-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%85%A8%E6%A0%88/" itemprop="url" rel="index"><span itemprop="name">Java全栈</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%85%A8%E6%A0%88/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h2><ul>
<li>数组是<strong>相同数据类型</strong>的有序集合</li>
</ul>
<p>特点：</p>
<ul>
<li><p>长度确定</p>
<p>  数组一旦被创建，它的大小就是不可改变的</p>
</li>
<li><p>数组中的元素可以是基本类型，也可以是引用类型</p>
</li>
<li><p>数组变量属于<strong>引用类型</strong>的数据</p>
<p>  数组也<strong>可以看成是对象</strong>，数组中的每个元素相当于该对象的成员变量。数组本身就是对象，Java中对象是在堆中的，因此无论数组中的元素的数据类型，<strong>数组对象本身就在堆中</strong>。</p>
</li>
</ul>
<hr>
<h2 id="声明创建数组"><a href="#声明创建数组" class="headerlink" title="声明创建数组"></a>声明创建数组</h2><ul>
<li><p>首先必须声明数组变量，才能在程序中使用数组</p>
  <pre class="line-numbers language-java" data-language="java"><code class="language-java">dataType<span class="token punctuation">[</span><span class="token punctuation">]</span> arrayRefVar<span class="token punctuation">;</span> <span class="token comment">// 首选的方法</span>
或
dataType arrayRefVar<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 效果相同，但不是首选方法（C/C++风格）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>Java语言使用new操作符来创建数组</p>
  <pre class="line-numbers language-java" data-language="java"><code class="language-java">dataType<span class="token punctuation">[</span><span class="token punctuation">]</span> arrayRefVar <span class="token operator">=</span> <span class="token keyword">new</span> dataType<span class="token punctuation">[</span>arraySize<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>获取数组长度</p>
  <pre class="line-numbers language-java" data-language="java"><code class="language-java">arrays<span class="token punctuation">.</span>length<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<hr>
<h2 id="Java内存分析"><a href="#Java内存分析" class="headerlink" title="Java内存分析"></a>Java内存分析</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul>
<li><p>存放基本类型变量(<strong>包含这个基本类型的具体数值</strong>)</p>
</li>
<li><p><strong>引用类型的变量</strong>(存放这个引用<strong>在堆里面的具体地址</strong>) </p>
<p>  <strong>对象是通过引用来操作的</strong></p>
</li>
</ul>
<hr>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul>
<li>存放<strong>new</strong>的<strong>对象</strong>和<strong>数组</strong>，不会存放别的对象引用</li>
<li>可以<strong>被所有的线程共享</strong></li>
</ul>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><ul>
<li>包含了<strong>所有的class和static变量</strong></li>
</ul>
<hr>
<h2 id="数组的三种初始化"><a href="#数组的三种初始化" class="headerlink" title="数组的三种初始化"></a>数组的三种初始化</h2><h3 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token class-name">Man</span><span class="token punctuation">[</span><span class="token punctuation">]</span> men <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token keyword">new</span> <span class="token class-name">Man</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Man</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="数组的默认初始化"><a href="#数组的默认初始化" class="headerlink" title="数组的默认初始化"></a>数组的默认初始化</h3><p>数组是引用类型，它的<strong>元素相当于类的实例变量</strong>。因此数组一经分配空间，其中的<strong>每个元素也被按照实例变量的方式被隐式初始化</strong>。</p>
<hr>
<h2 id="对数组进行反转"><a href="#对数组进行反转" class="headerlink" title="对数组进行反转"></a>对数组进行反转</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arrays<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>arrays<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> result<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arrays<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        result<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arrays<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><ul>
<li><p>多维数组可以看成是<strong>数组的数组</strong></p>
<p>  比如二维数组就是一个特殊的一维数组，其中<strong>每一个元素都是一个一维数组</strong>。</p>
  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 一个两行五列的数组</span>
<span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
</ul>
<hr>
<h2 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h2><ul>
<li><p>数组的工具类<code>java.util.Arrays</code></p>
</li>
<li><p>由于数组对象本身并没有什么方法可供调用，但API中提供了一个工具类Arrays，从而可以对数据对象进行一些基本操作</p>
</li>
<li><p>查看JDK帮助文档</p>
</li>
<li><p><strong>Arrays类中的方法都是static修饰的静态方法</strong>，在使用的时候可以<strong>直接使用类名进行调用</strong>，而<strong>不用使用对象来调用(使用对象调用也能实现，但没必要)</strong></p>
</li>
<li><p>常用功能(详细用法可见帮助文档)</p>
<ul>
<li>给数组赋值：<code>fill</code></li>
<li>对数组排序：<code>sort</code>，<strong>升序</strong></li>
<li>比较数组：<code>equals</code>，比较数组中元素值是否相等</li>
<li>查找数组元素：<code>binarySearch</code>方法能对<strong>排序好的数组</strong>进行<strong>二分查找法</strong>操作</li>
<li>将数组转换为List类型：<code>asList</code></li>
</ul>
</li>
</ul>
<hr>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ol>
<li>比较数组中相邻的元素，如果<strong>第一个数 &gt; 第二个数</strong>，就交换位置；</li>
<li>每一次比较，都会<strong>产生出一个最大的数字</strong>（<strong>如果第一个数 &lt; 第二个数交换位置，则会产生一个最小的数字</strong>）；</li>
<li>下一轮可以少一次排序；</li>
<li>依次循环，直到结束。</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arrays<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 外层循环，判断我们要走多少次</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arrays<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 通过flag标识减少数组有序后的无意义的比较</span>
        
        <span class="token comment">// 内层循环，比较判断两个数</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arrays<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arrays<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> arrays<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                tmp <span class="token operator">=</span> arrays<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                arrays<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arrays<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                arrays<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
                flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 有调整顺序</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        
        <span class="token keyword">if</span> <span class="token punctuation">(</span>flag <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 一次循环中没有调整顺序，说明数组实际已经有序，不必再循环</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token keyword">return</span> arrays<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h2 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h2><ul>
<li><p>当一个数组中大部分元素为0，或者为同一值的数时，可以使用稀疏数组来保存。</p>
</li>
<li><p>处理方式</p>
<ul>
<li>记录数组一共有<strong>几行几列</strong>，和大部分元素值<strong>不同</strong>的个数</li>
<li>把具有不同值的元素的<strong>行列及值</strong>记录在一个小规模的数组中，从而缩小程序的规模</li>
</ul>
  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//将普通数组转换为稀疏数组</span>

<span class="token comment">// 获取有效值的个数</span>
<span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">11</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">11</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            cnt<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 创建一个描述稀疏数组的数组</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>cnt<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

arr2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span> <span class="token comment">//行数</span>
arr2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span> <span class="token comment">//列数</span>
arr2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> cnt<span class="token punctuation">;</span> <span class="token comment">// 和大部分元素值不同的个数</span>

<span class="token comment">//遍历二维数组，将非零的值存放在稀疏数组中</span>
<span class="token keyword">int</span> row <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            row<span class="token operator">++</span><span class="token punctuation">;</span>
            arr2<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
            arr2<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>
            arr2<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>


<span class="token comment">// 读取稀疏数组</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>arr2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>arr2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token class-name">Array</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>arr3<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//填充洗漱数组中大部分相同的元素</span>

<span class="token comment">// 将少部分不同的元素填充进去</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr2<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    arr3<span class="token punctuation">[</span>arr2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>arr2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hunter1023.github.io/2021/03/29/Java%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hunter">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talk is cheap">
      <meta itemprop="description" content="Tough times never last, but tough people do.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Talk is cheap">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/29/Java%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Java方法详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-30 00:22:37" itemprop="dateCreated datePublished" datetime="2021-03-30T00:22:37+08:00">2021-03-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-23 23:29:13" itemprop="dateModified" datetime="2025-01-23T23:29:13+08:00">2025-01-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%85%A8%E6%A0%88/" itemprop="url" rel="index"><span itemprop="name">Java全栈</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%85%A8%E6%A0%88/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h2><ul>
<li><p>Java的方法类似于其它语言的<strong>函数</strong>，是一段用来<strong>完成特定功能</strong>的<strong>代码片段</strong>。</p>
</li>
<li><p>方法包含一个<strong>方法头</strong>和一个<strong>方法体</strong></p>
</li>
<li><pre><code class="language-java">  修饰符 返回值类型 方法名(参数类型 参数名) &#123;
      方法体
          
      return 返回值;
  &#125;
  <pre class="line-numbers language-none"><code class="language-none">
- 方法**可以不包含任何参数**

---

## 值传递和引用传递

### 值传递 pass by value

在调用函数时，**将实际参数复制一份**传递到函数中，这样在行数中对参数进行修改，就**不会影响到原来的实际参数**。

### 引用传递 pass by reference

在调用函数时，**将实际参数的地址**直接传递到函数中，这样在函数中对参数进行的修改就**会影响到实际参数**。

---

### Java是值传递

- Java中，调用函数时，如果参数是**对象**，**实际参数**其实就是**指向对象的地址**。

	如果传递的是地址，就**看这个地址的变化**，而**不是看地址指向的对象的变化**。

- 值传递和引用传递的**区别并不是传递的内容**，而是**实际参数是否被复制**并传递到函数。

---

## 方法的重载

- 重载就是在一个类中，有**相同的函数名称**，但**参数不同**的函数。

- 方法的重载规则

	- **方法名称**必须**相同**
	- **参数列表**必须**不同**(**个数**不同&#x2F;**类型**不同&#x2F;参数**排列顺序**不同等)
	- 方法的**返回类型不限制**(可以相同也可以不同)
	- 仅仅返回类型不同不足以成为方法的重载

- 实现理论

	方法名称相同时，编译器会根据调用方法的参数个数、类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错。

---

## 可变参数

   - JDK 1.5开始，Java支持传递**同类型的可变参数**给一个方法

   - 在方法声明中，在指定参数类型后加一个省略号&#96;...&#96;

   - **一个方法中只能指定一个可变参数**，它**必须是方法的最后一个参数**

   - &#96;&#96;&#96;java
	public class Demo &#123;
		public static void main(String[] args) &#123;
	        printMax(34, 4, 6, 78, 232.4);
	        printMax(new double[]&#123;1, 2, 3&#125;)
	    &#125;
	    
	    public static void printMax(double... numbers) &#123; &#x2F;&#x2F; 可变参数
	        if (numbers.length &#x3D;&#x3D; 0) &#123;
	            System.out.println(&quot;No argument passed&quot;);
	            return;
	        &#125;
	
	        double result &#x3D; numbers[0];
	
	        &#x2F;&#x2F; 获取最大值
	        for (int i &#x3D; 0; i &lt; numbers.length; i++) &#123;
	            if (numbers[i] &gt; result) &#123;
	                result &#x3D; numbers[i];
	            &#125;
	            System.out.println(&quot;The max value is &quot; + result);
	        &#125;
	    &#125;
	&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hunter1023.github.io/2021/03/22/Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hunter">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talk is cheap">
      <meta itemprop="description" content="Tough times never last, but tough people do.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Talk is cheap">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/22/Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/" class="post-title-link" itemprop="url">Java流程控制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-22 23:22:30" itemprop="dateCreated datePublished" datetime="2021-03-22T23:22:30+08:00">2021-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-23 23:29:13" itemprop="dateModified" datetime="2025-01-23T23:29:13+08:00">2025-01-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%85%A8%E6%A0%88/" itemprop="url" rel="index"><span itemprop="name">Java全栈</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%85%A8%E6%A0%88/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="用户交互Scanner"><a href="#用户交互Scanner" class="headerlink" title="用户交互Scanner"></a>用户交互Scanner</h2><p><code>java.util.Scanner</code>是<strong>Java5</strong>的特性。可以通过<strong>Scanner类</strong>来<strong>获取用户的输入</strong>。</p>
<ul>
<li><p>通过Scanner类的<code>next()</code>与<code>nextLine()</code>方法<strong>获取输入的字符串</strong>，在读取前我们一般需要使用<code>hasNext()</code>与<code>hasNextLine()</code><strong>判断是否还有输入的数据</strong>。</p>
<ul>
<li><p><code>next()</code></p>
<ul>
<li>一定要<strong>读取到有效字符后</strong>才会结束输入；</li>
<li>对输入有效字符前遇到的<strong>空白</strong>，<code>next()</code>会将其<strong>自动去掉</strong>；</li>
<li>只有输入有效字符后才将其<strong>后面输入的空白作为分隔符或结束符</strong>；</li>
<li>&#x3D;&#x3D;<code>next()</code><strong>不能得到带有空格的字符串</strong>&#x3D;&#x3D;</li>
</ul>
</li>
<li><p><code>nextLine()</code></p>
<ul>
<li>以<strong>Enter为结束符</strong></li>
<li>可以获得空白</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Scanner</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 判断用户有没有输入字符串</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>scanner<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">String</span> str <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"输出的内容为："</span> <span class="token operator">+</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 凡是属于I/O流的类，如果不关闭会一直占用资源。用完就关掉。</span>
scanner<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>凡是属于I&#x2F;O流的类，如果不关闭会一直占用资源。</p>
<p>  <strong>用完就关掉</strong>，<code>scanner.close()</code></p>
</li>
</ul>
<hr>
<h2 id="Switch选择结构"><a href="#Switch选择结构" class="headerlink" title="Switch选择结构"></a>Switch选择结构</h2><ul>
<li>除了<code>if else</code>语句外，多选择结构还可以通过<code>switch case</code>语句实现</li>
<li><strong>switch case</strong>语句判断一个<strong>变量</strong>与<strong>一系列值</strong>中的某一个值<strong>是否相等</strong>，每个值称为一个<strong>分支</strong>。</li>
<li>switch 语句中的<strong>变量类型</strong>可以是<ul>
<li>byte、short、int、char</li>
<li><strong>JDK 7</strong>开始，switch支持<strong>String类型</strong></li>
<li>case标签必须是<strong>字符串常量</strong>或<strong>字面量</strong></li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">switch</span> <span class="token punctuation">(</span>expression<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">case</span> value<span class="token operator">:</span>
        <span class="token comment">// 语句</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 可选，但最好写上</span>
    <span class="token keyword">case</span> value<span class="token operator">:</span>
        <span class="token comment">// 语句</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 可选，但最好写上</span>
    <span class="token comment">// 可以有任意数量的case语句</span>
    <span class="token keyword">default</span><span class="token operator">:</span> <span class="token comment">// 可选，放最后</span>
        <span class="token comment">// 语句 </span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>&#x3D;&#x3D;<strong>case穿透</strong>&#x3D;&#x3D;</p>
<p>  如果<strong>分支中没有break</strong>，当变量<strong>成功匹配上一个分支后，之后的分支会顺序执行</strong>，直到语句结束或遇到break。</p>
<p>  因此，规范写法：<strong>每个分支必须要有break</strong>。</p>
</li>
<li><p>default</p>
<p>  变量值<strong>没能与其他分支匹配时，会执行default分支</strong>，</p>
<p>  因此理论上<strong>应该放在最后</strong>。</p>
</li>
</ul>
<hr>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><hr>
<h3 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a>do while循环</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">do</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// 代码语句</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>布尔表达时<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>while 和 do while循环的区别</p>
<p>  while先判断后执行，do while 先执行后判断</p>
</li>
<li><p>记住while之后要加<strong>分号;</strong>，当然，好的IDE都会相关有纠错提示</p>
</li>
</ul>
<hr>
<h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><hr>
<ul>
<li><p>for循环使一些循环结构变得更加简单；</p>
</li>
<li><p>for循环语句是<strong>支持迭代</strong>的一种通用结构，是<strong>最有效、最灵活</strong>的循环结构；</p>
</li>
<li><pre><code class="language-java">  for (初始化; 布尔表达式; 迭代) &#123;
      // 代码语句
  &#125;
  <pre class="line-numbers language-none"><code class="language-none">
---

## 增强for循环 foreach

- **Java5** 引入了主要用于**数组或集合**的增强型for循环；

- &#96;&#96;&#96;java
	for (声明语句 : 表达式) &#123;
	    &#x2F;&#x2F; 代码语句
	&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
<li><p>声明语句</p>
<ul>
<li>声明新的<strong>局部变量</strong>，该变量的<strong>类型必须和数组元素的类型匹配</strong>；</li>
<li>其<strong>作用域限定在循环语句块</strong>，其值与此时数组元素的值相等；</li>
</ul>
</li>
<li><p>表达式</p>
<p>  表达式时要访问的<strong>数组名</strong>，或者是<strong>返回值为数组</strong>的方法；</p>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> numbers <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">:</span> numbers<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h2 id="break、continue、goto"><a href="#break、continue、goto" class="headerlink" title="break、continue、goto"></a>break、continue、goto</h2><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>break用于<strong>强行退出</strong>循环，不执行剩余语句(break语句也在switch语句中使用)</p>
<h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>continue语句用在循环语句体中，用于<strong>终止某次</strong>循环过程。即跳过循环体中尚未执行的语句，<strong>直接进行下一次是否执行循环的判定</strong>。</p>
<h3 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h3><p>goto关键字很早就在程序设计语言中出现。尽管goto仍然是Java的一个保留字，但并未得到正式使用；<strong>Java没有goto</strong>。</p>
<p>但在break和continue身上，我们能看出一些goto的影子——<strong>带标签</strong>的break和continue。</p>
<ul>
<li><p>标签是指<strong>后面跟一个冒号的标识符</strong>，如<code>label:</code></p>
</li>
<li><p>对Java来说，<strong>唯一用到标签</strong>的地方是在<strong>循环语句之前</strong>。</p>
<p>  <strong>设置标签的唯一理由</strong>：我们希望在其中<strong>嵌套另一个循环</strong>，由于<strong>break和continue关键字通常只中断当前循环</strong>，但若随同标签使用，它们就会<strong>中断到存在标签的地方</strong>。</p>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">outer<span class="token operator">:</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> （<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">continue</span> outer<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>






      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hunter1023.github.io/2021/03/14/IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hunter">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talk is cheap">
      <meta itemprop="description" content="Tough times never last, but tough people do.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Talk is cheap">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/14/IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">IDEA使用技巧</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-14 22:42:44" itemprop="dateCreated datePublished" datetime="2021-03-14T22:42:44+08:00">2021-03-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-10 22:38:41" itemprop="dateModified" datetime="2025-02-10T22:38:41+08:00">2025-02-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%85%A8%E6%A0%88/" itemprop="url" rel="index"><span itemprop="name">Java全栈</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%85%A8%E6%A0%88/IDE/" itemprop="url" rel="index"><span itemprop="name">IDE</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="日常使用"><a href="#日常使用" class="headerlink" title="日常使用"></a>日常使用</h2><ol>
<li><p>快速输入<code>public static void main(String[] args)&#123;&#125;</code></p>
<p><code>psvm</code> + tab即可</p>
</li>
<li><p>快速输入<code>System.out.println();</code></p>
</li>
</ol>
<ul>
<li><code>sout</code> + tab即可</li>
<li>可以先输入任何想要输出的变量，再<code>.sout</code></li>
</ul>
<ol start="3">
<li><p>想<strong>创建对象</strong>或使用一个<strong>能返回对象的方法</strong>时，直接写<code>new ClassName()</code>&#x2F;<code>ClassName.methodName(parameters)</code>，再<code>Alt + Enter</code>，即可自动产生对象名。</p>
</li>
<li><p>谷歌<code>IDEA优化</code>，进行相关操作</p>
</li>
<li><p>运行Java文件</p>
</li>
</ol>
<ul>
<li><strong>上次运行过</strong>的文件：Shift + F10</li>
<li><strong>当前</strong>文件：Ctrl + Shift + F10</li>
</ul>
<ol start="6">
<li><p><strong>反编译</strong></p>
<ol>
<li>工具栏 - Project Structure… - Project - Project compiler output，找到编译成字节码的class文件输出地址，在文件资源管理器中打开该地址；</li>
<li>IDEA中，在中意的Package右键 - Show in Explore </li>
<li>在文件资源管理器中，<strong>复制class文件到java文件所在的目录</strong>，之后再在IDEA中打开，<strong>即可查看反编译后的内容</strong>。</li>
</ol>
</li>
<li><p>编写构造器</p>
<p> Alt + insert  –&gt; Constructor</p>
</li>
<li><p>编写Getter和Setter方法</p>
<p> Alt + insert  –&gt; Getter and Setter</p>
</li>
<li><p>方法的重载</p>
<p> Alt + insert  –&gt; Override Methods…</p>
 <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 创建重载方法后，IDEA 会自动写一个注解(有功能的注释)</span>
<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">overrideMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 方法体</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>包裹选中的代码</strong></p>
<p>Ctrl + Alt + T</p>
</li>
<li><p>自动清除无效import</p>
<p>Settings -&gt; Editor -&gt; General -&gt; Auto Import -&gt; Java</p>
<p>勾选<code>Optimize imports on the fly</code>。</p>
<p><img src="https://s2.loli.net/2022/08/18/3FmoUBNnPJGzkTc.png" alt="image-20220818002554092"></p>
</li>
<li><p>在底部的Git标签页中，添加Local Changes标签页</p>
<p>效果：</p>
<p><img src="https://s2.loli.net/2022/12/14/ZzBeQisM6HN9lYp.png" alt="image-20221214231836532"></p>
<p>操作：File - Settings - Version Control - Commit - <strong>取消勾选</strong>Use non-modal commit interfce</p>
<img src="https://s2.loli.net/2022/12/14/lY5PNLcVWtRJQvU.png" alt="image-20221214231903047" style="zoom:80%;" />
</li>
<li><p>去掉import自动合并</p>
</li>
</ol>
<p>​	<a target="_blank" rel="noopener" href="https://blog.csdn.net/mistytulip/article/details/103766872">IDEA java文件import去掉自动合并</a></p>
<ol start="14">
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37751454/article/details/88541334">idea+tomcat实现热部署-修改java代码及时生效</a></p>
</li>
<li><p><code>Endpoints</code>：查看web应用程序的请求映射</p>
<p><code>view</code> - <code>Tool Windows</code> - <code>Endpoints</code></p>
<img src="https://s2.loli.net/2024/07/29/H62LrA5ZcE1FMlu.png" alt="image-20240729143156072" style="zoom:80%;" />

<img src="https://s2.loli.net/2024/07/29/vLOmajSuFynRNEP.png" alt="image-20240729143247150" style="zoom:80%;" /></li>
</ol>
<hr>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>设置快捷生成日志的提示：</p>
<ol>
<li>File - Settings - Editor - Live Templates - 加号 - Live Template</li>
</ol>
<p><img src="https://s2.loli.net/2023/09/17/1BxFcydvNzQneZf.png" alt="image-20230917005706530"></p>
<ol start="2">
<li><p>Abbreviation填写期望的快捷缩写，Template text填写期望的填充效果</p>
<p><code>private static final Logger LOGGER = LoggerFactory.getLogger($CLASS_NAME$.class);</code></p>
</li>
<li><p>Edit Variables… - Expression选择<code>className()</code></p>
</li>
<li><p>左下角<code>Define</code>，设置生效的场景：<code>java: declaration</code></p>
<img src="https://s2.loli.net/2023/09/17/pVGl8Xu3ACawOZL.png" alt="image-20230917012446212" style="zoom:80%;" /></li>
</ol>
<hr>
<h2 id="文件和代码模板"><a href="#文件和代码模板" class="headerlink" title="文件和代码模板"></a>文件和代码模板</h2><h3 id="创建类时自动添加注释"><a href="#创建类时自动添加注释" class="headerlink" title="创建类时自动添加注释"></a>创建类时自动添加注释</h3><ul>
<li>File - Settings - Editor - File and Code Tmplates</li>
<li>Scheme: <code>Default</code></li>
<li>Includes - File Header</li>
</ul>
<img src="https://s2.loli.net/2023/10/09/L4SKgVnwHfM7RQj.png" alt="image-20231009100131089" style="zoom:80%;" />

<hr>
<h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><p>IDEA中有4种基础断点：</p>
<ol>
<li><strong>行断点</strong></li>
<li><strong>方法断点</strong></li>
<li><strong>属性断点</strong></li>
<li><strong>异常断点</strong></li>
</ol>
<p>以此4种断点为基础，衍生出了4种断点：</p>
<ol>
<li>**条件断点。**右键断点，添加Condition。<strong>只有在满足条件时，断点才会阻断程序运行。</strong></li>
</ol>
<img src="https://s2.loli.net/2024/07/17/myB3TfJnUa4iZwj.png" alt="image-20240717110843181" style="zoom:80%;" />

<ol start="2">
<li><strong>源断点。<strong>可以在</strong>不阻断代码</strong>的情况下，在控制台上输出某些信息。</li>
</ol>
<p><code>Shift</code>+鼠标左键 添加断点，勾选<code>&quot;Breakpoint hit&quot; message</code>和<code>Evaluate and log</code></p>
<ul>
<li><code>&quot;Breakpoint hit&quot; message</code>：在调试控制台中<strong>输出断点被触发的消息</strong>。默认消息为 “Breakpoint hit at &lt;文件名&gt;:&lt;行号&gt;”。</li>
<li><code>Evaluate and log</code>：执行输入框中输入的表达式，并将结果输出到控制台。</li>
</ul>
<p><img src="https://s2.loli.net/2024/07/17/pxmNtdA2egRX6SD.png" alt="image-20240717114900903"></p>
<ol start="3">
<li><strong>多线程断点</strong>。模拟线程的轮询执行。</li>
</ol>
<p>右键断点，Suspend选择<code>Thread</code>。实际debug过程中，可以在<code>Debugger</code>的标签页看到不同的线程，通过切换线程进行Debug，就能模拟线程的轮询执行。</p>
<img src="https://s2.loli.net/2024/07/17/uzNa8vZ7LqMjkFV.png" alt="image-20240717142624986" style="zoom:80%;" />

<ol start="4">
<li>**Stream断点。**在Stream的代码行加上断点，就可以在运行到这行代码时，点击<code>Trace Current Stream Chain</code>，看到数据的流转情况。</li>
</ol>
<p><img src="https://s2.loli.net/2024/07/17/5OWF97vfxKIuhqg.png" alt="image-20240717142837288"></p>
<hr>
<h3 id="进入断点之后的调试技巧"><a href="#进入断点之后的调试技巧" class="headerlink" title="进入断点之后的调试技巧"></a>进入断点之后的调试技巧</h3><ol>
<li><code>Step Over</code>：一行行往下执行，<strong>不会进入方法内部</strong>。</li>
</ol>
<img src="https://s2.loli.net/2024/07/17/pm35xOKgtUJlrnV.png" alt="Step Over" style="zoom:80%;" />

<ol start="2">
<li><code>Step Into</code>：进入方法内部。但是<strong>一些外部Jar包的方法会无法进入</strong>。如果想要进入外部Jar包方法，可以使用<code>Force Step Into</code></li>
</ol>
<img src="https://s2.loli.net/2024/07/17/n83GYrC7ojWbDHJ.png" alt="Step Into" style="zoom:80%;" />

<img src="https://s2.loli.net/2024/07/17/OLzxPUIApHmuo3e.png" alt="Force Step Into" style="zoom:80%;" />

<ol start="3">
<li><p><code>Step Out</code>：跳转到调用方法处。</p>
</li>
<li><p><code>Run to Cursor</code>：跳转到鼠标光标所在位置。</p>
</li>
</ol>
<img src="https://s2.loli.net/2024/07/17/PdIeyuBhrSZDQ8K.png" alt="image-20240717144632995" style="zoom:80%;" />

<hr>
<h3 id="回退重新执行方法-Reset-Frame"><a href="#回退重新执行方法-Reset-Frame" class="headerlink" title="回退重新执行方法 Reset Frame"></a>回退重新执行方法 <code>Reset Frame</code></h3><p>在调用栈中，点击希望回退的位置对应方法左侧的回退图标<code>Reset Frame</code>，就能实现回退。</p>
<p><img src="https://s2.loli.net/2024/07/17/Ds1lcRIQN6ji7Uu.png" alt="image-20240717144332410"></p>
<hr>
<h3 id="跳转至下一个断点-Resume-Program"><a href="#跳转至下一个断点-Resume-Program" class="headerlink" title="跳转至下一个断点 Resume Program"></a>跳转至下一个断点 <code>Resume Program</code></h3><p>如果没有后续断点，就会将程序执行至结束。</p>
<img src="https://s2.loli.net/2024/07/17/5nzkyJhKROS2jZd.png" alt="image-20240717144557317" style="zoom:80%;" />

<hr>
<h3 id="观察指定变量的变化情况-Watches"><a href="#观察指定变量的变化情况-Watches" class="headerlink" title="观察指定变量的变化情况 Watches"></a>观察指定变量的变化情况 <code>Watches</code></h3><p>Debug过程中，<strong>所有的变量都会被展示在Debugger栏中，如果只想要观察某几个特定的变量，不便于观察</strong>。</p>
<p>勾选Debug标签页右侧<code>Layout Settings</code>下的<code>Separate Watches</code>选项。再添加一个想要监听的变量或表达式，就能只关注自己关心的变量信息。</p>
<img src="https://s2.loli.net/2024/07/17/51ypjqJ9lnEOoCU.png" alt="image-20240717145055989" style="zoom:80%;" />

<hr>
<h3 id="手动修改变量的值"><a href="#手动修改变量的值" class="headerlink" title="手动修改变量的值"></a>手动修改变量的值</h3><p>通过<code>Evaluate Expression...</code>，<strong>就可以实现手动修改变量值，以快速进入某个代码逻辑中</strong>。</p>
<img src="https://s2.loli.net/2024/07/17/3rFYSmOGMcTxXeg.png" alt="image-20240717145755575" style="zoom:80%;" />

<hr>
<h3 id="手动抛出异常，测试异常处理的代码逻辑"><a href="#手动抛出异常，测试异常处理的代码逻辑" class="headerlink" title="手动抛出异常，测试异常处理的代码逻辑"></a>手动抛出异常，测试异常处理的代码逻辑</h3><p>选择栈中方法后，右键选择<code>Throw Exception</code>：</p>
<img src="https://s2.loli.net/2024/07/17/6Og5JTwcHpInMYt.png" alt="image-20240717150036571" style="zoom:80%;" />

<p>例如构造一个空指针异常：</p>
<img src="https://s2.loli.net/2024/07/17/R2oiJCEX6G8PhSa.png" alt="image-20240717150152071" style="zoom:80%;" />

<hr>
<h3 id="监控断点的开销"><a href="#监控断点的开销" class="headerlink" title="监控断点的开销"></a>监控断点的开销</h3><p>有时候打了断点会让项目执行很慢，尤其是一些复杂的条件断点。勾选<code>Overhead</code>，就能看到断点的执行次数和执行耗时。</p>
<p><strong>如果发现断点耗时，可以去掉，节约资源。</strong></p>
<img src="https://s2.loli.net/2024/07/17/a43YMTZnSuh1V56.png" alt="image-20240717150846260" style="zoom:80%;" />

<hr>
<h2 id="添加JVM启动参数"><a href="#添加JVM启动参数" class="headerlink" title="添加JVM启动参数"></a>添加JVM启动参数</h2><img src="https://s2.loli.net/2024/07/22/bl6B8tKdXoMefcr.png" alt="Edit Configurations..." style="zoom:80%;" />



<img src="https://s2.loli.net/2024/07/22/85Dkq6YhjNAUx1r.png" alt="Modify options" style="zoom:80%;" />

<img src="https://s2.loli.net/2024/07/22/trnBATwkCDUzGXL.png" alt="Add VM options" style="zoom:80%;" />

<p><img src="https://s2.loli.net/2024/07/22/B3vPzZMTU7dmYpR.png" alt="添加JVM启动参数"></p>
<ul>
<li><p><code>-Xms</code>：堆内存最小值，例如<code>-Xms1m</code></p>
</li>
<li><p><code>-Xmx</code>：堆内存最大值，例如<code>-Xmx1m</code></p>
</li>
<li><p><code>-Xss</code>：指定线程栈的大小</p>
<p>  通常不需要修改值，如果遇到栈溢出报错，可以适当增大；如果需要创建大量线程，可以适当减小。</p>
</li>
<li><p><code>-XX:+HeapDumpOnOutOfMemoryError</code>：发生OOM后，生成相应的dump文件</p>
</li>
<li><p><code>-XX:HeapDumpPath=[指定的存放路径]</code>：dump文件存放路径</p>
</li>
<li><p><code>-Xlog:gc*</code>：查看GC日志</p>
</li>
<li><p><code>-XX:MaxTenuringThreshold</code>：设置对象从Survivor区晋升到老年代的年龄阈值</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hunter1023.github.io/2021/03/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hunter">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talk is cheap">
      <meta itemprop="description" content="Tough times never last, but tough people do.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Talk is cheap">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">机器学习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-14 13:36:55" itemprop="dateCreated datePublished" datetime="2021-03-14T13:36:55+08:00">2021-03-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-23 23:29:13" itemprop="dateModified" datetime="2025-01-23T23:29:13+08:00">2025-01-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><p>机器学习研究的主要内容，是关于在计算机上<strong>从数据中产生模型（model）的算法</strong>，即<strong>学习算法（learning algorithm）</strong>。</p>
<p>《机器学习》一书中，<strong>模型</strong>泛指<strong>从数据中学得的结果</strong>，有时将模型称为<strong>学习器learner</strong>，可以看作<strong>学习算法在给定数据和参数空间上的实例化</strong>。有些文献，<strong>模型</strong>指<strong>全局性</strong>结果，如<strong>一棵决策树</strong>，<strong>模式</strong>指<strong>局部性</strong>结果，如<strong>一条规则</strong>。</p>
<hr>
<h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><ul>
<li><p><strong>数据集 data set</strong>：记录的集合</p>
<ul>
<li><strong>示例&#x2F;样本 instance&#x2F;sample</strong>：关于一个事件或对象的描述。</li>
</ul>
</li>
<li><p><strong>属性&#x2F;特征 attribute&#x2F;feature</strong>：反映事件或对象在<strong>某方面的表现或性质</strong>的事项。</p>
</li>
<li><p><strong>样本空间 sample space</strong>：<strong>属性张成</strong>的空间。</p>
<p>  e.g. 把色泽、根蒂、敲声作为<strong>三个坐标轴</strong>，则张成一个用于描述西瓜的<strong>三维空间</strong>，每个西瓜都可以找到自己的坐标位置。</p>
</li>
<li><p>一个样本也可以称为<strong>样本空间</strong>中的一个<strong>特征向量 feature vector</strong>。</p>
</li>
</ul>
<p>$D&#x3D;{x_1,x_2,…,x_m}$表示包含$m$个示例的数据集，每个示例包含$d$个属性描述。每个示例$x_i&#x3D;(x_{i1};x_{i2};…;x_{id})$是d维样本空间中的一个向量。</p>
<ul>
<li><p><strong>学习&#x2F;训练 learning&#x2F;training</strong>：从<strong>数据中学得模型</strong>的过程，这个过程通过<strong>执行某个学习算法</strong>来完成，<strong>学习过程</strong>就是为了<strong>找出或逼近真相</strong>。</p>
<ul>
<li><p><strong>训练数据 training data</strong>：训练过程中使用的数据</p>
</li>
<li><p><strong>训练样本 training sample</strong></p>
</li>
<li><p><strong>训练集 training set</strong>：训练样本组成的集合</p>
</li>
<li><p><strong>标记 label</strong>：训练样本的<strong>结果信息</strong></p>
<p>  拥有了标记label 的示例sample，称为<strong>样例example</strong>，一般用$(x_u,y_i)$表示第i个样例，$y_i$是示例$x_i$的标记。</p>
</li>
<li><p>$Y$是所有标记label的集合，称为<strong>标记空间label space&#x2F;输出空间</strong></p>
</li>
</ul>
</li>
<li><p><strong>假设 hypothesis</strong></p>
<p>  学得的模型<strong>对应了关于数据的某种潜在的规律</strong>。</p>
</li>
<li><p><strong>真实 ground-truth</strong>：<strong>客观规律自身</strong></p>
</li>
<li><p><strong>预测</strong>模型 <strong>prediction</strong> model</p>
</li>
<li><p><strong>分类 classification</strong></p>
<p>  <strong>预测离散值</strong>的学习任务。例如好瓜、坏瓜。</p>
<ul>
<li><strong>binary classification 二分类</strong><ul>
<li>positive class 正类</li>
<li>negative class 反类</li>
</ul>
</li>
<li><strong>multi-class classification 多分类</strong></li>
</ul>
<p>  一般地，<strong>预测prediction任务</strong>希望通过<strong>对训练集training set进行学习</strong>，<strong>建立一个从输入空间X到输出空间Y的映射</strong>。
  </p>
</li>
<li><p><strong>回归 regression</strong></p>
<p>  <strong>预测连续值</strong>的学习任务。例如西瓜成熟度0.95、0.37。</p>
</li>
<li><p><strong>测试 testing</strong></p>
<p>  testing sample 被预测的样本</p>
</li>
<li><p><strong>聚类 clustering</strong></p>
<p>  将训练集中的西瓜分成若干组，<strong>每组称为一个簇cluster</strong>。</p>
<p>  这些自动形成的簇可能对应一些<strong>潜在的</strong>概念划分，例如“浅色瓜”、“深色瓜”。</p>
</li>
<li><p><strong>监督学习 supervised learning</strong></p>
<p>  训练数据拥有<strong>标记信息</strong></p>
<ul>
<li>分类、回归</li>
</ul>
</li>
<li><p><strong>无监督学习 unsupervised learning</strong></p>
<p>  训练数据<strong>没有标记信息</strong></p>
<ul>
<li>聚类</li>
</ul>
</li>
<li><p><strong>泛化 generalization</strong></p>
<p>  学得模型<strong>适用于新样本的能力</strong>，称为泛化能力。</p>
</li>
</ul>
<p>通常假设样本空间中<strong>全体样本服从一个未知分布(distribution)D</strong>，我们获得的<strong>每个样本都是独立地从这个分布上采样获得的</strong>，即**“独立同分布”(independent and identically distributed)**</p>
<hr>
<h2 id="假设空间"><a href="#假设空间" class="headerlink" title="假设空间"></a>假设空间</h2><ul>
<li><p><strong>归纳 induction</strong></p>
<p>  <strong>从特殊到一般</strong>的<strong>泛化(generalization)<strong>过程，即</strong>从具体的事实归结出一般性规律</strong>。</p>
<p>  <strong>从样例中学习</strong>显然是一个归纳的过程，因此亦称<strong>归纳学习(induction learning)</strong></p>
</li>
<li><p><strong>演绎 deduction</strong></p>
<p>  <strong>从一般到特殊</strong>的<strong>特化(specialization)<strong>过程，即</strong>从基础原理推演出具体状况</strong>。</p>
</li>
</ul>
<p>可以<strong>把学习过程看作一个在所有假设(hypothesis)组成的空间中进行搜索的过程</strong>，搜索目标是找到与训练集**匹配(fit)**的假设。假设的表示一旦确定，假设空间及其规模大小就确定了。</p>
<p>现实问题中我们常面临很大的假设空间，但学习的过程是基于有限样本训练集进行的，因此<strong>可能有多个假设与训练集一致</strong>。<strong>与训练集一致的假设集合</strong>，称之为<strong>版本空间(version space)</strong>。</p>
<hr>
<h2 id="归纳偏好"><a href="#归纳偏好" class="headerlink" title="归纳偏好"></a>归纳偏好</h2><p>对于一个具体的学习算法而言，它必须要产生<strong>一个</strong>模型。<strong>学习算法本身的偏好</strong>会起到关键作用。</p>
<p>机器学习算法在学习过程中<strong>对某类假设的偏好</strong>，称为<strong>归纳偏好(inductive bias)</strong>。</p>
<p><strong>是否存在一般性的原则来引导算法确立“正确”的偏好？</strong></p>
<h4 id="“奥卡姆剃刀”-Occam’s-razor-原则"><a href="#“奥卡姆剃刀”-Occam’s-razor-原则" class="headerlink" title="**“奥卡姆剃刀”(Occam’s razor)**原则"></a>**“奥卡姆剃刀”(Occam’s razor)**原则</h4><p>奥卡姆剃刀原则是一种常用的、<strong>自然科学研究中最基本的原则</strong>：若有多个假设与观察一致，则<strong>选最简单的那个</strong>。</p>
<p>然而，奥卡姆剃刀并非唯一可行的原则，且其本身存在不同的诠释。例如：</p>
<ol>
<li>好瓜↔(色泽 &#x3D; *) ^ (根蒂 &#x3D; 蜷缩) ^ (敲声 &#x3D; 浊响)</li>
<li>好瓜↔(色泽 &#x3D; *) ^ (根蒂 &#x3D; 蜷缩) ^ (敲声 &#x3D; *)</li>
</ol>
<p>这两个假设何者更简单的问题并不简单，<strong>需要借助其他机制</strong>才能解决。</p>
<hr>
<h2 id="数据挖掘与机器学习的联系"><a href="#数据挖掘与机器学习的联系" class="headerlink" title="数据挖掘与机器学习的联系"></a>数据挖掘与机器学习的联系</h2><p><strong>数据库领域的研究</strong>为数据挖掘提供<strong>数据管理技术</strong>；</p>
<p><strong>机器学习和统计学</strong>的研究为数据挖掘提供<strong>数据分析技术</strong>；(统计学主要通过机器学习对数据挖掘发挥影响)</p>
<hr>
<h1 id="模型评估与选择"><a href="#模型评估与选择" class="headerlink" title="模型评估与选择"></a>模型评估与选择</h1><h2 id="经验误差与过拟合"><a href="#经验误差与过拟合" class="headerlink" title="经验误差与过拟合"></a>经验误差与过拟合</h2><p>m个样本，a个样本分类错误</p>
<ul>
<li><strong>错误率(error rate)</strong> E &#x3D; a &#x2F; m：分类错误的样本数占样本总数的比例</li>
<li><strong>精度(accuracy)</strong>：1 - a &#x2F; m</li>
</ul>
<p>把训练样本自身的一些特点当作了所有潜在样本都会具有的一般性质，会导致泛化性能下降。这种现象在机器学习中称为**“过拟合”(overfitting)<strong>。</strong>“欠拟合”(underfitting)**指对训练样本的一般性质尚未学好。</p>
<hr>
<h2 id="评估方法"><a href="#评估方法" class="headerlink" title="评估方法"></a>评估方法</h2><p>包含$m$个样例的数据集$D&#x3D;{(x_1,y_1), (x_2,y_2),…,(x_m,y_m)}$，如果<strong>既要训练，又要测试</strong>，需要把数据集$D$进行适当的处理，从中产生出<strong>训练集$S$<strong>和</strong>测试集$T$</strong>。对数据集$D$的处理方法，有以下常见的几种。</p>
<hr>
<h3 id="留出法-hold-out"><a href="#留出法-hold-out" class="headerlink" title="留出法 (hold-out)"></a>留出法 (hold-out)</h3><p>留出法直接将数据集$D$划分为两个互斥的集合。在$S$上训练出模型后，<strong>用$T$来评估其测试误差，作为对泛化误差的估计</strong>。</p>
<p>训练&#x2F;测试集的划分要尽可能<strong>保持数据分布的一致性</strong>，避免因数据划分过程引入额外的偏差而对最终结果产生影响，例如在分类任务中至少要<strong>保持样本的类别比例相似</strong>。如果从<strong>采样</strong>的角度来看待数据集的划分过程，则<strong>保留类别比例</strong>的采样方式通常称为<strong>分层采样（stratified sampling)</strong>。若$S$、$T$中样本类别比例差别很大，则误差估计将由于训练&#x2F;测试数据分布的差异而产生偏差。</p>
<p>即使给定训练&#x2F;测试集的样本比例后，仍然存在多种划分方式对初始数据集$D$进行分割。因此，单次使用留出法得到的估计结果往往不够稳定可靠。使用留出法，<strong>一般要采用若干次随机划分、重复进行实验评估后取平均值</strong>作为留出法的评估结果。</p>
<p>常见的做法是<strong>将大约${\frac{2}{3}}$~${\frac{4}{5}}$的样本用于训练</strong>，剩余样本用于测试。</p>
<hr>
<h3 id="交叉验证法-cross-validation"><a href="#交叉验证法-cross-validation" class="headerlink" title="交叉验证法 (cross validation)"></a>交叉验证法 (cross validation)</h3><p>交叉验证法先将数据集$D$划分为$k$个大小相似的互斥子集，每个子集$D_i$都尽可能保持数据的一致性，即从$D$中通过分层采样得到。然后，<strong>每次用$k-1$个子集的并集作为训练集，剩下的那个子集作为测试集</strong>，这样就<strong>可以获得$k$组训练&#x2F;测试集，最终返回$k$个测试结果的平均值</strong>。</p>
<p>交叉验证法评估结果的<strong>稳定性和保证性很大程度上取决于k的取值</strong>，因此交叉验证法通常又称为**$k$折交叉验证($k$-fold cross validation)<strong>。$k$最常用的取值是10，此时称为</strong>10折交叉验证**，其他常用的k值有5、20等。</p>
<p>与留出法相似，将数据集$D$划分为$k$个子集同样存在多种划分方式。<strong>为减小因样本划分不同而引入的差别</strong>，$k$折交叉验证通常要随机使用不同的划分<strong>重复$p$次</strong>，最终结果是<strong>这$p$次$k$折交叉验证结果的均值</strong>，常见的有<strong>10次10折交叉验证</strong>。</p>
<hr>
<h3 id="自助法-bootstrapping"><a href="#自助法-bootstrapping" class="headerlink" title="自助法 (bootstrapping)"></a>自助法 (bootstrapping)</h3><p>自助法将给定包含$m$个样本的数据集$D$进行采样，产生数据集$D^{‘}$：每次随机从D中挑选一个样本，将其拷贝放入$D^{‘}$，这个过程<strong>重复执行$m$次</strong>，就得到了数据集$D^{‘}$。</p>
<p>$D$中有一部分样本会多次出现，另一部分样本则不出现。样本在$m$次采样中始终不被采到的概率是$(1-\frac{1}{m})^m$，取极限：$\displaystyle\lim_{x\to\infty}(1-\frac{1}{m})^m&#x3D;{\frac{1}{e}}\approx 0.368$。即通过自助采样，初始数据$D$中约有36.8%的样本不会出现在采样数据集$D^{‘}$中。于是，<strong>可将$D^{‘}$用作训练集，剩余样本用作测试集</strong>。这样，实际评估的模型与期望评估的模型都使用$m$个训练样本，而仍有数据总量约1&#x2F;3的、没在训练集中出现的样本用于测试。这样的测试结果，亦称**“包外估计”（out-of-bag estimate)**。</p>
<p>自助法在<strong>数据集较小、难以有效划分训练&#x2F;测试集</strong>时很有用；自助集能从初始数据集中产生多个不同的训练集，这<strong>对集成学习等方法有很大好处</strong>。</p>
<p>然而，自助法产生的数据<strong>改变了初始数据集的分布，会引入估计偏差</strong>。因此，在初始数据量足够时，<strong>留出法和交叉验证法更常用</strong>。</p>
<hr>
<h3 id="调参（parameter-tuning）与最终模型"><a href="#调参（parameter-tuning）与最终模型" class="headerlink" title="调参（parameter tuning）与最终模型"></a>调参（parameter tuning）与最终模型</h3><p>大多数学习算法都有些参数需要设定，参数配置不同，学得模型的性能往往有显著差别。因此，在进行模型评估与选择时，还需要算法参数进行设定，这就是常说的<strong>调参</strong>。</p>
<p>学习算法的很多参数<strong>在实数范围内取值</strong>，因此对每种参数配置都训练出模型是不可行的。常用的做法是，<strong>对每个参数选定一个范围和变化步长</strong>。例如，在$[0, 0.2]$范围内以0.05为步长，则实际要评估的候选参数数值有5个，最终从这5个候选值中产生选定值。显然，这样选定的参数值往往不是最佳值，但这是<strong>计算开销和性能估计之间进行折中的结果，通过这种折中，学习过程才变得可行</strong>。</p>
<p>在研究对比不同算法的泛化性能时，我们用测试集上的判别效果来估计模型在实际使用时的泛化能力。而<strong>把训练数据另外划分为训练集和验证集（validation set），基于验证集上的性能来进行模型选择和调参</strong>。</p>
<hr>
<h2 id="性能度量-performance-measure"><a href="#性能度量-performance-measure" class="headerlink" title="性能度量 (performance measure)"></a>性能度量 (performance measure)</h2><p>对学习器的泛性能进行评估，不仅需要有效可行的<strong>实验估计方法</strong>，还需要有<strong>衡量模型泛化能力的评价标准</strong>，这就是<strong>性能度量</strong>。</p>
<p>回归任务最常用的性能度量是<strong>均方误差（mean squared error）</strong>：</p>
<p>$$E(f; D)&#x3D;\frac{1}{m}\sum_{i&#x3D;1}^{m}(f(x_i)-y_i)^2$$</p>
<p>更一般地，对于数据分布D和概率密度函数p(·)，均方误差可描述为：</p>
<p>$$E(f; D)&#x3D;\int_{x\sim D}(f(x)-y)^2p(x)dx$$</p>
<hr>
<h3 id="错误率与精度"><a href="#错误率与精度" class="headerlink" title="错误率与精度"></a>错误率与精度</h3><p>在<a href="#%E7%BB%8F%E9%AA%8C%E8%AF%AF%E5%B7%AE%E4%B8%8E%E8%BF%87%E6%8B%9F%E5%90%88">经验误差与过拟合</a>中，提到了错误率和精度。这是分类任务中最常用的两种性能度量，既适用于二分类任务，也适用于多分类任务。</p>
<ul>
<li><p>错误率</p>
<p>  $$E(f;D)&#x3D;\frac{1}{m}\sum_{i&#x3D;1}^mⅡ(f(x_i)\ne y_i)$$</p>
</li>
<li><p>精度</p>
<p>  $$acc(f;D)&#x3D;\frac{1}{m}\sum_{i&#x3D;1}^mⅡ(f(x_i)&#x3D;y_i)&#x3D;1-E(f;D)$$</p>
</li>
</ul>
<p>更一般地，对于数据分布D和概率密度函数p(·)，错误率和精度可分别描述为</p>
<ul>
<li>$$E(f;D)&#x3D;\int_{x\sim D}Ⅱ(f(x)\ne y)p(x)dx$$</li>
<li>$$acc(f;D)&#x3D;\int_{x\sim D}Ⅱ(f(x)&#x3D;y)p(x)dx&#x3D;1-E(f;D)$$</li>
</ul>
<hr>
<h3 id="查准率-Precision-、查全率-Recall-与F1"><a href="#查准率-Precision-、查全率-Recall-与F1" class="headerlink" title="查准率(Precision)、查全率(Recall)与F1"></a>查准率(Precision)、查全率(Recall)与F1</h3><p>对于二分类问题，可将样例根据其真实类别与学习器预测类别的组合划分为<strong>真正例(True Positive)、假正例(False Positive)、真反例(True Negative)、假反例(False Negative)</strong>。</p>
<ul>
<li><p>样例总数&#x3D;$TP+FP+TN+FN$</p>
</li>
<li><p>查准率P</p>
<p>  $$P&#x3D;\frac{TP}{TP+FP}$$</p>
</li>
<li><p>查全率R</p>
<p>  $$R&#x3D;\frac{TP}{TP+FN}$$</p>
</li>
<li><p>基于P和R的**调和平均(harmonic mean)**定义的F1</p>
<p>  $$\frac{1}{F1}&#x3D;\frac{1}{2}(\frac{1}{P}+\frac{1}{R})$$</p>
</li>
</ul>
<p>在一些应用中，对查准率和查全率的重视程度不同。例如，在商品推荐系统中，为了尽可能少打扰用户，更希望推荐内容确实是用户感兴趣的，此时查准率更重要；而在逃犯信息检索系统中， 更希望尽可能少漏掉逃犯，查全率更重要。F1度量的一般形式$F_\beta$，能表达出不同的偏好：</p>
<p>$$\frac{1}{F_\beta}&#x3D;\frac{1}{1+\beta^2}(\frac{1}{P}+\frac{\beta^2}{R})$$</p>
<hr>
<h3 id="ROC与AUC"><a href="#ROC与AUC" class="headerlink" title="ROC与AUC"></a>ROC与AUC</h3><p>分类过程相当于以某个**截断点(cut point)**将样本分为两部分，前一部分判作正例，后一部分判作反例。</p>
<ul>
<li><p>ROC(Receiver Operating Characteristic)</p>
<p>  <strong>受试者工作特征曲线</strong>，根据学习器的预测结果对样例进行排序，按此顺序逐个把样本作为正例进行预测，每次计算出两个重要量的值，分别作为横纵坐标作图，就得到了ROC曲线。</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Hunter</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"Hunter1023/Hunter1023.github.io","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>

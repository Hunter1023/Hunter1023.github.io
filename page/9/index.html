<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"hunter1023.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":3,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Tough times never last, but tough people do.">
<meta property="og:type" content="website">
<meta property="og:title" content="Talk is cheap">
<meta property="og:url" content="https://hunter1023.github.io/page/9/index.html">
<meta property="og:site_name" content="Talk is cheap">
<meta property="og:description" content="Tough times never last, but tough people do.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Hunter">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://hunter1023.github.io/page/9/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/9/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Talk is cheap</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Talk is cheap</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hunter</p>
  <div class="site-description" itemprop="description">Tough times never last, but tough people do.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">98</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">175</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hunter1023.github.io/2020/06/13/Python%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hunter">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talk is cheap">
      <meta itemprop="description" content="Tough times never last, but tough people do.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Talk is cheap">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/06/13/Python%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Python之数据分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-13 08:14:22" itemprop="dateCreated datePublished" datetime="2020-06-13T08:14:22+08:00">2020-06-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-23 23:29:13" itemprop="dateModified" datetime="2025-01-23T23:29:13+08:00">2025-01-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">数据分析</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h2><p>Numpy是Python的一种开源的<strong>数值计算扩展</strong>。可以用来<strong>存储和处理大型矩阵</strong>，比Python自身的<strong>嵌套列表结构(nested list structure)<strong>要</strong>高效得多</strong>。在实际工作中<strong>直接使用情况较少</strong>。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/06/13/Python%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hunter1023.github.io/2020/06/01/Excel%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hunter">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talk is cheap">
      <meta itemprop="description" content="Tough times never last, but tough people do.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Talk is cheap">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/06/01/Excel%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">Excel技巧</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-01 19:45:47" itemprop="dateCreated datePublished" datetime="2020-06-01T19:45:47+08:00">2020-06-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-23 23:29:13" itemprop="dateModified" datetime="2025-01-23T23:29:13+08:00">2025-01-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">数据分析</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><table>
<thead>
<tr>
<th>功能</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>编辑单元格内容</td>
<td>【F2】</td>
</tr>
<tr>
<td>单元格内换行</td>
<td>【<strong>Alt</strong>】+【Enter】</td>
</tr>
<tr>
<td>设置单元格格式</td>
<td>【Ctrl】+【<strong>1</strong>】</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/33511879">Ctrl+E的众多效用</a><br />（拼接单元格内容、拆分提取单元格内容、<br />替换字符、去除空格和符号、自动换行…）</td>
<td>【Ctrl】+【 E】</td>
</tr>
<tr>
<td>筛选</td>
<td>【Ctrl】+【Shift】+【L】</td>
</tr>
<tr>
<td>输入当前日期</td>
<td>【Ctrl】+【;】</td>
</tr>
<tr>
<td>输入当前时间（不含日期）</td>
<td>【Ctrl】+【Shift】+【;】</td>
</tr>
<tr>
<td>切换sheet表</td>
<td>【Ctrl】+【PgUp&#x2F;PgDn】</td>
</tr>
<tr>
<td>快速求和</td>
<td>【Alt】+【&#x3D;】</td>
</tr>
<tr>
<td>数据透视表向导</td>
<td>【Alt+D】+【P】</td>
</tr>
<tr>
<td><strong>隐藏</strong>行<br /><strong>取消隐藏</strong>行</td>
<td>选定目标区域<br />【Ctrl】 + 【9】<br />【Ctrl】 + 【Shift】 + 【<strong>(</strong>】</td>
</tr>
<tr>
<td><strong>隐藏</strong>列<br /><strong>取消隐藏</strong>列</td>
<td>选定目标区域，<br />【Ctrl】 + 【0】<br />【Ctrl】 + 【Shift】 +【<strong>)</strong>】</td>
</tr>
<tr>
<td>展开或折叠<strong>单元格编辑栏</strong></td>
<td>【Ctrl】+【Shift】+【U】</td>
</tr>
<tr>
<td><strong>插入</strong>行<br /><strong>删除</strong>行</td>
<td>【Ctrl】+【Shift】+【<strong>+</strong>】<br />【Ctrl】+【-】</td>
</tr>
<tr>
<td><strong>设置千位分隔符，并四舍五入为整数</strong></td>
<td>【Ctrl】+【Shift】+【!】</td>
</tr>
<tr>
<td>设置<strong>百分数</strong>形式</td>
<td>【Ctrl】+【Shift】+【%】</td>
</tr>
<tr>
<td>设置<strong>外边框</strong></td>
<td>【Ctrl】+【Shift】+【&amp;】</td>
</tr>
</tbody></table>
<hr>
<h2 id="绝对引用行-列"><a href="#绝对引用行-列" class="headerlink" title="绝对引用行&#x2F;列"></a>绝对引用行&#x2F;列</h2><p>使用<code>$</code>符号即可<strong>绝对引用</strong>行<strong>或</strong>列</p>
<hr>
<h2 id="复制粘贴单元格"><a href="#复制粘贴单元格" class="headerlink" title="复制粘贴单元格"></a>复制粘贴单元格</h2><h3 id="筛选的情况下"><a href="#筛选的情况下" class="headerlink" title="筛选的情况下"></a>筛选的情况下</h3><p>未被筛选的行不会被复制</p>
<h3 id="隐藏的情况下"><a href="#隐藏的情况下" class="headerlink" title="隐藏的情况下"></a>隐藏的情况下</h3><p><strong>隐藏的行&#x2F;列依然会被复制</strong>，想要不复制被隐藏的行&#x2F;列，需要在选中指定区域后，使用【Alt】+【;】快捷键，再进行复制，即可顺利粘贴。</p>
<hr>
<h2 id="多个单元格中输入相同的数据"><a href="#多个单元格中输入相同的数据" class="headerlink" title="多个单元格中输入相同的数据"></a>多个单元格中输入相同的数据</h2><ol>
<li>选中所有目标单元格</li>
<li>输入所需数据，按下【Ctrl】+【Enter】组合键即可。</li>
</ol>
<hr>
<h2 id="多个单元格中有部分内容需要重复输入"><a href="#多个单元格中有部分内容需要重复输入" class="headerlink" title="多个单元格中有部分内容需要重复输入"></a>多个单元格中有部分内容需要重复输入</h2><p>如：邮箱后缀、电话区号、订单号前缀</p>
<p>希望达到效果：只需向单元格中输入不一样的内容部分，<strong>重复部分自动填充</strong></p>
<p>操作：</p>
<ol>
<li><p>选定需要设置的单元格范围，<strong>设置单元格格式</strong>(Ctrl + 1)</p>
</li>
<li><p><strong>数字</strong> - 分类 - 自定义 - 类型</p>
</li>
<li><p>输入框中填写需要的格式</p>
<ol>
<li><p><strong>添加邮箱共同后缀</strong></p>
<p>输入<code>@&quot;@163.com&quot;</code></p>
</li>
<li><p><strong>添加电话区号</strong>：</p>
<p>输入<code>&quot;0755-&quot;@</code></p>
</li>
</ol>
<p><code>@</code>用于<strong>在数字格式中包含文本</strong>，否则文本将不会显示出来</p>
</li>
</ol>
<hr>
<h2 id="条件格式的设置"><a href="#条件格式的设置" class="headerlink" title="条件格式的设置"></a>条件格式的设置</h2><hr>
<h2 id="批量从身份证号中提取生日"><a href="#批量从身份证号中提取生日" class="headerlink" title="批量从身份证号中提取生日"></a>批量从身份证号中提取生日</h2><p>编辑单元格：<code>=TEXT(MID(身份证号所在单元格, 起始位数, 提取长度), &quot;生日格式&quot;(如0000-00-00))</code></p>
<hr>
<h2 id="筛选出重复值-唯一值"><a href="#筛选出重复值-唯一值" class="headerlink" title="筛选出重复值(唯一值)"></a>筛选出重复值(唯一值)</h2><ol>
<li>选中<strong>需要筛选出重复值(唯一值)的范围</strong></li>
<li>开始 - 样式 - 条件格式 - <strong>突出显示单元格规则</strong> - <strong>重复值</strong></li>
</ol>
<hr>
<h2 id="去除重复值"><a href="#去除重复值" class="headerlink" title="去除重复值"></a>去除重复值</h2><ol>
<li>选择需要去重的单元格区域</li>
<li><strong>数据 - 数据工具 - 删除重复值</strong></li>
</ol>
<hr>
<h2 id="长数字输入"><a href="#长数字输入" class="headerlink" title="长数字输入"></a>长数字输入</h2><ul>
<li>Excel单元格<strong>常规型数字</strong>的特殊机制<ol>
<li>输入的数字**＞11位<strong>时，<strong>自动</strong>采用</strong>科学计数法**</li>
<li>数字的<strong>精度</strong>是<strong>15</strong>位</li>
</ol>
</li>
</ul>
<p>最佳解决方式：</p>
<p>设置单元格格式(<strong>Ctrl + 1</strong>) - 数字 - 分类 - <strong>文本</strong></p>
<hr>
<h2 id="冻结窗口"><a href="#冻结窗口" class="headerlink" title="冻结窗口"></a>冻结窗口</h2><ul>
<li>冻结<strong>指定的某行&#x2F;列</strong>：选中需要冻结的行或列，选择<strong>视图 - 窗口 - 冻结窗格</strong>即可</li>
<li>冻结<strong>指定的多行以及多列</strong>：<ol>
<li><strong>视图 - 窗口 - 拆分</strong>，会显示一个<strong>十字型的拆分参考线</strong>。</li>
<li>移动拆分参考线至所需的行、列</li>
<li>视图 - 窗口 - <strong>冻结窗口</strong></li>
</ol>
</li>
</ul>
<hr>
<h2 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h2><h3 id="粘贴值"><a href="#粘贴值" class="headerlink" title="粘贴值"></a>粘贴值</h3><p>文件 - 选项 - 快速访问工具栏 - 从下列位置选择命令 - 所有命令 - 粘贴值 - 添加至右侧，之后就可通过【Alt】+ 【提示的另一个键】即可实现快捷键操作。</p>
<hr>
<h2 id="选中整行-整列-数据"><a href="#选中整行-整列-数据" class="headerlink" title="选中整行&#x2F;整列 数据"></a>选中整行&#x2F;整列 数据</h2><ul>
<li>选中整行<strong>数据</strong>：选定<strong>起始单元格</strong>，<code>Ctrl + Shift + →</code></li>
<li>选中整列<strong>数据</strong>：选定<strong>起始单元格</strong>，<code>Ctrl + Shift + ↓</code></li>
</ul>
<hr>
<h2 id="数据透视表"><a href="#数据透视表" class="headerlink" title="数据透视表"></a>数据透视表</h2><p>数据透视表(Pivot Table) 是一种交互式的表，可以进行某些计算，如求和与计数等，所进行的计算与数据跟数据透视表中的排列有关。</p>
<p>之所以称为数据透视表，是因为<strong>可以动态地改变它们的版面布置</strong>，<strong>以便按照不同方式分析数据</strong>，也可以重新安排行号、列标和页字段。每一次改变版面布置时，数据透视表会立即按照新的布置重新计算数据。另外，<strong>如果原始数据发生更改，则可以更新数据透视表</strong>。</p>
<ol>
<li>选择需要透视的表格区域</li>
<li>插入 - 表格 - 数据透视表</li>
</ol>
<hr>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="VLOOKUP函数"><a href="#VLOOKUP函数" class="headerlink" title="VLOOKUP函数"></a>VLOOKUP函数</h3><p>按<strong>列</strong>查找，最终返回查询序列中所对应的值。</p>
<p>与之对应的HLOOKUP是按行查找的。</p>
<ul>
<li>使用场景：<ol>
<li>两张表格</li>
<li>两张表格中<strong>存在相同列</strong></li>
<li>表2中存在表1不具备的字段，想把表2中的字段关联到表1中</li>
</ol>
</li>
<li>单元格中输入：<code>=VLOOKUP(lookup_value，table_array，col_index_num，range_lookup)</code><ol>
<li>lookup_value：查找的值</li>
<li>table_array：要查找的区域</li>
<li>col_index_num：需要返回的元素在区域中的第几<strong>列</strong></li>
<li>range_lookup：<strong>精确</strong>匹配&#x2F;<strong>近似</strong>匹配<ul>
<li><strong>1</strong>&#x2F;<strong>TRUE</strong>：<strong>近似</strong>匹配</li>
<li><strong>0</strong>&#x2F;<strong>FALSE</strong>：<strong>精确</strong>匹配</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="INDEX-MATCH-函数"><a href="#INDEX-MATCH-函数" class="headerlink" title="INDEX + MATCH 函数"></a>INDEX + MATCH 函数</h3><ul>
<li><p>使用场景：</p>
<p>  功能与VLOOKUP函数基本相同，但是<strong>能弥补VLOOKUP函数的局限性</strong>(想要关联的列<strong>在相同列的左侧</strong>时，<strong>无法匹配</strong>)。</p>
</li>
<li><p><code>MATCH(lookup_value, lookup_array, [match_type])</code></p>
<ol>
<li>lookup_value：查找的值</li>
<li>lookup_array：查找<strong>区域(只能1列宽)</strong></li>
<li>[match_type]：<ul>
<li>1：<strong>小于</strong></li>
<li>0：<strong>精确匹配</strong></li>
<li>-1：<strong>大于</strong></li>
</ul>
</li>
</ol>
<p>  结果返回<strong>查找区域中的所在行数</strong></p>
</li>
<li><p><code>INDEX(array, row_num, [column_num])</code></p>
<ol>
<li>array：查找区域</li>
<li>row_num：所在<strong>行数</strong>(<strong>通过MATCH函数获取</strong>)</li>
<li>[column_num]：所在列数</li>
</ol>
</li>
</ul>
<hr>
<h3 id="AND-函数-OR-函数"><a href="#AND-函数-OR-函数" class="headerlink" title="AND 函数 &#x2F; OR 函数"></a>AND 函数 &#x2F; OR 函数</h3><ul>
<li><code>AND(logical1,[logical2],...)</code></li>
<li><code>OR(logical1,[logical2],...)</code></li>
</ul>
<p>用于<strong>条件判断</strong></p>
<hr>
<h3 id="IF-函数"><a href="#IF-函数" class="headerlink" title="IF 函数"></a>IF 函数</h3><p><code>IF(logical_test, [value_if_true], [value_if_false])</code>：</p>
<ol>
<li>logical_test：<strong>逻辑判断</strong></li>
<li>[value_if_true]：结果为true时的值(<strong>字符串</strong>使用<strong>双引号标注</strong>)</li>
<li>[value_if_false]：结果为false时的值</li>
</ol>
<p>例子：使用IF函数，判断业绩完成情况</p>
<p>单元格中输入：<code>=IF(N4-M4&gt;=0,&quot;已完成&quot;, M4-N4)</code></p>
<h4 id="IF-函数嵌套-示例"><a href="#IF-函数嵌套-示例" class="headerlink" title="IF 函数嵌套 示例"></a>IF 函数嵌套 示例</h4><p><code>=IF(AND(O4=&quot;已完成&quot;,R4=&quot;已完成&quot;),&quot;已完成&quot;,IF(AND(O4=&quot;已完成&quot;,R4&lt;&gt;&quot;已完成&quot;),&quot;仅业绩完成&quot;,IF(AND(O4&lt;&gt;&quot;已完成&quot;,R4=&quot;已完成&quot;),&quot;仅入会完成&quot;,&quot;均未完成&quot;)))</code></p>
<hr>
<h3 id="COUNTIFS-函数"><a href="#COUNTIFS-函数" class="headerlink" title="COUNTIFS 函数"></a>COUNTIFS 函数</h3><p><code>COUNTIFS(criteria_range1, criteria1,...)</code></p>
<ul>
<li><p>使用场景：</p>
<p>  对区域中<strong>符合条件的单元格</strong>进行筛选<strong>计数</strong>。</p>
</li>
<li><p>参数：</p>
<ul>
<li><p>criteria_range1: 筛选<strong>区域</strong></p>
</li>
<li><p>criteria1：<strong>筛选</strong>条件</p>
</li>
<li><p>criteria_range2</p>
<p>  …</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="SUMIFS-函数"><a href="#SUMIFS-函数" class="headerlink" title="SUMIFS 函数"></a>SUMIFS 函数</h3><p><code>SUMIFS(sum_range, criteria_range1, criteria1,...)</code></p>
<ul>
<li><p>使用场景：</p>
<p>  对区域中<strong>符合条件的单元格</strong>进行筛选<strong>求和</strong>。</p>
</li>
<li><p>参数：</p>
<ul>
<li><p>sum_range：<strong>求和区域</strong></p>
</li>
<li><p>criteria_range1：筛选<strong>区域</strong></p>
</li>
<li><p>criteria1：<strong>筛选</strong>条件</p>
</li>
<li><p>criteria_range2</p>
<p>  …</p>
</li>
</ul>
<p>  <strong>求和区域和筛选区域，类似VLOOKUP函数中两张表的感觉</strong>。</p>
</li>
</ul>
<hr>
<h3 id="LEFT、MID、RIGHT-函数"><a href="#LEFT、MID、RIGHT-函数" class="headerlink" title="LEFT、MID、RIGHT 函数"></a>LEFT、MID、RIGHT 函数</h3><ul>
<li><code>LEFT(text, [num_chars])</code></li>
<li><code>MID(text, start_num, num_chars)</code></li>
<li><code>RIGHT(text, [num_chars])</code><ul>
<li>text：文本所在单元格</li>
<li>start_num：起始位置是第几个字符</li>
<li>num_chars：截取的字符长度</li>
</ul>
</li>
</ul>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/68af835de06a">数据分析中常用的9个Excel函数 - 简书</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hunter1023.github.io/2020/02/16/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hunter">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talk is cheap">
      <meta itemprop="description" content="Tough times never last, but tough people do.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Talk is cheap">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/16/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB/" class="post-title-link" itemprop="url">算法题目分类</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-16 12:18:51" itemprop="dateCreated datePublished" datetime="2020-02-16T12:18:51+08:00">2020-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-23 23:29:13" itemprop="dateModified" datetime="2025-01-23T23:29:13+08:00">2025-01-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>根据《算法笔记》一书，对PAT甲级、乙级真题和<a target="_blank" rel="noopener" href="http://codeup.cn/contest.php">codeup</a>部分试题进行分类。</p>
<h2 id="1-C-C-快速入门"><a href="#1-C-C-快速入门" class="headerlink" title="1. C&#x2F;C++快速入门"></a>1. C&#x2F;C++快速入门</h2><h3 id="1-1-数组"><a href="#1-1-数组" class="headerlink" title="1.1 数组"></a>1.1 数组</h3><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39345384/article/details/104146906">codeup 杨辉三角</a></li>
</ul>
<hr>
<h3 id="1-2-指针"><a href="#1-2-指针" class="headerlink" title="1.2 指针"></a>1.2 指针</h3><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39345384/article/details/104151149">codeup C语言10.16</a></li>
</ul>
<hr>
<h3 id="1-3-结构体的使用"><a href="#1-3-结构体的使用" class="headerlink" title="1.3 结构体的使用"></a>1.3 结构体的使用</h3><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39345384/article/details/104156997">codeup C语言11.1</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39345384/article/details/104158080">codeup C语言11.2</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39345384/article/details/104158719">codeup C语言11.4</a></li>
</ul>
<hr>
<h2 id="2-入门模拟"><a href="#2-入门模拟" class="headerlink" title="2. 入门模拟"></a>2. 入门模拟</h2><h3 id="2-1-简单模拟"><a href="#2-1-简单模拟" class="headerlink" title="2.1 简单模拟"></a>2.1 简单模拟</h3><p><strong>不涉及算法，只是根据题目描述来编写代码，考察代码能力。</strong></p>
<table>
<thead>
<tr>
<th>题目</th>
<th>解题关键</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39345384/article/details/104163314">codeup 问题 B: A+B</a></td>
<td>\</td>
</tr>
<tr>
<td><strong>B1001 害死人不偿命的(3n+1)猜想</strong></td>
<td>\</td>
</tr>
<tr>
<td><strong>B1010 一元多项式求导</strong></td>
<td>\</td>
</tr>
<tr>
<td><strong>B1011 A+B和C</strong></td>
<td>\</td>
</tr>
<tr>
<td><strong>B1012 数字分类</strong></td>
<td>有条不紊地整理</td>
</tr>
<tr>
<td><strong>B1016 部分A+B</strong></td>
<td>\</td>
</tr>
<tr>
<td><strong>B1018 锤子剪刀布</strong></td>
<td><strong>注意scanf留在缓冲区的换行符<code>\n</code>的处理</strong></td>
</tr>
<tr>
<td><strong>B1026 程序运行时间</strong></td>
<td>\</td>
</tr>
<tr>
<td><strong>B1032 挖掘机技术哪家强</strong></td>
<td>统计各学校总分的方式</td>
</tr>
<tr>
<td><strong>B1046 划拳</strong></td>
<td>\</td>
</tr>
<tr>
<td><strong>A1002</strong> <strong>A+B for Polynomials</strong></td>
<td>非零系数项个数的统计</td>
</tr>
<tr>
<td><strong>A1009</strong> <strong>Product of Polynomials</strong></td>
<td>第二个多项式可边读边处理</td>
</tr>
<tr>
<td><strong>A1042</strong> <strong>Shuffling Machine</strong></td>
<td><strong>将扑克顺序号转为实际牌号的方式</strong></td>
</tr>
<tr>
<td><strong>A1046 Shortest Distance</strong></td>
<td>便于计算距离的方式</td>
</tr>
<tr>
<td><strong>A1065</strong> <strong>A+B and C (64bit)</strong></td>
<td><strong>B1011</strong> <strong>A+B 和 C 进阶版</strong><br /><strong>负数相加若溢出，可能得到0</strong></td>
</tr>
</tbody></table>
<hr>
<h3 id="2-2-查找元素"><a href="#2-2-查找元素" class="headerlink" title="2.2 查找元素"></a>2.2 查找元素</h3><p>查找是学习写代码的一项基本功。</p>
<ul>
<li>一般来说，如果需要在一个比较小范围的数据集内内进行查找，<strong>直接遍历</strong>即可。</li>
<li>如果需要查找的范围较大，可以用<a href="#35-%E4%BA%8C%E5%88%86">二分查找</a><strong>等算法</strong>进行更快速的查找</li>
</ul>
<table>
<thead>
<tr>
<th>题目</th>
<th>解题关键</th>
</tr>
</thead>
<tbody><tr>
<td><strong>B1004</strong> <strong>成绩排名</strong></td>
<td>\</td>
</tr>
<tr>
<td><strong>B1028</strong> <strong>人口普查</strong></td>
<td><strong>1. 不合理年龄的判断方式</strong><br /><strong>2. 需要考虑全不合理的情况</strong></td>
</tr>
<tr>
<td><strong>B1032</strong> <strong>挖掘机技术哪家强</strong></td>
<td>统计各学校总分的方式</td>
</tr>
<tr>
<td><strong>B1041</strong> <strong>考试座位号</strong></td>
<td>\</td>
</tr>
<tr>
<td><strong>A1011</strong> <strong>World Cup Betting</strong></td>
<td>\</td>
</tr>
<tr>
<td><strong>A1006</strong> <strong>Sign In and Sign Out</strong></td>
<td>方法类似 B1028 人口普查</td>
</tr>
<tr>
<td><strong>A1036</strong> <strong>Boys vs Girls</strong></td>
<td>\</td>
</tr>
</tbody></table>
<hr>
<h3 id="2-3-图形输出"><a href="#2-3-图形输出" class="headerlink" title="2.3 图形输出"></a>2.3 图形输出</h3><p>做法一般有两种：</p>
<ul>
<li>通过规律，直接进行输出</li>
<li>定义一个二维字符数组，通过规律填充，然后输出整个二维数组</li>
</ul>
<table>
<thead>
<tr>
<th>题目</th>
<th>解题关键</th>
</tr>
</thead>
<tbody><tr>
<td><strong>B1027</strong> <strong>打印沙漏</strong></td>
<td><strong>沙漏高度和符号数量的关系</strong></td>
</tr>
<tr>
<td><strong>B1036</strong> <strong>跟奥巴马一起编程</strong></td>
<td>\</td>
</tr>
<tr>
<td><strong>A1031</strong> <strong>Hello World for U</strong></td>
<td>根据 n1和n3为  $\leq$ n2，且满足 n1+n2+n3 &#x3D; N+2 的最大值，求出n1，n2，n3</td>
</tr>
</tbody></table>
<hr>
<h3 id="2-4-日期处理"><a href="#2-4-日期处理" class="headerlink" title="2.4 日期处理"></a>2.4 日期处理</h3><p>需要处理好<strong>平年和闰年、大月和小月</strong>的问题，需要<strong>细心</strong>处理。</p>
<p>闰年的判断方法：</p>
<ol>
<li><p><strong>非整百年</strong>：能<strong>被4整除</strong>为闰年</p>
</li>
<li><p><strong>整百年</strong>：能<strong>被400整除</strong>的是闰年（<strong>1900年不是闰年</strong>）</p>
</li>
</ol>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39345384/article/details/104252546">codeup 问题 A: 日期差值</a></li>
</ul>
<hr>
<h3 id="2-5-进制转换"><a href="#2-5-进制转换" class="headerlink" title="2.5 进制转换"></a>2.5 进制转换</h3><p>对一个<strong>P进制的数</strong>，如果要<strong>转换为Q进制</strong>，需要分两步：</p>
<ol>
<li><p>将 P进制数x <strong>转换为 十进制数y</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int y &#x3D; 0, pro &#x3D; 1;
while(x !&#x3D; 0) &#123;
    y +&#x3D; (x % 10) * pro;
    x &#x2F;&#x3D; 10;
    pro *&#x3D; p;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>将 十进制数y <strong>转换为 Q进制数z</strong></p>
<p>采用<strong>除基取余法</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int z[40], num &#x3D; 0; &#x2F;&#x2F;数组z 存放 Q进制数y 的每一位，num为位数
do &#123;
    z[num++] &#x3D; y % Q; &#x2F;&#x2F;除基取余
    y &#x2F;&#x3D; Q;
&#125; while(y !&#x3D; 0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用<code>do···while</code>语句而不是<code>while</code>的原因是：<strong>如果十进制数y &#x3D; 0，使用<code>while</code>语句将使循环直接跳出，导致结果出错</strong>。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>题目</th>
<th>解题关键</th>
</tr>
</thead>
<tbody><tr>
<td><strong>B1022</strong> <strong>D进制的A+B</strong></td>
<td><strong>除基取余法</strong></td>
</tr>
<tr>
<td><strong>B1037</strong> <strong>在霍格沃茨找零钱</strong></td>
<td>\</td>
</tr>
<tr>
<td><strong>A1019</strong> <strong>General Palindromic Number</strong></td>
<td>\</td>
</tr>
<tr>
<td><strong>A1027</strong> <strong>Colors in Mars</strong></td>
<td>\</td>
</tr>
<tr>
<td><strong>A1058</strong> <strong>A+B in Hogwarts</strong></td>
<td>题型同 乙级1037 在霍格沃茨找零钱<br />单位转换过程可能会超过int范围</td>
</tr>
</tbody></table>
<hr>
<h3 id="2-6-字符串处理"><a href="#2-6-字符串处理" class="headerlink" title="2.6 字符串处理"></a>2.6 字符串处理</h3><p>考察<strong>代码能力</strong>的题型。一般需要<strong>仔细分析清楚</strong>题目中的<strong>输入和输出格式</strong>才能顺利AC。</p>
<p>有些题目中，可能<strong>实现逻辑非常麻烦</strong>，有很多<strong>细节</strong>和<strong>边界</strong>情况，此类题目需要<strong>多做多想，积累经验</strong>。</p>
<table>
<thead>
<tr>
<th>题目</th>
<th>解题关键</th>
</tr>
</thead>
<tbody><tr>
<td><strong>B1002</strong> <strong>写出这个数</strong></td>
<td><strong>数字转为字符串</strong>：<br />C语言：<code>sprintf(str, &quot;%d&quot;, num)</code><br />C++：<code>to_string(num)</code></td>
</tr>
<tr>
<td><strong>B1006</strong> <strong>换个格式输出整数</strong></td>
<td>\</td>
</tr>
<tr>
<td><strong>B1009</strong> <strong>说反话</strong></td>
<td><strong>句子颠倒，单词本身不颠倒</strong><br />C++ 待更新</td>
</tr>
<tr>
<td><strong>B1014</strong> <strong>福尔摩斯的约会</strong><br /><strong>A1061</strong> <strong>Dating</strong></td>
<td><strong>正确归纳</strong>解码方式</td>
</tr>
<tr>
<td><strong>B1021</strong> <strong>个位数统计</strong></td>
<td>\</td>
</tr>
<tr>
<td><strong>B1024</strong> <strong>科学计数法</strong><br /><strong>A1073</strong> <strong>Scientific Notation</strong></td>
<td><strong>1. 利用正则表达式，分开读取 数字部分 和 指数部分</strong><br />2. 指数 &lt; 0：整数部分必然为 0<br />3. 指数 &gt;&#x3D; 0：<br/>     - <strong>仍有小数点，何时输出小数点</strong><br/>     - 没有小数点，后续输出0</td>
</tr>
<tr>
<td><strong>B1031</strong> <strong>查验身份证</strong></td>
<td>\</td>
</tr>
<tr>
<td><strong>B1048</strong> <strong>数字加密</strong></td>
<td><strong>1. 对齐两个整数</strong> <br/>     - 若加密正整数A 比 B 长，B<strong>高位补0</strong>后进行加密 <br/>     - 若加密正整数A 比 B 短，B<strong>多余的部分正常输出，等同于A高位补0</strong>后进行加密 <br/> 2. 结果从数字高位(<strong>字符串低位</strong>)<strong>开始输出</strong></td>
</tr>
<tr>
<td><strong>A1001</strong> <strong>A+B Format</strong></td>
<td>从<strong>数字高位(字符串低位)开始</strong>，需要添加<code>,</code>的位置满足**<code>(i + 1) % 3 == len % 3</code> 且 不是最后一位**</td>
</tr>
<tr>
<td><strong>A1005</strong> <strong>Spell It Right</strong></td>
<td>\</td>
</tr>
<tr>
<td><strong>A1035</strong> <strong>Password</strong></td>
<td>(待优化)</td>
</tr>
<tr>
<td><strong>A1077</strong> <strong>Kuchiguse</strong></td>
<td><strong>1. 通过<code>reverse()</code>反转字符串，将后缀转换为前缀，便于比较</strong><br />2. <code>getline()</code>之前注意<strong>读取换行符</strong>。</td>
</tr>
<tr>
<td><strong>A1082</strong> <strong>Read Number in Chinese</strong></td>
<td>1. <strong>四位数字分为一节</strong>，单位为个、万、亿<br />2. <strong>一节中数字全为0</strong>，则不输出<strong>节的单位</strong><br />3. 节中<strong>第一个非零数之前有0</strong>，则输出<strong>1个</strong>0</td>
</tr>
</tbody></table>
<hr>
<h2 id="3-算法初步"><a href="#3-算法初步" class="headerlink" title="3. 算法初步"></a>3. 算法初步</h2><h3 id="3-1-排序"><a href="#3-1-排序" class="headerlink" title="3.1 排序"></a>3.1 排序</h3><h4 id="3-1-1-简单选择排序（-O-n-2-）"><a href="#3-1-1-简单选择排序（-O-n-2-）" class="headerlink" title="3.1.1 简单选择排序（$O(n^2)$）"></a>3.1.1 简单选择排序（$O(n^2)$）</h4><p>简单选择排序是指，对一个序列A中的元素<code>A[0] ~ A[n-1]</code>，令<code>i</code>从 0 到 n-1 枚举，进行 n 趟操作，每一趟从<strong>待排部分</strong>$[i, n-1]$中<strong>选择最小元素（记录下标）</strong>，令其<strong>与待排部分</strong>的**第一个元素A[i]**进行交换，使得$[0, i]$<strong>区间有序</strong>。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void selectSort(int A[]) &#123; &#x2F;&#x2F;降序 简单选择排序
    for(int i &#x3D; 0; i &lt; n; i++) &#123;
        int k &#x3D; i;
        for(int j &#x3D; i; j &lt; n; j++) &#123; &#x2F;&#x2F;选出最小的元素
            if(A[j] &lt; A[i])
                k &#x3D; j; &#x2F;&#x2F;记录更小元素的下标
        &#125;
        int tmp &#x3D; A[i]; &#x2F;&#x2F;交换A[k]与A[i]
        A[i] &#x3D; A[j];
        A[j] &#x3D; tmp;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h4 id="3-1-2-直接插入排序（-O-n-2-）"><a href="#3-1-2-直接插入排序（-O-n-2-）" class="headerlink" title="3.1.2 直接插入排序（$O(n^2)$）"></a>3.1.2 直接插入排序（$O(n^2)$）</h4><p>直接插入排序是指，对序列A的n个元素<code>A[0]~A[n-1]</code>，令 i **从 1 **到 n-1 枚举，进行 n - 1 趟操作。</p>
<p>某一趟时，序列A的前 i 个元素 <code>A[0]~A[i-1]</code>已经有序，则该趟在范围$[0, i - 1]$中，<strong>从后往前</strong>寻找某个位置j，使得<code>A[i]</code>插入后，范围$[0, i]$有序(<strong><code>A[j]~A[i]</code>后移一位</strong>)。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void insertSort(int A[]) &#123; &#x2F;&#x2F;升序 直接插入排序
    for(int i &#x3D; 1; i &lt; n; i++) &#123;
        int tmp &#x3D; A[i], j &#x3D; i;
        &#x2F;&#x2F;从后往前遍历，便于编写代码
        while(j &gt; 0 &amp;&amp; tmp &lt; A[j - 1]) &#123;
            A[j] &#x3D; A[j - 1];
            j--;
        &#125;
        A[j] &#x3D; tmp;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h4 id="3-1-3-冒泡排序（-O-n-2-）"><a href="#3-1-3-冒泡排序（-O-n-2-）" class="headerlink" title="3.1.3 冒泡排序（$O(n^2)$）"></a>3.1.3 冒泡排序（$O(n^2)$）</h4><p>冒泡排序的本质在于<strong>交换</strong>，即每次通过交换的方式把当前<strong>剩余元素的最大值(升序)<strong>移动到一端，当</strong>剩余元素减少到0</strong>时，排序结束。整个过程执行 <strong>n-1 趟</strong>，每一趟<strong>从左到右依次比较相邻的元素</strong>，如果<strong>大的数在左边，则交换</strong>，该趟结束时，<strong>最大数</strong>被移动到<strong>当前剩余数的最右边</strong>。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void bubbleSort(int A[]) &#123; &#x2F;&#x2F;升序 冒泡排序
    for(int i &#x3D; 1; i &lt; n; i++) &#123;&#x2F;&#x2F;进行 n - 1 趟排序
        for(int j &#x3D; 0; j &lt; n - i; j++) &#123;
            if(a[j] &gt; a[j + 1]) &#123;
                int tmp &#x3D; a[j];
                a[j] &#x3D; a[j + 1];
                a[j + 1] &#x3D; tmp;
            &#125;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<hr>
<h4 id="3-1-4-排序题与sort函数的应用"><a href="#3-1-4-排序题与sort函数的应用" class="headerlink" title="3.1.4 排序题与sort函数的应用"></a>3.1.4 排序题与sort函数的应用</h4><p>PAT中的排序题，大部分<strong>只需要得到排序的最终结果，而不需要去写排序的完整过程(例如冒泡排序、快速排序等)</strong>，因此推荐直接使用<strong>C语言的库函数<code>qsort</code><strong>或是</strong>C++的<code>sort</code>函数</strong>进行排序。<code>qsort</code>函数的使用需要运用指针，且写法上没有<code>sort</code>函数简洁。<code>sort</code>函数<strong>根据具体情形使用不同的排序方法</strong>，效率较高，在实现中<strong>规避了经典快速排序中可能出现的会导致实际复杂度退化到$O(n^2)$的极端情况</strong>。</p>
<p>因此<strong>更推荐使用C++的<code>sort</code>函数</strong>进行代码编写。</p>
<ul>
<li><p><strong>结构体数组的排序</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct node &#123;
    int x;
    int y;
&#125; ssd[10];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果想先<strong>按x</strong>从大到小排序，<strong>在x相等的情况下</strong>，<strong>按y</strong>从小到大排序(即<strong>二级排序</strong>)，cmp的写法是：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool cmp(node a, node b) &#123; &#x2F;&#x2F;返回值为true时，a排在b之前
    if(a.x !&#x3D; b.x) &#123;
        return a.x &gt; b.x; &#x2F;&#x2F;降序
    &#125; else &#123;
        return a.y &lt; b.y; &#x2F;&#x2F;升序
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>排名的实现</strong></p>
<p>很多排序题要求<strong>在排序之后</strong>计算每个个体的<strong>排名</strong>，规则一般是：<strong>分数相同的排名相同，占用一个排位</strong>。例如有5个学生的分数分别为90、88、88、88、86，其排名分别为1、2、2、2、5。</p>
<p><strong>方法：</strong></p>
<p>将第一个个体排名记为1，遍历剩余个体，如果当前分数等于上一个个体的分数，则当前个体排名等于<strong>上一个个体的排名</strong>，否则当前个体的排名等于<strong>数组下标+1</strong></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>题目</th>
<th>解题关键</th>
</tr>
</thead>
<tbody><tr>
<td><strong>B1015</strong> <strong>德才论</strong><br /><strong>A1062</strong> <strong>Talent and Virtue</strong></td>
<td>设置flag作为考生的分类，便于所有考生<strong>统一排序</strong></td>
</tr>
<tr>
<td><strong>A1012</strong> <strong>The Best Rank</strong></td>
<td>1. <strong>利用全局变量设计cmp函数</strong><br />2. 通过<strong>记录所有科目的排名</strong>，最后选出最好的排名以及对应科目<br />3. 相同分数者排名相同，<strong>下一不同分数者</strong>排名为<strong>数组下标+1</strong></td>
</tr>
<tr>
<td><strong>A1016</strong> <strong>Phone Bills</strong></td>
<td><strong>（待优化）</strong><br />1. <strong>通话记录统一先排序</strong>后处理<br />2. <strong>连续的两个通话记录，判断是否为 同一用户 且 为先通话后挂断的状态</strong><br />3. <strong>通话时长的统计方法</strong><br />4. 单位美分cents 要转换为 美元$</td>
</tr>
<tr>
<td><strong>A1025</strong> <strong>PAT Ranking</strong></td>
<td>\</td>
</tr>
<tr>
<td><strong>A1028</strong> <strong>List Sorting</strong></td>
<td>\</td>
</tr>
<tr>
<td><strong>A1055</strong> <strong>The World’s Richest</strong></td>
<td><strong>超时问题。要求输出的人数$\leq$100，通过筛去每个年龄多余的人解决</strong></td>
</tr>
<tr>
<td><strong>A1075</strong> <strong>PAT Judge</strong></td>
<td><strong>(待优化)</strong><br />1. <strong>不能编译</strong>的提交<strong>得分为0</strong><br />2. 没有提交过的答案需要输出为<code>-</code>，利用<code>&lt;cstring&gt;</code>中的<code>memset</code>函数，<strong>为 得分数组 赋值 -1，表示没有提交过答案</strong><br />3. <strong>没有任何一题通过编译 或 没有提交过答案的人</strong>不记录排名，<strong>设置 是否有通过编译的标识</strong>，进行筛选<br />4. 读取数据时，<strong>将用户数组下标看作id</strong>，便于统计<br />5. 排序<strong>以 是否有通过编译 为 第一排序条件</strong></td>
</tr>
<tr>
<td>A1080</td>
<td></td>
</tr>
<tr>
<td>A1083</td>
<td></td>
</tr>
<tr>
<td>A1095</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h3 id="3-2-散列"><a href="#3-2-散列" class="headerlink" title="3.2 散列"></a>3.2 散列</h3><h4 id="3-2-1-散列-hash-的定义与整数散列"><a href="#3-2-1-散列-hash-的定义与整数散列" class="headerlink" title="3.2.1 散列(hash)的定义与整数散列"></a>3.2.1 散列(hash)的定义与整数散列</h4><blockquote>
<p>例题:</p>
<p>给出$N$个正整数，再给出$M$个正整数，问这$M$个数中的每个数分别是否在$N$个数中出现过，其中 $N, M \leq10^5$，且所有正整数均不超过$10^5$。例如 $N &#x3D; 5，M &#x3D; 3$， $N$个正整数为 ${8， 3， 7， 6， 2}$，欲查询的$M$个正整数为 ${7， 4， 2}$。</p>
</blockquote>
<p>对这个问题，最直观的思路是：对每个欲查询的正整数$x$，遍历所有$N$个数，看是否有一个数与$x$相等。这种做法的时间复杂度为$O(NM)$，显然不是好方法。可以采取<strong>用空间换时间</strong>的方式，用<strong>数组下标</strong>作为<strong>对应整数的标识</strong>，即设定一个<code>bool</code>型数组<code>hashTable[100001]</code>，其中<code>hashTable[x] == true</code>表示正整数$x$在$N$个整数中出现过。这样就可以在一开始读入$N$个正整数时进行预处理。于是，对$M$个欲查询的数，就能直接通过<code>hashTable</code>数组判断出每个数是否出现过，这种做法的时间复杂度为$O(N+M)$。<strong>直接把输入的数作为数组的下标</strong>来对这个数的性质进行统计的方法<strong>非常实用，务必掌握</strong>。</p>
<p>但是这个方法有一个问题：如果<strong>输入的整数可能是$10^9$大小</strong>，甚至是<strong>字符串</strong>，就<strong>不能将其直接作为数组下标</strong>了。因此我们寻找一种做法，<strong>将元素通过一个函数转换为一个在能接受范围内的整数，使得该整数尽可能唯一地代表这个元素</strong>。这样的方法称为<strong>散列(hash)</strong>，用于转换的函数称为<strong>散列函数H</strong>，也就是说，如果元素在转换前为<code>key</code>，那么转换后就是一个整数<code>H(key)</code>。</p>
<h5 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h5><p>对<code>key</code>是<strong>整数</strong>的情况来说，常用的<strong>散列函数</strong>有：</p>
<ol>
<li><p><strong>直接定址法</strong></p>
<ul>
<li><p>恒等变换，即 <code>H(key) = key</code></p>
</li>
<li><p>线性变换，即 <code>H(key) =  a * key + b</code></p>
</li>
</ul>
</li>
<li><p><strong>除留余数法</strong></p>
<p>把<code>key</code><strong>除以一个数<code>mod</code>得到的余数</strong>作为 <code>hash</code>值 的方法，即 <code>H(key) = key % mod</code></p>
<p>通过这个散列函数，可以把很大的数转换为不超过 mod 的整数，这样就可以将它作为可用的数组下标。显然，当<code>mod</code>是一个<strong>素数</strong>时，<code>H(key)</code><strong>能尽可能覆盖<code>[0,mod]</code>范围内的每一个数</strong>。</p>
</li>
<li><p>平方取中法(<strong>很少用</strong>)</p>
<p>取<code>key</code>的<strong>平方的中间若干位</strong>作为hash值</p>
</li>
</ol>
<hr>
<h5 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h5><p>当两个不同的数<code>key1</code>和<code>key2</code>他们的hash值相同时，这样的情况称为<strong>冲突</strong>。<strong>解决冲突的常用方法：</strong></p>
<ol>
<li><p><strong>开放定址法(获取新的hash值)</strong></p>
<ul>
<li><p><strong>线性探查法 (Linear Probing)</strong></p>
<p>当表中下标为<code>H(key)</code>的位置已经被其他元素占用，则<strong>检查下一个位置<code>H(key)+1</code></strong>，以此类推。<strong>如果检查过程中超过了表长<code>m</code>，那么就回到表的首位继续循环</strong>，直到找到一个可用的位置，或是所有位置都已经被使用。</p>
<p><code>H = (H(key) + i) % m</code>；<strong>(i &#x3D; 0, 1, 2, …, m-1)</strong></p>
<p><strong>缺点</strong>：容易导致<strong>大量元素在相邻的散列地址上“聚集”(堆积)，大大降低查找效率</strong>。</p>
</li>
<li><p><strong>平方探查法 (Quadratic Probing)</strong></p>
<p>当表中下标为<code>H(key)</code>的位置已经被其他元素占用，则按如下顺序检查表中位置</p>
<p><code>H = (H(key) + i) % m</code>；i &#x3D; $0, 1^2, -1^2, 2^2, -2^2, …, k^2, -k^2;(k \leq m&#x2F;2)$</p>
<p>可<strong>避免聚集</strong>问题。</p>
<p>缺点：<strong>不能探测到散列表上所有单元</strong>(但至少能探测到一半单元)。</p>
</li>
<li><p><strong>再散列法(双散列法)</strong></p>
<p><code>H = (H1(key) + i * H2(key)) % m</code>；<strong>i 是冲突次数</strong></p>
</li>
</ul>
</li>
<li><p><strong>链地址法 (拉链法)</strong></p>
<p>不计算新的hash值，而是把 <strong>所有H(key)相同的key</strong>(称为<strong>同义词</strong>) <strong>存储在一个线性链表中</strong>，由散列地址唯一标识。</p>
</li>
</ol>
<hr>
<p>一般来说，可以使用**标准库模板库中的<code>map</code>**来直接使用hash的功能（C++11以后可以用 <code>unordered_map</code>，<strong>速度更快</strong>），因此除非必须模拟这些方法或是对算法的效率要求比较高，一般不需要自己实现上面解决冲突的方法。</p>
<hr>
<h4 id="3-2-2-字符串hash初步"><a href="#3-2-2-字符串hash初步" class="headerlink" title="3.2.2 字符串hash初步"></a>3.2.2 字符串hash初步</h4><p>如果**<code>key</code>不是整数**，应该如何设计散列函数？</p>
<blockquote>
<p>例题：</p>
<p>如何将一个二维整点$P$的坐标映射为一个整数，使得整点$P$可以由该整数唯一标识？</p>
</blockquote>
<p>假设一个整点$P$的坐标是$(x,y)$，其中$0\leq x,y\leq Range$，那么可以令<code>hash</code>函数为<code>H(P) = x * Range + y</code>，这样对数据范围内的任意两个整点$P1$与$P2$，<code>H(P1)</code>都不会等于<code>H(P2)</code>，就可以用<code>H(P)</code>来唯一地标识该整点P，<strong>接着</strong>便可以<strong>通过整数hash的方法进一步映射到较小的范围</strong>。</p>
<p>字符串hash是指<strong>将一个字符串S映射为一个整数</strong>，使得该整数可以尽可能唯一地代表字符串S。</p>
<p>为了讨论问题方便，<strong>假设字符串均由大写字母A~Z构成</strong>，不妨把 A<del>Z 视为 0</del>25。接着按照<strong>26进制转换为10进制</strong>的思路，实现将字符串映射为整数的需求(转换成的整数最大为$26^{len}-1$，len为字符串长度)。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int hashFunc(char S[], int len) &#123; &#x2F;&#x2F;将字符串S转换为整数
    int id &#x3D; 0;
    for(int i &#x3D; 0; i &lt; len; i++)
		id &#x3D; id * 26 + (S[i] - &#39;A&#39;); &#x2F;&#x2F;将26进制转换为10进制
    return id;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>为了避免转换成的整数过大，需要注意 字符串长度len 不能太长。如果字符串中<strong>还有小写字母，可以把 A<del>Z 作为 0</del>25，把 a<del>z 作为 26</del>51</strong>，这样就变成了<strong>52进制转换为10进制</strong>的问题。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int hashFunc(char S[], int len) &#123;
    int id &#x3D; 0;
    for(int i &#x3D; 0l i &lt; len; i++) &#123;
        if(isupper(S[i])) &#123;
            id &#x3D; id * 52 + (S[i] - &#39;A&#39;);
        &#125; else if(islower(S[i])) &#123;
            id &#x3D; id * 52 + (S[i] - &#39;a&#39;);
        &#125;
    &#125;
    return id;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果字符中还有数字，一般有两种处理方法：</p>
<ol>
<li><p>按照小写字母的处理方法，<strong>增大进制数至62</strong>。</p>
</li>
<li><p>如果保证在字符串的<strong>末尾是个确定的数字</strong>，就可以把前面英文字母的部分按上面的思路转换成整数，再<strong>将末尾的数字直接拼接上去</strong>。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int hashFunc(char S[], int len) &#123;
    int id &#x3D; 0;
    for(int i &#x3D; 0; i &lt; len - 1; i++)
        id &#x3D; id * 26 + (S[i] - &#39;A&#39;);
   	id &#x3D; id * 10 + (S[len - 1] - &#39;0&#39;);
    return id;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<blockquote>
<p>例题：</p>
<p>给出N个字符串(由三位大写字母组成)，再给出M个查询字符串，问每个查询字符串在N个字符串中出现的次数。</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

int hashFunc(char S[], int len) &#123; &#x2F;&#x2F;将字符串S转换为整数
    int id &#x3D; 0;
    for(int i &#x3D; 0; i &lt; len; i++)
		id &#x3D; id * 26 + (S[i] - &#39;A&#39;); &#x2F;&#x2F;将26进制转换为10进制
    return id;
&#125;

int main() &#123;
    int N, M;
    int hashTable[26 * 26 * 26] &#x3D; &#123;0&#125;;
    cin &gt;&gt; N &gt;&gt; M;
    string S[N];
    for(int i &#x3D; 0; i &lt; N; i++) &#123;
        cin &gt;&gt; S[i];
        int id &#x3D; hashFunc(S[i], 3);
        hashTable[id]++; &#x2F;&#x2F;字符串出现的次数+1
    &#125;
    string tmp;
    for(int i &#x3D; 0; i &lt; M; i++) &#123;
        cin &gt;&gt; tmp;
        int id &#x3D; hashFunc(tmp, 3);
        cout &lt;&lt; hashTable[id] &lt;&lt; endl; &#x2F;&#x2F;输出字符串出现的次数
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h4 id="3-2-3-相关习题"><a href="#3-2-3-相关习题" class="headerlink" title="3.2.3 相关习题"></a>3.2.3 相关习题</h4><table>
<thead>
<tr>
<th>题目</th>
<th>解题关键</th>
</tr>
</thead>
<tbody><tr>
<td><strong>B1005</strong> <strong>继续(3n+1)猜想</strong></td>
<td>奇数在判断过程中，可能大小会超过100</td>
</tr>
<tr>
<td><strong>B1029</strong> <strong>旧键盘</strong><br /><strong>A1084</strong> <strong>Broken Keyboard</strong></td>
<td>待优化</td>
</tr>
<tr>
<td><strong>B1033</strong> <strong>旧键盘打字</strong></td>
<td><strong>不能用<code>scanf</code>或<code>cin</code>读取字符串</strong>，应采用<code>gets(str)</code>或<code>getline(cin, str)</code>，因为题目<strong>只保证第 2 行输入的文字串非空</strong></td>
</tr>
<tr>
<td><strong>B1038</strong> <strong>统计同成绩学生</strong></td>
<td>\</td>
</tr>
<tr>
<td><strong>B1039</strong> <strong>到底买不买</strong><br /><strong>A1092</strong> <strong>To Buy or Not to Buy</strong></td>
<td>\</td>
</tr>
<tr>
<td><strong>B1042</strong> <strong>字符统计</strong></td>
<td>\</td>
</tr>
<tr>
<td><strong>B1043</strong> <strong>输出PATest</strong></td>
<td>\</td>
</tr>
<tr>
<td><strong>B1047</strong> <strong>编程团体赛</strong></td>
<td>\</td>
</tr>
<tr>
<td>A1041</td>
<td></td>
</tr>
<tr>
<td>A1050</td>
<td></td>
</tr>
<tr>
<td>A1048</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h3 id="3-3-递归"><a href="#3-3-递归" class="headerlink" title="3.3 递归"></a>3.3 递归</h3><h4 id="3-3-1-分治"><a href="#3-3-1-分治" class="headerlink" title="3.3.1 分治"></a>3.3.1 分治</h4><p><strong>分治(divide and conquer)<strong>的全称为“<strong>分而治之</strong>”。分治法</strong>将原问题划分成若干个规模较小而结构与原问题相同或类似的子问题，然后分别解决这些子问题，最后合并子问题的解，即可得到原问题的解</strong>。分治法的三个步骤：</p>
<ol>
<li>分解：将原问题分解为若干和原问题拥有相同或相似结构的子问题。</li>
<li>解决：递归求解所有子问题。如果存在子问题的规模小到可以直接解决，就直接解决它。</li>
<li>合并：将子问题的解合并为原问题的解。</li>
</ol>
<p>分治法<strong>分解出的子问题</strong>应当是<strong>相互独立、没有交叉</strong>的。如果存在两个子问题有相交部分，就不应该使用分治法解决。分治法作为一种算法思想，<strong>既可以使用递归的手段实现，也可以通过非递归的手段实现</strong>。一般来说，<strong>使用 递归 实现较为容易</strong>。</p>
<hr>
<h4 id="3-3-2-递归"><a href="#3-3-2-递归" class="headerlink" title="3.3.2 递归"></a>3.3.2 递归</h4><p>递归很适合用来<strong>实现分治思想</strong>。</p>
<p>递归的逻辑中一般有两个重要概念：</p>
<ol>
<li><strong>递归边界</strong></li>
<li><strong>递归调用</strong></li>
</ol>
<p>其中<strong>递归调用</strong>是将原问题<strong>分解为若干个子问题</strong>的手段，而<strong>递归边界</strong>则是<strong>分解的尽头</strong>。递归的代码结构中一定存在这两个该概念，<strong>它们支撑起了整个递归最关键的逻辑</strong>。</p>
<blockquote>
<p>经典例子1：使用递归求解n的阶乘</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

int F(int n) &#123;
    if(n &#x3D;&#x3D; 0) &#123;
        return 1;
    &#125; else &#123;
        return n * F(n-1);
    &#125;
&#125;

int main() &#123;
    int n;
    cin &gt;&gt; n;
    cout &lt;&lt; F(n) &lt;&lt; endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>经典例子2：求 Fibonacci 数列的第n项</p>
<p>Fibonacci 数列(即斐波那契数列) 是满足 F(0) &#x3D; 1, F(1) &#x3D; 1, F(n) &#x3D; F(n-1) + F(n-2) (n $\geq$ 2) 的数列，数列的前几项为 1, 1, 2, 3, 5, 8, 13, 21, … 。</p>
</blockquote>
<p>从定义中可以获知<strong>递归边界为 F(0) &#x3D; 1 和 F(1) &#x3D; 1</strong>，且递归调用为 F(n) &#x3D; F(n-1) + F(n-2)  (n $\geq$ 2) ，因此可以仿照求解n的阶乘的写法。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

int F(int n) &#123;
    if(n &#x3D;&#x3D; 0 || n &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F;递归边界
        return 1;
    &#125; else &#123;
        return F(n-1) + F(n-2);
    &#125;
&#125;

int main() &#123;
    int n;
    cin &gt;&gt; n;
    cout &lt;&lt; F(n) &lt;&lt; endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>最后来看<strong>全排列(Full Permutation)</strong>。全排列指<strong>n个整数能形成的 所有排列</strong>。</p>
<p>现在需要按字典序从小到大的顺序输出$1\sim n$的全排列，其中$(a_1, a_2, …, a_n)$的字典序小于$(b_1, b_2, …, b_n)$是指存在一个$i$，使得$a_1&#x3D;b_1$、$a_2 &#x3D; b_2$、…、$a_{i-1} &#x3D; b_{i-1}$、$a_i &lt; b_i$成立。</p>
<p>从递归的角度考虑，就可以分为若干个子问题：“输出以1开头的全排列”、“输出以2开头的全排列” … “输出以n开头的全排列”。<strong>不妨设定一个数组<code>P</code></strong>，用来存放当前的排列；再设定一个<strong>散列数组<code>hashTable</code></strong>，其中<code>hashTable[x]</code>，当整数<code>x</code>已经在数组<code>P</code>中时，为<code>1</code>。</p>
<p>按顺序往<code>P</code>的第1位到第n位中填入数字。<strong>不妨假设当前已经填好了<code>P[1] ~ P[index-1]</code>，正准备填<code>P[index]</code></strong>。显然需要枚举 1 ~ n，如果当前枚举的数字<code>x</code>还没有在<code>P[1] ~ P[index-1]</code>中(即<code>hashTable[x] == 0</code>)，那么就把它填入<code>P[index]</code>，同时将<code>hashTable[x]</code>置为<code>1</code>，然后去处理<code>P</code>的第<code>index + 1</code>位(<strong>即进行递归</strong>)；<strong>当递归完成时，再将<code>hashTable[x]</code>还原为<code>0</code>，以便让<code>P[index]</code>填下一个数字</strong>。</p>
<p>那么<strong>递归边界</strong>是什么呢？显然，当<code>index</code>达到<code>n + 1</code>时，说明<code>P</code>的的第<code>1 ~ n</code>位都已经填好了，此时可以把数组P输出，表示生成了一个排列，然后直接<code>return</code>即可。下面给出<code>n = 3</code>时的代码：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

void generateP(int index, int n) &#123;
    if(index &#x3D;&#x3D; n + 1) &#123; &#x2F;&#x2F;递归边界，已经处理完排列的 1~n 位
		for(int i &#x3D; 1; i &lt;&#x3D; n; i++)
            cout &lt;&lt; P[i];
        cout &lt;&lt; endl;
        return;
    &#125;
    for(int x &#x3D; 1; x &lt;&#x3D; n; x++) &#123; &#x2F;&#x2F;枚举 1~n，试图将 x 填入 P[index]
        if(hashTable[x] &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F;如果 x 不在 P[1] ~ P[index - 1] 中
            P[index] &#x3D; x; &#x2F;&#x2F;令 P 的第 index 位为 x，即把x加如当前排列
            hashTable[x] &#x3D; 1; &#x2F;&#x2F;记 x 已在 P 中
            generateP(index + 1, n); &#x2F;&#x2F;处理排列的第 index + 1 号位
            hashTable[x] &#x3D; 0; &#x2F;&#x2F;已处理完 P[index] 为 x 的子问题，还原状态
        &#125;
    &#125;
&#125;


int main() &#123;
    int n &#x3D; 3, P[11], hashTable[11] &#x3D; &#123;0&#125;;
	generateP(1); &#x2F;&#x2F;从P[1]开始填
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>最后的最后</strong>来看**$n$皇后问题**。$n$皇后问题是指在一个$n<em>n$的国际象棋棋盘上放置$n$个皇后，使得这$n$个皇后*<em>两两均不在同一行、同一列、同一条对角线上</em></em>，求合法的方案数。</p>
<p>对于这个问题，如果采用组合数的方式来枚举每一种情况(即从$n^2$个位置中选择$n$个位置)，那么需要$C_{n\times n}^n$的枚举量。但是<strong>换个思路，考虑到每行只能放置一个皇后、每列也只能放置一个皇后，如果把n列皇后所在的行号依次写出，那么就会是$1 \sim n$的一个排列</strong>。于是只需要枚举$1 \sim n$的所有排列，查看每个排列对应的放置方案是否合法，统计其中合法的方案即可。</p>
<p>于是可以<strong>在全排列的代码基础上进行求解</strong>。由于当达到递归边界时表示生成了一个排列，所以<strong>需要在起内部判断是否为合法方案</strong>，即<strong>遍历每两个皇后</strong>，判断它们<strong>是否在同一条对角线上</strong>(显然不在同一行和同一列)，若不是，则累计计数变量<code>cnt</code>即可。主要代码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int cnt &#x3D; 0;

void generateP(int index) &#123;
    if(index &#x3D;&#x3D; n + 1) &#123; &#x2F;&#x2F;递归边界，生成一个排列
        int flag &#x3D; 1; &#x2F;&#x2F;flag为true表示当前排列为一个合法方案
        for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123; &#x2F;&#x2F;遍历任意两个皇后
            for(int j &#x3D; i + 1; j &lt;&#x3D; n; j++) &#123;
                if(abs(i - j) &#x3D;&#x3D; abs(P[i] - P[j])) &#x2F;&#x2F;如果在一条对角线上
                    flag &#x3D; 0;
            &#125;
        &#125;
        if(flag) &#x2F;&#x2F;当前方案合法
            cnt++;
    	return;
    &#125;
    for(int x &#x3D; 1; x &lt;&#x3D; n; x++) &#123;
        if(hashTable[x] &#x3D;&#x3D; 0) &#123;
            P[index] &#x3D; x;
            hashTable[x] &#x3D; 1;
            generateP(index + 1);
            hashTable[x] &#x3D; 0;
        &#125;
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这种<strong>枚举所有情况，然后判断每一种情况是否合法的朴素做法</strong>称为<strong>暴力法</strong>。</p>
<p>通过思考可以发现，当已经放置了一部分皇后时，<strong>可能剩余的皇后无论怎样放置都不可能合法，就不需要继续递归，直接返回上层即可</strong>。这种做法称为<strong>回溯法</strong>。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void generateP(int index) &#123;
    if(index &#x3D;&#x3D; n + 1) &#123; &#x2F;&#x2F;递归边界，生成一个 合法方案
        cnt++;
        return;
    &#125;
    for(int x &#x3D; 1; x &lt;&#x3D; n; x++) &#123; &#x2F;&#x2F;第 x 行
        if(hashTable[x] &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F;第 x 行还没有皇后
            int flag &#x3D; 1; &#x2F;&#x2F;flag 为 1 表示当前皇后不会和之前的皇后冲突
            for(int pre &#x3D; 1; pre &lt; index; pre++) &#123; &#x2F;&#x2F;遍历之前的皇后
				if(abs(index - pre) &#x3D;&#x3D; abs(x - P[pre])) &#123;
                    flag &#x3D; 0; &#x2F;&#x2F;与之前的皇后在一条对角线冲突
                    break;
                &#125;
            &#125;
            if(flag) &#123; &#x2F;&#x2F;如果可以把皇后放在第 x 行
                P[index] &#x3D; x; &#x2F;&#x2F;令第 index 列皇后的行号为 x
                hashTable[x] &#x3D; 1; &#x2F;&#x2F;第 x 行已被占用
                generateP(index + 1); &#x2F;&#x2F;递归处理第 index + 1 行皇后
                hashTable[x] &#x3D; 0; &#x2F;&#x2F;递归完毕，还原第 x 行 为 为占用
            &#125;
        &#125;
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<hr>
<h3 id="3-4-贪心"><a href="#3-4-贪心" class="headerlink" title="3.4 贪心"></a>3.4 贪心</h3><h4 id="3-4-1-简单贪心"><a href="#3-4-1-简单贪心" class="headerlink" title="3.4.1 简单贪心"></a>3.4.1 简单贪心</h4><p>贪心法是<strong>求解一类最优化问题</strong>的方法，它总是考虑在当前状态下<strong>局部最优(或较优)<strong>的策略，来</strong>使全局的结果达到最优(或较优)</strong>。要获得<strong>最优</strong>结果，要求中间的每步策略都是最优的，因此<strong>严谨使用</strong>贪心法来求解最优化问题<strong>需要对采取的策略进行证明</strong>。证明的一般思路是使用<strong>反证法及数学归纳法</strong>，即假设策略不能导致最优解，然后通过一系列推导来得到矛盾，以此证明策略是最优的，最后用数学归纳法保证全局最优。不过对平常使用来说，也许没有时间或不太容易对想到的策略进行严谨的证明(<strong>贪心的证明往往比贪心本身更难</strong>)，因此一般来说，<strong>如果在想到某个似乎可行的策略，并且自己无法举出反例，那么就勇敢的实现它</strong>。</p>
<hr>
<h4 id="3-4-2-区间贪心"><a href="#3-4-2-区间贪心" class="headerlink" title="3.4.2 区间贪心"></a>3.4.2 区间贪心</h4><p><strong>区间不相交问题</strong>：给出$N$个开区间$(x, y)$，从中选择尽可能多的开区间，使得这些开区间两两没有交集。例如对开区间$(1, 3)$、$(2,4)$、$(3, 5)$、$(6, 7)$来说，可以选出最多三个区间$(1, 3)$、$(3, 5)$、$(6, 7)$，它们互相没有交集。</p>
<p>首先考虑最简单的情况，如果开区间$I_1$被开区间$I_2$包含(如图4-5a所示)，则选择$I_1$是最好的选择，因为这样就<strong>有更大的空间去容纳其他开区间</strong>。</p>
<p>接下来<strong>把所有开区间按左端点$x$从大到小排序</strong>，如果去掉区间包含的情况，那么一定有$y_1 &gt; y_2 &gt; … &gt; y_n$成立(如图4-5b所示)。观察发现，$I_1$右边有一段一定不会和其他区间重叠，如果把它去掉，那么$I_1$的左边剩余部分就会被$I_2$包含，由图4-5a的情况可知，应当选择$I_1$。因此对这种情况，<strong>总是先选择 左端点最大 的区间</strong>。值得注意的是，<strong>总是先选择右端点最小的区间</strong>的策略也是可行的。</p>
<img src="https://i.loli.net/2020/03/07/KlvHnuEwTJkcVsP.png" style="zoom:67%;" />

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

const int maxn &#x3D; 110;

struct Inteval &#123;
    int x, y; &#x2F;&#x2F;开区间左右端点
&#125; I[maxn];

bool cmp(Inteval a, Inteval b) &#123;
    if(a.x !&#x3D; b.x) &#123; &#x2F;&#x2F;先按左端点从大到小排序
        return a.x &gt; b.x; 
    else &#123; &#x2F;&#x2F;左端点相同的 按右端点从小到大排序
        return a.y &gt; b.y;
    &#125;
&#125;
    
int main() &#123;
    int n;
    while(cin &gt;&gt; n, n !&#x3D; 0) &#123;
        for(int i &#x3D; 0; i &lt; n; i++)
            cin &gt;&gt; I[i].x &gt;&gt; I[i].y;
    sort(I, I + n, cmp);
    int cnt &#x3D; 1, lastX &#x3D; I[0].x; &#x2F;&#x2F;记录不相交区间的个数，上一个被选中区间的左端点
    for(int i &#x3D; 1; i &lt; n; i++) &#123;
        if(I[i].y &lt;&#x3D; lastX) &#123; &#x2F;&#x2F;如果该区间右端点在 lastX 左边
            lastX &#x3D; I[i].x; &#x2F;&#x2F;以 I[i] 作为新选中的区间
            cnt++; &#x2F;&#x2F;不相交区间个数加1
        &#125;
        cout &lt;&lt; cnt &lt;&lt; endl;
    &#125;
    return 0
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>与这个问题类似的是<strong>区间选点问题：给出$N$个闭区间$[x, y]$，求最少需要确定多少个点，才能使每个闭区间中都至少存在一个点</strong>。例如对闭区间$[1,4]$、$[2, 6]$、$[5, 7]$来说，需要两个点(例如3、5)才能保证每个闭区间内都有至少一个点。</p>
<p>事实上，这个问题和区间不相交问题的策略是一致的。首先，回到图4-5a，如果闭区间$I_1$被闭区间$I_2$包含，那么在$I_1$中取点可以保证这个点一定在$I_2$内。接着<strong>把所有区间按左端点从大到小排序，去除掉区间包含的情况</strong>，就可以得到图4-5b。由于每个闭区间中都需要存在一个点，因此<strong>对左端点最大的区间$I_1$来说，取左端点就能让它尽可能多地覆盖其他区间</strong>。区间选点问题的代码只需要把区间不想交问题代码中的<code>I[i].y &lt;= lastX</code>改为<code>I[i].y &lt; lastX</code>即可。</p>
<p>总的来说，不是所有问题都适合使用贪心法，但是这并不妨碍贪心算法称为一个简洁、实用、高效的算法。</p>
<hr>
<h4 id="3-4-3-相关习题"><a href="#3-4-3-相关习题" class="headerlink" title="3.4.3 相关习题"></a>3.4.3 相关习题</h4><table>
<thead>
<tr>
<th>题目</th>
<th>解题关键</th>
</tr>
</thead>
<tbody><tr>
<td><strong>B1020</strong> <strong>月饼</strong><br /><strong>A1070</strong> <strong>Mooncake</strong></td>
<td>库存量和售价都应该定义为double类型</td>
</tr>
<tr>
<td><strong>B1023</strong> <strong>组个最小数</strong></td>
<td>\</td>
</tr>
<tr>
<td><strong>A1033</strong> <strong>To Fill or Not to Fill</strong></td>
<td><strong>能到达的距离</strong>内，<strong>由近到远遍历</strong>，有三种情况：<br /><br />1. 最近距离的加油站都到不了<br />2. 出现油价比目前低的加油站，就直接去<br />    2.1 <strong>油不够</strong>，只加能刚好到达的油量<br />    2.2 <strong>不用加油</strong><br />3. 没有更低价的加油站，就<strong>加满油(能尽量少加更贵的油)</strong>，去<strong>价格相对 最低</strong>的加油站</td>
</tr>
<tr>
<td>A1037</td>
<td></td>
</tr>
<tr>
<td>A1038</td>
<td></td>
</tr>
<tr>
<td>A1067</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h3 id="3-5-二分"><a href="#3-5-二分" class="headerlink" title="3.5 二分"></a>3.5 二分</h3><h4 id="3-5-1-二分查找"><a href="#3-5-1-二分查找" class="headerlink" title="3.5.1 二分查找"></a>3.5.1 二分查找</h4><p>二分查找的<strong>高效之处</strong>在于，<strong>每一步都可以去除当前区间中的一半元素</strong>，因此其时间复杂度是$O(\log n)$，这是十分优秀的。</p>
<p>在严格<strong>递增</strong>序列中查找给定的数$x$的做法：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

int binarySearch(int A[], int left, int right, int x) &#123;
    int mid;
    while(left &lt;&#x3D; right) &#123;
        mid &#x3D; (left + right) &#x2F; 2;
        if(A[mid] &#x3D;&#x3D; x) &#123;
            return mid;
        &#125; else if(A[mid] &gt; x) &#123;
            right &#x3D; mid - 1;
        &#125; else &#123;
            left &#x3D; mid + 1;
        &#125;
    &#125;
    return -1; &#x2F;&#x2F;查找失败
&#125;

int main() &#123;
    int A[n] &#x3D; &#123;1, 3, 4, 6, 7, 8, 10, 11, 12, 15&#125;;
    printf(&quot;%d %d\n&quot;, binarySearch(A, 0, n - 1, 6), binarySearch(A, 0, n - 1, 9));
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>需要注意的是，如果过二分<strong>上界超过<code>int</code>型数据范围的一半</strong>，当欲查询元素在序列较靠后位置时，语句<code>mid = (left + right) / 2</code>中的<code>left + right</code>就<strong>有可能超过int而导致溢出</strong>，通常<strong>使用等价语句<code>mid = left + (right - left) / 2</code>作为代替</strong>，以避免溢出。另外，二分法可以<strong>使用递归</strong>进行实现，但在程序设计时，<strong>更多采用非递归的写法</strong>。</p>
<p>接下来探讨更进一步的问题：如果递增序列$A$中的<strong>元素可能重复</strong>，那么如何对给定的欲查询元素$x$，<strong>求出序列中第一个$\geq x$的元素位置$L$以及第一个$&gt;x$的元素的位置$R$</strong>，这样元素$x$在序列中的存在区间就是$[L, R)$。</p>
<p>例如对下标从0开始、有5个元素的序列${1,3,3,3,6}$来说，如果要查询3，则应当得到$L &#x3D; 1$、$R &#x3D; 4$；如果查询 5，则应当得到$L &#x3D; R &#x3D; 4$。<strong>如果序列中没有$x$，$L$和$R$也可以理解为 假设序列中存在$x$，则$x$应当在的位置</strong>。</p>
<p>先来考虑第一个小问：求序列中的第一个$\geq x$的元素位置。</p>
<ol>
<li>若<code>A[mid] &gt;= x</code>，说明第一个$\geq x$的元素的位置一定在**<code>mid</code>处或<code>mid</code>的左侧，应往左子区间[left, mid]继续查询，即令<code>right = mid</code>**</li>
<li>若<code>A[mid] &lt; x</code>，说明第一个$\geq x$的元素的位置一定在**<code>mid</code>右侧，应往右子区间[mid+1, right]继续查询，即令<code>left = mid + 1</code>**</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int lower_bound(int A[], int left, int right, int x) &#123;
    int mid;
    while(left &lt; right) &#123;
        mid &#x3D; (left + right) &#x2F; 2;
        if(A[mid] &gt;&#x3D; x) &#123; &#x2F;&#x2F;中间值 &gt;&#x3D; x
            right &#x3D; mid;
        &#125; else &#123; &#x2F;&#x2F;中间值 &lt; x
            left &#x3D; mid + 1;
        &#125;
    &#125;
    return left; &#x2F;&#x2F;返回夹出来的位置
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述代码有两个需要注意的地方：</p>
<ol>
<li>循环条件为<code>left &lt; right</code>，而不是之前的<code>left &lt;= right</code>，这是由问题本身决定的。因为<strong>如果想要返回第一个<code>&gt;= x</code>的元素的位置，就不需要判断元素<code>x</code>本身是否存在</strong>。</li>
<li>二分的<strong>初始区间</strong>应当能<strong>覆盖到所有可能返回的结果</strong>，考虑到欲查询元素可能比序列中所有元素都大，此时应当返回n，因此<strong>二分上界是n</strong>，故二分的初始区间为<code>[left, right] = [0, n]</code>。</li>
</ol>
<p>接下来解决第二小问：求序列中第一个大于x的元素的位置。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int upper_bound(int A[], int left, itn right, int x) &#123;
    int mid;
    while(left &lt; right) &#123;
        mid &#x3D; (left + right) &#x2F; 2;
        if(A[mid] &gt; x) &#123;
            right &#x3D; mid;
        &#125; else &#123;
            left &#x3D; mid + 1；
        &#125;
    &#125;
    return left; &#x2F;&#x2F;返回夹出来的位置
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>lower_bound</code>和<code>upper_bound</code>函数都在解决这样一个问题：<strong>寻找有序序列中第一个满足某条件的元素的位置</strong>。这是一个非常重要且经典的问题，平时能碰到的大部分二分法问题都可以归结于这个问题。</p>
<hr>
<h4 id="3-5-2-二分法拓展"><a href="#3-5-2-二分法拓展" class="headerlink" title="3.5.2 二分法拓展"></a>3.5.2 二分法拓展</h4><p>首先介绍如何计算$\sqrt2$的<strong>近似值</strong>。</p>
<p>对$f(x) &#x3D; x^2$来说，在$x \in [1, 2]$范围内，$f(x)$随着$x$的增大而增大，<strong>这就给使用二分法创造了条件</strong>。</p>
<p><strong>以精确到$10^{-5}$为例</strong>，令浮点型<code>left</code>和<code>right</code>的<strong>初值分别是 1 和 2</strong>，然后根据中点<code>mid</code>处$f(x)$的值与 2 的大小来选择子区间进行逼近：</p>
<ol>
<li>若<code>f(mid) &gt; 2</code>，说明<code>mid</code> &gt; $\sqrt2$，令<code>right = mid</code></li>
<li>若<code>f(mid) &lt; 2</code>，说明<code>mid</code> &lt; $\sqrt2$，令<code>left = mid</code></li>
</ol>
<p>上面两个步骤当<code>right - left</code> &lt; $10^{-5}$时结束，显然<strong>当<code>left</code>与<code>right</code>的距离 &lt; $10^{-5}$ 时已满足精度要求</strong>，<code>mid</code>即为所求的近似值。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const double eps &#x3D; 1e-5; &#x2F;&#x2F;精度为 10^&#123;-5&#125;，科学计数法

double f(double x) &#123;
    return x * x;
&#125;

double calSqrt() &#123;
	double left &#x3D; 1, right &#x3D; 2, mid;
    while(right - left &gt; eps) &#123;
        mid &#x3D; (left + right) &#x2F; 2;
        if(f(mid) &gt; 2) &#123; &#x2F;&#x2F;即 mid &gt; sqrt(2)
            right &#x3D; mid;
        &#125; else &#123;
            left &#x3D; mid;
        &#125;
    &#125;
    return mid;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>事实上，计算$\sqrt2$的近似值的问题是这样一个问题的特例：<strong>给定一个定义在$[L, R]$上的单调函数$f(x)$，求方程<code>f(x) = 0</code>的根</strong>。</p>
<p>同样假设精度要求为<code>eps</code> &#x3D; $10^{-5}$，函数$f(x)$在$[L,R]$上递增，<strong>令<code>left</code>与<code>right</code>的初值分别为$L$、$R$</strong>。根据<strong>中点<code>mid</code>的函数值<code>f(mid)</code> 与 0 的大小关系</strong>来判断往哪个子区间继续逼近<code>f(x) = 0</code>的根：</p>
<ol>
<li>若<code>f(mid) &gt; 0</code>，说明<code>f(x) = 0</code>的根在<code>mid</code>左侧，应往左子区间继续逼近，即令<code>right = mid</code></li>
<li>若<code>f(mid) &lt; 0</code>，说明<code>f(x) = 0</code>的根在<code>mid</code>右侧，应往右子区间继续逼近，即令<code>left = mid</code></li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const double eps &#x3D; 1e-5; &#x2F;&#x2F;精度为 10^&#123;-5&#125;，科学计数法

double f(double x) &#123;
    return ...;
&#125;

double solve() &#123;
	double left &#x3D; L, right &#x3D; R, mid;
    while(right - left &gt; eps) &#123;
        mid &#x3D; (left + right) &#x2F; 2;
        if(f(mid) &gt; 0) &#123;
            right &#x3D; mid;
        &#125; else &#123;
            left &#x3D; mid;
        &#125;
    &#125;
    return mid; &#x2F;&#x2F;f(x) &#x3D; 0 的根
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<hr>
<h4 id="3-5-3-快速幂"><a href="#3-5-3-快速幂" class="headerlink" title="3.5.3 快速幂"></a>3.5.3 快速幂</h4><h4 id="3-5-4-相关习题"><a href="#3-5-4-相关习题" class="headerlink" title="3.5.4 相关习题"></a>3.5.4 相关习题</h4><table>
<thead>
<tr>
<th>题目</th>
<th>解题关键</th>
</tr>
</thead>
<tbody><tr>
<td><strong>A1010</strong> <strong>Radix</strong></td>
<td>1. <strong>基数上界为 已确认数字的十进制大小 + 1 与 下界中的较大值（确保不会出现多个解(而且基数不确定的数，只有一位数的时候才可能多个解) )</strong><br />2. 基数过大时，数值转换为十进制会发生<strong>上溢，存储结果为负数</strong></td>
</tr>
<tr>
<td>A1044</td>
<td></td>
</tr>
<tr>
<td>A1048</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h3 id="3-6-tow-pointers"><a href="#3-6-tow-pointers" class="headerlink" title="3.6 tow pointers"></a>3.6 tow pointers</h3><h4 id="3-6-1-什么是two-pointers"><a href="#3-6-1-什么是two-pointers" class="headerlink" title="3.6.1 什么是two pointers"></a>3.6.1 什么是two pointers</h4><h4 id="3-6-2-归并排序"><a href="#3-6-2-归并排序" class="headerlink" title="3.6.2 归并排序"></a>3.6.2 归并排序</h4><h4 id="3-6-3-快速排序"><a href="#3-6-3-快速排序" class="headerlink" title="3.6.3 快速排序"></a>3.6.3 快速排序</h4><h4 id="3-6-4-相关习题"><a href="#3-6-4-相关习题" class="headerlink" title="3.6.4 相关习题"></a>3.6.4 相关习题</h4><table>
<thead>
<tr>
<th>题目</th>
<th>解题关键</th>
</tr>
</thead>
<tbody><tr>
<td><strong>B1030</strong> <strong>完美数列</strong><br /><strong>A1085</strong> <strong>Perfect Sequence</strong></td>
<td>\</td>
</tr>
<tr>
<td><strong>B1035</strong> <strong>插入与归并</strong><br /><strong>A1089</strong> <strong>Insert or Merge</strong></td>
<td>1. 插入排序：<strong>未排序部分和初始序列一定相同</strong><br/> 2. 归并排序：<strong>末尾不足数量的子序列同样需要排序</strong><br/> 3. <strong>插入排序 更容易判断，将其作为判断排序类型的切入点</strong><br />4. 插入和归并排序的**实际操作由排序函数<code>sort</code>&#x2F;<code>qsort</code>**代替</td>
</tr>
<tr>
<td>A1029</td>
<td></td>
</tr>
<tr>
<td>A1048</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h3 id="3-7-其他高效技巧与算法"><a href="#3-7-其他高效技巧与算法" class="headerlink" title="3.7 其他高效技巧与算法"></a>3.7 其他高效技巧与算法</h3><h4 id="3-7-1-打表"><a href="#3-7-1-打表" class="headerlink" title="3.7.1 打表"></a>3.7.1 打表</h4><h4 id="3-7-2-活用递推"><a href="#3-7-2-活用递推" class="headerlink" title="3.7.2 活用递推"></a>3.7.2 活用递推</h4><h4 id="3-7-3-随机选择法"><a href="#3-7-3-随机选择法" class="headerlink" title="3.7.3 随机选择法"></a>3.7.3 随机选择法</h4><h4 id="3-7-4-相关习题"><a href="#3-7-4-相关习题" class="headerlink" title="3.7.4 相关习题"></a>3.7.4 相关习题</h4><table>
<thead>
<tr>
<th>题目</th>
<th>解题关键</th>
</tr>
</thead>
<tbody><tr>
<td><strong>B1040</strong> <strong>有几个PAT</strong><br /><strong>A1093</strong> <strong>Count PAT’s</strong></td>
<td>1. A前有P，后有T才能形成PAT；<br/>2. 当前A能构成的PAT数量 &#x3D; 之前P的数量 * 之后T的数量<br/>3. 突破口：<strong>先遍历一遍，获取T的数量</strong></td>
</tr>
<tr>
<td><strong>B1045</strong> <strong>快速排序</strong><br /><strong>A1101</strong> <strong>Quick Sort</strong></td>
<td>1. <strong>可能的主元：左侧的最大值比自身小；右侧的最小值比自身大</strong><br />2. <strong>输出即使没有主元，也得换行</strong></td>
</tr>
</tbody></table>
<hr>
<h2 id="4-数学问题"><a href="#4-数学问题" class="headerlink" title="4.  数学问题"></a>4.  数学问题</h2><h3 id="4-1-简单数学"><a href="#4-1-简单数学" class="headerlink" title="4.1 简单数学"></a>4.1 简单数学</h3><table>
<thead>
<tr>
<th>题目</th>
<th>解题关键</th>
</tr>
</thead>
<tbody><tr>
<td>B1003</td>
<td></td>
</tr>
<tr>
<td>B1019<br />A1069</td>
<td></td>
</tr>
<tr>
<td>B1049<br />A1104</td>
<td></td>
</tr>
<tr>
<td>A1008</td>
<td></td>
</tr>
<tr>
<td>A1049</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h3 id="4-2-最大公约数与最小公倍数"><a href="#4-2-最大公约数与最小公倍数" class="headerlink" title="4.2 最大公约数与最小公倍数"></a>4.2 最大公约数与最小公倍数</h3><table>
<thead>
<tr>
<th>题目</th>
<th>解题关键</th>
</tr>
</thead>
<tbody><tr>
<td>B1008</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h3 id="4-3-分数的四则运算"><a href="#4-3-分数的四则运算" class="headerlink" title="4.3 分数的四则运算"></a>4.3 分数的四则运算</h3><table>
<thead>
<tr>
<th>题目</th>
<th>解题关键</th>
</tr>
</thead>
<tbody><tr>
<td>B1034<br />A1088</td>
<td></td>
</tr>
<tr>
<td>A1081</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h3 id="4-4-素数"><a href="#4-4-素数" class="headerlink" title="4.4 素数"></a>4.4 素数</h3><table>
<thead>
<tr>
<th>题目</th>
<th>解题关键</th>
</tr>
</thead>
<tbody><tr>
<td>B1007</td>
<td></td>
</tr>
<tr>
<td>B1013</td>
<td></td>
</tr>
<tr>
<td>A1015</td>
<td></td>
</tr>
<tr>
<td>A1078</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h3 id="4-5-质因子分解"><a href="#4-5-质因子分解" class="headerlink" title="4.5 质因子分解"></a>4.5 质因子分解</h3><table>
<thead>
<tr>
<th>题目</th>
<th>解题关键</th>
</tr>
</thead>
<tbody><tr>
<td>A1059</td>
<td></td>
</tr>
<tr>
<td>A1096</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h3 id="4-6-大整数运算"><a href="#4-6-大整数运算" class="headerlink" title="4.6 大整数运算"></a>4.6 大整数运算</h3><table>
<thead>
<tr>
<th>题目</th>
<th>解题关键</th>
</tr>
</thead>
<tbody><tr>
<td>A1023</td>
<td></td>
</tr>
<tr>
<td>A1024</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h3 id="4-7-扩展欧几里得算法"><a href="#4-7-扩展欧几里得算法" class="headerlink" title="4.7 扩展欧几里得算法"></a>4.7 扩展欧几里得算法</h3><h3 id="4-8-组合数"><a href="#4-8-组合数" class="headerlink" title="4.8 组合数"></a>4.8 组合数</h3><hr>
<h2 id="5-C-标准模板库介绍"><a href="#5-C-标准模板库介绍" class="headerlink" title="5. C++标准模板库介绍"></a>5. C++标准模板库介绍</h2><h3 id="5-1-vector"><a href="#5-1-vector" class="headerlink" title="5.1 vector"></a>5.1 vector</h3><table>
<thead>
<tr>
<th>题目</th>
<th>解题关键</th>
</tr>
</thead>
<tbody><tr>
<td>A1039</td>
<td></td>
</tr>
<tr>
<td>A1047</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h3 id="5-2-set"><a href="#5-2-set" class="headerlink" title="5.2 set"></a>5.2 set</h3><table>
<thead>
<tr>
<th>题目</th>
<th>解题关键</th>
</tr>
</thead>
<tbody><tr>
<td>A1063</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h3 id="5-3-string"><a href="#5-3-string" class="headerlink" title="5.3 string"></a>5.3 string</h3><table>
<thead>
<tr>
<th>题目</th>
<th>解题关键</th>
</tr>
</thead>
<tbody><tr>
<td>A1060</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h3 id="5-4-map"><a href="#5-4-map" class="headerlink" title="5.4 map"></a>5.4 map</h3><table>
<thead>
<tr>
<th>题目</th>
<th>解题关键</th>
</tr>
</thead>
<tbody><tr>
<td>B1044<br />A1100</td>
<td></td>
</tr>
<tr>
<td>A1022</td>
<td></td>
</tr>
<tr>
<td>A1054</td>
<td></td>
</tr>
<tr>
<td>A1071</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h3 id="5-5-queue"><a href="#5-5-queue" class="headerlink" title="5.5 queue"></a>5.5 queue</h3><h3 id="5-6-priority-queue"><a href="#5-6-priority-queue" class="headerlink" title="5.6 priority_queue"></a>5.6 priority_queue</h3><h3 id="5-7-stack"><a href="#5-7-stack" class="headerlink" title="5.7 stack"></a>5.7 stack</h3><h3 id="5-8-pair"><a href="#5-8-pair" class="headerlink" title="5.8 pair"></a>5.8 pair</h3><h3 id="5-9-algorithm"><a href="#5-9-algorithm" class="headerlink" title="5.9 algorithm"></a>5.9 algorithm</h3><hr>
<h2 id="6-数据结构专题1"><a href="#6-数据结构专题1" class="headerlink" title="6. 数据结构专题1"></a>6. 数据结构专题1</h2><h3 id="6-1-栈的应用"><a href="#6-1-栈的应用" class="headerlink" title="6.1 栈的应用"></a>6.1 栈的应用</h3><table>
<thead>
<tr>
<th>题目</th>
<th>解题关键</th>
</tr>
</thead>
<tbody><tr>
<td><strong>A1051</strong> <strong>Pop Sequence</strong></td>
<td>1. 可能会发生<strong>堆栈溢出</strong><br />2. <strong>栈顶元素和当前需要出栈的元素相同时，出栈。该判断之前必须先判断栈是否不为空(否则会报错)</strong><br />3. 标记出栈序列中待出栈元素下标，最终<strong>标记只有超出序列下标，才可能是出栈序列</strong></td>
</tr>
</tbody></table>
<hr>
<h3 id="6-2-队列的应用"><a href="#6-2-队列的应用" class="headerlink" title="6.2 队列的应用"></a>6.2 队列的应用</h3><table>
<thead>
<tr>
<th>题目</th>
<th>解题关键</th>
</tr>
</thead>
<tbody><tr>
<td><strong>A1056</strong> <strong>Mice and Rice</strong></td>
<td>1. 输入的第二行是按老鼠的序号给出的重量。<strong>第三行给出的是老鼠的序号，而不是按序号给出的比赛序号</strong><br />2. 用<strong>队列记录老鼠的序号</strong>(而不是记录老鼠的结构体，<strong>有利于减少内存的占用</strong>)，<strong>晋级的老鼠重新入队</strong><br />3. 最后的分组中，老鼠数量可能不足(利用&lt;cmath&gt;中的<code>ceil</code>函数<strong>向上取整</strong>)</td>
</tr>
</tbody></table>
<hr>
<h3 id="6-3-链表处理"><a href="#6-3-链表处理" class="headerlink" title="6.3 链表处理"></a>6.3 链表处理</h3><table>
<thead>
<tr>
<th>题目</th>
<th>解题关键</th>
</tr>
</thead>
<tbody><tr>
<td><strong>B1025</strong> <strong>反转链表</strong><br /><strong>A1074</strong> <strong>Reversing Linked List</strong></td>
<td>1. 通过<strong>数组下标来表示地址</strong>，便于链接各个节点<br/> 2. 可能<strong>存在无效结点</strong><br/>3. <strong>只根据 链表顺序的地址 进行反转</strong>，有利于节约开销</td>
</tr>
<tr>
<td><strong>A1032</strong> <strong>Sharing</strong></td>
<td>\</td>
</tr>
<tr>
<td><strong>A1052</strong> <strong>Linked List Sorting</strong></td>
<td>存在<strong>无有效结点</strong>的情况</td>
</tr>
<tr>
<td>A1097</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h2 id="7-搜索专题"><a href="#7-搜索专题" class="headerlink" title="7. 搜索专题"></a>7. 搜索专题</h2><h3 id="7-1-深度优先搜索DFS"><a href="#7-1-深度优先搜索DFS" class="headerlink" title="7.1 深度优先搜索DFS"></a>7.1 深度优先搜索DFS</h3><table>
<thead>
<tr>
<th>题目</th>
<th>解题关键</th>
</tr>
</thead>
<tbody><tr>
<td><strong>A1103</strong> <strong>Integer Factorization</strong></td>
<td>1. 利用<code>vector</code>(<strong>可根据<code>size</code>函数确认符合要求的元素个数</strong>)，<strong>预先存储所有 ≤ N的 元素(整数的P次幂值)</strong><br />2. <strong>为了保证底数最大的序列被选中，从大到小遍历</strong><br />3. DFS函数的参数：<strong>当前</strong>元素下标，<strong>已选</strong>元素数量，<strong>已选</strong>元素之和，<strong>已选</strong>元素的底数之和<br />4. DFS函数的<strong>递归边界</strong>：已选元素数量为K且和为N<br />5. DFS函数的<strong>递归调用</strong>：<strong>选择当前元素和不选择当前元素</strong><br />6. <strong>剪枝</strong>：<strong>和超过N 或 已选元素数量超过K 或 遍历完底数序列</strong>时，不必再递归</td>
</tr>
</tbody></table>
<hr>
<h3 id="7-2-广度优先搜索BFS"><a href="#7-2-广度优先搜索BFS" class="headerlink" title="7.2 广度优先搜索BFS"></a>7.2 广度优先搜索BFS</h3><table>
<thead>
<tr>
<th>题目</th>
<th>解题关键</th>
</tr>
</thead>
<tbody><tr>
<td><strong>A1091</strong> <strong>Acute Stroke</strong></td>
<td>1. <strong>设定相对当前位置的前后左右上下6个方向的增量</strong>，便于枚举<br />2. 设置数组<code>inq</code><strong>记录当前位置是否入过队</strong><br />3. <strong>越界、当前位置为0、已入过队的位置</strong>无需再判断。<br />4. 在BFS函数中，<strong>利用队列进行BFS</strong>，使用STL的<code>queue</code>，<code>push</code>函数只将所选元素的<strong>副本入队，后续对原元素的操作不改变队列中的副本</strong>。</td>
</tr>
</tbody></table>
<hr>
<h2 id="8-数据结构专题2"><a href="#8-数据结构专题2" class="headerlink" title="8. 数据结构专题2"></a>8. 数据结构专题2</h2><h3 id="8-1-树与交叉树"><a href="#8-1-树与交叉树" class="headerlink" title="8.1 树与交叉树"></a>8.1 树与交叉树</h3><h3 id="8-2-二叉树的遍历"><a href="#8-2-二叉树的遍历" class="headerlink" title="8.2 二叉树的遍历"></a>8.2 二叉树的遍历</h3><table>
<thead>
<tr>
<th>题目</th>
<th>解题关键</th>
</tr>
</thead>
<tbody><tr>
<td><strong>A1020</strong> <strong>Tree Traversals</strong></td>
<td>\</td>
</tr>
<tr>
<td><strong>A1086</strong> <strong>Tree Traversals Again</strong></td>
<td><strong>先序</strong>序列相当于<strong>入栈</strong>次序；<strong>中序</strong>序列相当于<strong>出栈</strong>次序</td>
</tr>
<tr>
<td><strong>A1102</strong> <strong>Invert a Binary Tree</strong></td>
<td>1. 题目给的是<strong>结点编号</strong>的关系，故<strong>采用静态链表</strong>存储二叉树<br />2. 反转二叉树即<strong>每个结点的左右子树对换</strong>，选择<strong>后序</strong>遍历</td>
</tr>
</tbody></table>
<hr>
<h3 id="8-3-树的遍历"><a href="#8-3-树的遍历" class="headerlink" title="8.3 树的遍历"></a>8.3 树的遍历</h3><table>
<thead>
<tr>
<th>题目</th>
<th>解题关键</th>
</tr>
</thead>
<tbody><tr>
<td><strong>A1004</strong> <strong>Counting Leaves</strong></td>
<td>1. 利用数组<strong>存储每层的叶结点个数</strong><br />2. 根据<strong>出队结点的层数，获取最大层数</strong>，遍历输出每层叶结点个数<br /></td>
</tr>
<tr>
<td><strong>A1053</strong> <strong>Path of Equal Weight</strong></td>
<td>1. 输出的路径序列要求降序，因此<strong>在读入结点时</strong>就将孩子节点<strong>按权重降序</strong>排序，这样，之后遍历时得到的路径即为降序<br /><br />2. 利用<code>vector</code>的<code>begin</code>和<code>end</code>函数获得<code>vector</code>的<strong>首元素地址</strong>和<strong>尾后地址</strong>，用于<code>sort</code>函数排序<br />3. 利用<code>vector</code>存储路径，在<strong>递归子结点之前</strong>，用<code>push_back</code>函数<strong>将子结点加入路径</strong>，递归<strong>回溯后</strong>，用<code>pop_back</code><strong>将先前加入的子结点移出路径</strong></td>
</tr>
<tr>
<td><strong>A1079</strong> <strong>Total Sales of Supply Chain</strong></td>
<td>1. <strong>静态写法</strong>表示树，即用数组下标指代结点<br />2. 结点的结构体中设有<strong>货物量</strong>变量，用来<strong>判断是否为零售商</strong>（本题采用了BFS；也可DFS）</td>
</tr>
<tr>
<td><strong>A1090</strong> <strong>Highest Price in Supply Chain</strong></td>
<td>由于<strong>不涉及结点的数据域</strong>，可以直接<strong>用<code>vector&lt;int&gt; child[maxn]</code>存放树</strong></td>
</tr>
<tr>
<td>A1094</td>
<td></td>
</tr>
<tr>
<td>A1106</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h3 id="8-4-二叉查找树BST"><a href="#8-4-二叉查找树BST" class="headerlink" title="8.4 二叉查找树BST"></a>8.4 二叉查找树BST</h3><table>
<thead>
<tr>
<th>题目</th>
<th>解题关键</th>
</tr>
</thead>
<tbody><tr>
<td><strong>A1043</strong> <strong>Is It a Binary Search Tree</strong></td>
<td>1. <strong>静态写法</strong>(<strong>变长数组</strong>)表示二叉树<br />2. 根据BST左子树所有结点的数据域 &lt; 根结点的数据域，右子树所有结点的数据域 <strong>≥</strong> 根结点的数据域(<strong>由输入样例得出大小关系</strong>，镜像则相反)，<strong>获取左右子树的边界，判断是否符合先序序列，若符合</strong>，则按照<strong>左右根的顺序递归，将符合的根结点存入<code>vector</code>(获取后序序列)</strong><br />3. <strong>若vecotr中元素数量 &#x3D; 输入序列的元素数量(能顺利转换为BST的后序序列)，说明输入序列为先序序列</strong></td>
</tr>
<tr>
<td><strong>A1064</strong> <strong>Complete Binary Search Tree</strong></td>
<td>1. 输入的元素<strong>升序排序</strong>，即为二叉树的<strong>中序遍历序列</strong>。<br />2. <strong>静态写法</strong>(<strong>变长数组</strong>)按照<strong>层序存储</strong>完全二叉排序树<br />3. 对二叉树进行<strong>中序遍历</strong>，依次<strong>填入中序遍历序列的元素</strong>即可得到层序存储的二叉树。注意：中序遍历时，二叉树数组<strong>根结点的下标</strong>：<br />        <strong>若设为1</strong>，则左右孩子结点下标为<code>root * 2</code>和<code>root * 2 + 1</code>；<br />        <strong>若设为0</strong>，则左右孩子结点下标为<code>root * 2 + 1</code>和<code>root * 2 + 2</code><br />4. <strong>顺序输出</strong>二叉树数组元素即为<strong>层序遍历</strong>序列</td>
</tr>
<tr>
<td><strong>A1099</strong> <strong>Build A Binary Search Tree</strong></td>
<td><strong>静态写法</strong>表示树，解题方法和 A1064 基本一致</td>
</tr>
</tbody></table>
<hr>
<h3 id="8-5-平衡二叉树"><a href="#8-5-平衡二叉树" class="headerlink" title="8.5 平衡二叉树"></a>8.5 平衡二叉树</h3><table>
<thead>
<tr>
<th>题目</th>
<th>解题关键</th>
</tr>
</thead>
<tbody><tr>
<td><strong>A1066</strong> <strong>Root of AVL Tree</strong></td>
<td>即写出<strong>平衡二叉树的代码模板</strong><br />1. <strong>新建结点的初始高度为1</strong><br />2. 获取树高时，注意<strong>递归到空结点</strong>时，<strong>返回0</strong><br />3. 插入结点，递归过程中从<strong>系统栈出栈后</strong>：<br />        1) 平衡因子为2时，<strong>树型可能为LR型或LL型</strong>，LR型需要先对当前结点的<strong>左子树</strong>进行<strong>右旋</strong>；之后，LR型和LL型<strong>都需要对当前结点进行右旋</strong><br />        2) 平衡因子为-2时，<strong>树型可能为RL型或RR型</strong>，RL型需要先对当前结点的<strong>右子树</strong>进行<strong>左旋</strong>；之后，RL型和RR型<strong>都需要对当前结点进行左旋</strong><br />4. 左旋和右旋过程中要<strong>及时更新树高</strong></td>
</tr>
</tbody></table>
<hr>
<h3 id="8-6-并查集"><a href="#8-6-并查集" class="headerlink" title="8.6 并查集"></a>8.6 并查集</h3><table>
<thead>
<tr>
<th>题目</th>
<th>解题关键</th>
</tr>
</thead>
<tbody><tr>
<td><strong>A1107</strong> <strong>Social Clusters</strong></td>
<td>1. <strong>根据共同(包括潜在的→有共同爱好的人另外的爱好)爱好</strong>来确定潜在<strong>朋友的集合</strong>，利用<code>hobby[1001]</code><strong>记录 任意一个 拥有对应爱好的结点</strong>，<strong>便于合并操作</strong><br />2. 遍历各用户，<strong>根据根结点统计各集合的人数</strong><br />3. 将集合<strong>按包含人数降序</strong>排序，再<strong>遍历</strong>即可<strong>筛选统计出集合个数</strong><br />4. 路径压缩<strong>可选</strong></td>
</tr>
</tbody></table>
<hr>
<h3 id="8-7-堆"><a href="#8-7-堆" class="headerlink" title="8.7 堆"></a>8.7 堆</h3><table>
<thead>
<tr>
<th>题目</th>
<th>解题关键</th>
</tr>
</thead>
<tbody><tr>
<td><strong>A1098</strong> <strong>Insertion or Heap Sort</strong></td>
<td>1. 用于<strong>表示树的数组</strong>，注意下标<strong>从 0或1 开始，孩子结点表示的区别</strong><br />2. 插入排序：<strong>未排序部分和初始序列一定相同</strong><br/>3. 堆排序：<strong>后面的元素有序，前面无规律</strong><br/>4. <strong>插入排序 更容易判断，将其作为判断排序类型的切入点</strong><br />4. <strong>插入排序</strong>的<strong>实际操作可由排序函数<code>sort</code><strong>实现<br /><br />5. 要用堆排序得到</strong>递增序列</strong>，则需要建立<strong>大根堆</strong><br />6. 堆排序<strong>从后往前</strong>找到<strong>第一个 $&lt;$ 堆顶</strong>的元素，与堆顶元素交换，再<strong>对整个堆向下调整</strong></td>
</tr>
</tbody></table>
<hr>
<h3 id="8-8-哈夫曼树"><a href="#8-8-哈夫曼树" class="headerlink" title="8.8 哈夫曼树"></a>8.8 哈夫曼树</h3><hr>
<h2 id="9-图算法专题"><a href="#9-图算法专题" class="headerlink" title="9. 图算法专题"></a>9. 图算法专题</h2><h3 id="9-1-图的定义和相关术语"><a href="#9-1-图的定义和相关术语" class="headerlink" title="9.1 图的定义和相关术语"></a>9.1 图的定义和相关术语</h3><h3 id="9-2-图的存储"><a href="#9-2-图的存储" class="headerlink" title="9.2 图的存储"></a>9.2 图的存储</h3><h3 id="9-3-图的遍历"><a href="#9-3-图的遍历" class="headerlink" title="9.3 图的遍历"></a>9.3 图的遍历</h3><table>
<thead>
<tr>
<th>题目</th>
<th>解题关键</th>
</tr>
</thead>
<tbody><tr>
<td><strong>A1013</strong> <strong>Battle Over Cities</strong></td>
<td>1. 问题等价于求 一个无向图<strong>去掉一个结点后，连通分量的数量</strong>，这种问题一般有两种方法：<strong>图的遍历</strong>和<strong>并查集</strong><br />2. <strong><code>cin</code>会超时，需要改为<code>scanf</code></strong>，邻接矩阵和邻接表都可存储图<br />3. <strong>每次输入被占领的城市之前，要重置城市的访问状态为未访问</strong><br />4. 将<strong>失去的城市标记为已访问</strong>，即可<strong>达到失去的效果(没有公路可以到达)</strong></td>
</tr>
<tr>
<td>A1021</td>
<td></td>
</tr>
<tr>
<td><strong>A1034</strong> <strong>Head of a Gang</strong></td>
<td>1. 相同人员之间可能<strong>多次通话</strong><br />2. <code>map&lt;type1, type2&gt;</code><strong>自动按<code>type1</code>从小到大输出</strong>，使用<code>map&lt;string, int&gt;</code>建立头目姓名与成员数量的关系，便于输出结果<br />3. 图中可能<strong>有环</strong>，为了<strong>边权不被漏加</strong>，需要<strong>先累加边权再递归</strong>；同时<strong>为了防止边权被重复计算</strong>，累加后<strong>删除这条边，以免走回头路、重复计算边权</strong></td>
</tr>
<tr>
<td><strong>A1076</strong> <strong>Forwards on Weibo</strong></td>
<td>1. 转发是<strong>粉丝转发博主</strong>的信息，因此要<strong>根据用户的关注情况</strong>建立<strong>从博主到粉丝(即反向)<strong>的</strong>有向图</strong><br />2. <strong>DFS</strong>记录访问过的结点数量<strong>比较麻烦</strong>，BFS比较方便<br />3. 可能形成环 ，必须控制<strong>每个用户只能转发一次</strong>(<strong>遍历时只能访问一次</strong>)</td>
</tr>
</tbody></table>
<hr>
<h3 id="9-4-最短路径"><a href="#9-4-最短路径" class="headerlink" title="9.4 最短路径"></a>9.4 最短路径</h3><table>
<thead>
<tr>
<th>题目</th>
<th>解题关键</th>
</tr>
</thead>
<tbody><tr>
<td><strong>A1003</strong> <strong>Emergency</strong></td>
<td></td>
</tr>
<tr>
<td>A1018</td>
<td></td>
</tr>
<tr>
<td><strong>A1030</strong> <strong>Travel Plan</strong></td>
<td></td>
</tr>
<tr>
<td>A1072</td>
<td></td>
</tr>
<tr>
<td>A1087</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h3 id="9-5-最小生成树"><a href="#9-5-最小生成树" class="headerlink" title="9.5 最小生成树"></a>9.5 最小生成树</h3><h3 id="9-6-拓扑排序"><a href="#9-6-拓扑排序" class="headerlink" title="9.6 拓扑排序"></a>9.6 拓扑排序</h3><h3 id="9-7-关键路径"><a href="#9-7-关键路径" class="headerlink" title="9.7 关键路径"></a>9.7 关键路径</h3><hr>
<h2 id="10-动态规划专题"><a href="#10-动态规划专题" class="headerlink" title="10. 动态规划专题"></a>10. 动态规划专题</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hunter1023.github.io/2020/02/03/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hunter">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talk is cheap">
      <meta itemprop="description" content="Tough times never last, but tough people do.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Talk is cheap">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/03/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">黑盒测试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-03 19:22:52" itemprop="dateCreated datePublished" datetime="2020-02-03T19:22:52+08:00">2020-02-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-23 23:29:13" itemprop="dateModified" datetime="2025-01-23T23:29:13+08:00">2025-01-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>对黑盒测试来说，<strong>所有输入数据都放在一个文件里</strong>。</p>
</blockquote>
<hr>
<h2 id="单点测试"><a href="#单点测试" class="headerlink" title="单点测试"></a>单点测试</h2><p>PAT试题基本为<strong>单点测试</strong>（即<strong>一次运行一组数据，一组数据通过测试则获得这组数据的分值</strong>）。</p>
<hr>
<h2 id="多点测试"><a href="#多点测试" class="headerlink" title="多点测试"></a>多点测试</h2><p>多点测试要求程序<strong>一次运行所有数据，并要求输出结果都正确，只要存在错误，即不得分</strong>。<br><strong>大部分 在线判题系统(Online Judge)  都采用了多点测试</strong>。<br>由于要求程序能运行所有数据，因此<strong>必须保证程序能反复执行代码的核心部分</strong>，这<strong>就要用到循环</strong>。</p>
<h3 id="输入类型"><a href="#输入类型" class="headerlink" title="输入类型"></a>输入类型</h3><p>题目一般有3中输入的格式，需要采用不同输入方式。</p>
<ol>
<li><strong><code>while··· EOF</code>型</strong></li>
</ol>
<p>题目<strong>没有给定输入的结束条件</strong>，则<strong>默认读取到文件末尾</strong>。</p>
<blockquote>
<p>EOF（End Of File)</p>
<p>可以通过<code>printf(&quot;%d&quot;, EOF);</code>读取EOF的数值，一般的设备上值是-1。<br>EOF操作：</p>
<ul>
<li>windows：<code>Ctrl + Z</code></li>
<li>unix：<code>Ctrl + D</code></li>
</ul>
</blockquote>
<p><code>scanf</code> 若成功读入一个值，返回1；若成功读入2个值，返回2；若<strong>读入失败，返回 -1</strong>，C&#x2F;C++中，<code>EOF</code>即为 -1。</p>
<p>正常情况下，控制台中的输入不会失败，只有读取文件时<strong>到达文件末尾，导致无法读取时，才会产生读入失败</strong>。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;读取数字、字符、字符串
while (scanf(&quot;%d&quot;, &amp;n) !&#x3D; EOF) &#123;
    ···
&#125;

&#x2F;&#x2F;读取字符串
while (gets(str) !&#x3D; NULL) &#123;
    ···
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<ol start="2">
<li><strong><code>while··· break</code>型</strong></li>
</ol>
<p>题目要求，<strong>当输入的数据满足某个条件时，停止输入</strong>。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">while (scanf(&quot;%d%d&quot;, &amp;a, &amp;b) !&#x3D; EOF) &#123;
    if (a &#x3D;&#x3D; 0 &amp;&amp; b &#x3D;&#x3D; 0) &#123;
        break;
    &#125;
    printf(&quot;%d\n&quot;, a + b);
&#125;

&#x2F;&#x2F;更简洁的写法
while (scanf(&quot;%d%d&quot;, &amp;a, &amp;b), a || b) &#123;&#x2F;&#x2F; scanf()恒不为0
    printf(&quot;%d\n&quot;, a + b);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<ol start="3">
<li><strong><code>while (T--)</code>型</strong></li>
</ol>
<p>题目给出测试数据的组数，然后才给出相应数量数组的输入数据。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int T;
scanf(&quot;%d&quot;, &amp;T);
while (T--) &#123;
    ···
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><ol>
<li><p>正常输出</p>
</li>
<li><p>每组数据输出之后，额外加一个空行</p>
</li>
<li><p><strong>两组输出数据之间有一个空行，最后一组数据后面没有空行</strong></p>
<p>一般在第三种输入类型<code>while (T--)</code>情况下出现，只需通过判断T是否为0选择是否输出额外的换行。</p>
</li>
</ol>
<hr>
<h3 id="重置变量"><a href="#重置变量" class="headerlink" title="重置变量"></a>重置变量</h3><p>在多点测试中，<strong>每一次循环都要重置变量和数组</strong>，否则在下一组数据来临时，变量和数组不是初始状态，将出错。<strong>重置数组一般使用<code>memset</code>函数或<code>fill</code>函数</strong>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hunter1023.github.io/2020/02/01/C_C++%E8%A7%A3%E9%A2%98%E5%B9%B2%E8%B4%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hunter">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talk is cheap">
      <meta itemprop="description" content="Tough times never last, but tough people do.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Talk is cheap">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/01/C_C++%E8%A7%A3%E9%A2%98%E5%B9%B2%E8%B4%A7/" class="post-title-link" itemprop="url">C/C++解题干货</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-01 23:24:32" itemprop="dateCreated datePublished" datetime="2020-02-01T23:24:32+08:00">2020-02-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-23 23:29:13" itemprop="dateModified" datetime="2025-01-23T23:29:13+08:00">2025-01-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="数据类型选择"><a href="#数据类型选择" class="headerlink" title="数据类型选择"></a>数据类型选择</h2><ol>
<li><p><strong>整型int</strong>取值范围：$-2^{31} \sim +(2^{31}-1)$，题目要求<strong>绝对值在$10^9$以内 或 32位整数</strong>，则<strong>用int型表示</strong></p>
</li>
<li><p><strong>长整型long long</strong>取值范围：$-2^{63} \sim +(2^{63}-1)$，题目要求<strong>绝对值在$10^{18}$以内 或 64位整数</strong>，则<strong>用long long型表示</strong></p>
<p>注：如果 long long 型赋 $&gt; 2^{31}-1$的初值，需要在初值后加上LL，否则编译错误。如<code>long long num = 123456789012345LL;</code></p>
</li>
<li><p>浮点型数据<strong>一律用double存储</strong>，而不用float(精度低，6~7位)</p>
</li>
<li><p>字符常量使用**ASCII码(范围0~127)**统一编码。</p>
<ul>
<li>0~9 的ASCII码值：48~57</li>
<li>A<del>Z 的ASCII码值：65</del>90</li>
<li>a<del>z 的ASCII码值：97</del>122 (<strong>比大写字母的ASCII码值大32</strong>)</li>
</ul>
</li>
<li><p>强制类型转换</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstdio&gt;

int main() &#123;
    double r &#x3D; 12.56;
    int a &#x3D; 3, b &#x3D; 5;
    printf(&quot;%d\n&quot;, (int)r); &#x2F;&#x2F;输出12
    printf(&quot;%.1f&quot;, (double)a &#x2F; (double)b);&#x2F;&#x2F;输出0.6
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<hr>
<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><table>
<thead>
<tr>
<th>C语言</th>
<th>C++</th>
<th>比较</th>
</tr>
</thead>
<tbody><tr>
<td>#include &lt;cstdio&gt;<br /><strong>scanf函数<br />printf函数</strong></td>
<td>#include &lt;iostream&gt; <br />using std::cin;<br />using std::cout;<br />cin<br />cout</td>
<td>cin 和 cout <strong>无需指定输入输出格式</strong>，<br />但<strong>消耗的时间</strong>比 scanf 和 printf <strong>多得多</strong>。<br />故<strong>推荐使用C语言的 scanf 和 printf</strong>，<br />只有在十分必要的时候使用 cin 和 cout</td>
</tr>
</tbody></table>
<h3 id="输入和输出格式"><a href="#输入和输出格式" class="headerlink" title="输入和输出格式"></a>输入和输出格式</h3><table>
<thead>
<tr>
<th>类型</th>
<th>输入</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>long long</td>
<td><code>scanf(&quot;%lld&quot;, &amp;n);</code></td>
<td><code>printf(&quot;%lld&quot;, n);</code></td>
</tr>
<tr>
<td>double</td>
<td><code>scanf(&quot;%lf&quot;, &amp;db);</code></td>
<td><code>printf(&quot;%f&quot;, db);</code></td>
</tr>
<tr>
<td>字符串</td>
<td><code>scanf(&quot;%s&quot;, str);</code><br />(<strong>无需 取地址符&amp;</strong>)<br /></td>
<td><code>printf(&quot;%s&quot;, str);</code></td>
</tr>
<tr>
<td>char</td>
<td><code>c1 = getchar();</code><br /><strong>能读入换行符<code>\n</code></strong></td>
<td><code>putchar(c1);</code></td>
</tr>
</tbody></table>
<h3 id="实用的输出格式"><a href="#实用的输出格式" class="headerlink" title="实用的输出格式"></a>实用的输出格式</h3><ol>
<li><p><code>%md</code></p>
<p>使不足m位的int型变量以m位进行<strong>右对齐</strong>输出，高位<strong>用空格补齐</strong>；若变量本身超过m位，则保持原样。</p>
</li>
<li><p><code>%0md</code></p>
<p>使不足m位的int型变量以m位进行<strong>右对齐</strong>输出，高位<strong>用0补齐</strong>；若变量本身超过m位，则保持原样。</p>
</li>
<li><p><code>%.mf</code></p>
<p>让浮点数保留m位小数(<strong>四舍六入五成双</strong>)输出。如果要<strong>四舍五入</strong>，需要用到<strong>round函数</strong>。</p>
<blockquote>
<p>四舍六入五成双：</p>
<ul>
<li>5后有数时：舍5入1</li>
<li>5后无数时：<ul>
<li>5前为奇数，舍5入1</li>
<li>5前为偶数，舍5不进（0是偶数）</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ol>
<hr>
<h2 id="C-标准库头文件"><a href="#C-标准库头文件" class="headerlink" title="C++标准库头文件"></a>C++标准库头文件</h2><table>
<thead>
<tr>
<th>C++标准库</th>
<th>包含内容</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;iostream&gt;</td>
<td>C++标准输入和输出函数 的函数原型</td>
</tr>
<tr>
<td>&lt;cstdio&gt;</td>
<td>C风格标准输入和输出函数 的函数原型</td>
</tr>
<tr>
<td>&lt;iomanip&gt;</td>
<td><strong>格式化数据流</strong>的流操纵符 的函数原型</td>
</tr>
<tr>
<td>&lt;cmath&gt;</td>
<td><strong>数学库</strong>函数 的函数原型</td>
</tr>
<tr>
<td>&lt;ctime&gt;</td>
<td>处理时间和日期的函数 的函数原型</td>
</tr>
<tr>
<td>&lt;cstdlib&gt;</td>
<td><strong>数与文本的转换、内存分配、随机数</strong>及其他各种<strong>工具函数</strong> 的函数原型</td>
</tr>
<tr>
<td>&lt;random&gt;</td>
<td>产生<strong>非确定性的随机数</strong> 的功能库</td>
</tr>
<tr>
<td>&lt;cctype&gt;</td>
<td><strong>测试 字符</strong>特定属性(如是否为数字、标点符号等)函数 的函数原型<br /><strong>转换 大小写字母</strong>的函数 的函数原型</td>
</tr>
<tr>
<td>&lt;iterator&gt;</td>
<td><strong>访问 C++标准库容器中数据</strong> 的类</td>
</tr>
<tr>
<td>&lt;algorithm&gt;</td>
<td><strong>操作 C++标准库容器中数据</strong> 的函数</td>
</tr>
<tr>
<td>&lt;string&gt;</td>
<td>C++标准库的 <code>string</code>类 的定义</td>
</tr>
<tr>
<td>&lt;cstring&gt;</td>
<td>C风格<strong>字符串处理</strong>函数 的函数原型</td>
</tr>
</tbody></table>
<hr>
<h3 id=""><a href="#" class="headerlink" title="&lt;cmath&gt;"></a>&lt;cmath&gt;</h3><ol>
<li><p><strong><code>double fabs(double x)</code></strong></p>
<p><strong>浮点型取绝对值</strong></p>
</li>
<li><p><strong><code>double floor(double x)</code>和<code>ceil(double x)</code></strong></p>
<p><strong>向下取整</strong>和<strong>向上取整</strong></p>
</li>
<li><p><strong><code>double round(double x)</code></strong><br><strong>针对小数点后一位四舍五入</strong></p>
<p>另，<strong>不使用函数进行四舍五入的方法</strong>：</p>
<p><code>num = num + 0.5</code> </p>
</li>
<li><p><strong><code>double pow(double r, double p)</code></strong></p>
<p>求 r 的 p次方</p>
<p><strong>$10^n$还有另外的表示方法，如</strong></p>
<ul>
<li>$10^3$ 可写成 <code>1e3</code></li>
<li>$2\times10^6$可写成<code>2e6</code></li>
<li>$3\times10^{-6}$可写成<code>3e-6</code></li>
</ul>
</li>
<li><p><strong><code>double sqrt(double x)</code></strong></p>
<p>求 x 的算术平方根</p>
</li>
<li><p><strong><code>double log(double x)</code><strong>和</strong><code>double log10(double x)</code></strong></p>
<p>求 x <strong>以 $e$ 为底</strong>的对数 和 <strong>以10为底</strong>的对数</p>
<p>针对<strong>任意底数求对数的函数</strong>，必须用<strong>换底公式</strong>，即$\log_ab &#x3D; \ln b&#x2F;\ln a$</p>
</li>
<li><p><strong><code>double exp(double x)</code></strong></p>
<p>指数函数$e^x$</p>
</li>
<li><p>三角函数</p>
<p><strong>x为弧度</strong></p>
<ul>
<li><code>sin(double x)</code></li>
<li><code>cos(double x)</code></li>
<li><code>tan(double x)</code></li>
</ul>
</li>
</ol>
<hr>
<h3 id="-1"><a href="#-1" class="headerlink" title="&lt;ctime&gt;"></a>&lt;ctime&gt;</h3><ol>
<li><p><code>time_t time(time_t *seconds)</code></p>
<p>返回<strong>自 格林尼治标准时间的1970年1月1日0时 起 到现在</strong>的<strong>秒数</strong>。如果<code>seconds</code>不为空，<strong>返回值也存储在<code>seconds</code>中</strong>。</p>
</li>
</ol>
<hr>
<h3 id="-2"><a href="#-2" class="headerlink" title="&lt;cstdlib&gt;"></a>&lt;cstdlib&gt;</h3><ol>
<li><p><code>int rand()</code></p>
<p><code>rand</code>函数生成 [0, RAND_MAX] 之间的一个<strong>整数</strong></p>
<p>直接由<code>rand</code>函数生成的数的范围<strong>常常不能满足具体需要</strong>，可以通过<strong>比例缩放(scaling)<strong>方法得到所需的随机数。例如</strong>模拟投掷六面骰子，结果可以用<code>rand() % 6 + 1</code>表示</strong>。其中数字6称为<strong>比例缩放因子</strong>。</p>
</li>
<li><p><code>void srand(unsigned int seed)</code></p>
<p><code>rand</code>函数<strong>实际上生成的是 伪随机数</strong>。程序每次执行时产生的序列都是重复的，将其调整为每次执行时都产生不同的随机数序列的过程称为<strong>随机化</strong>，可以<strong>通过<code>srand</code>函数实现</strong>。<code>srand</code>函数接收一个<code>unsigned int</code>值，<strong>为</strong> <code>rand</code>函数使用的<strong>随机数发生器 “播种”</strong>，从而产生不同的随机数序列。为了<strong>在随机化时不用每次都输入“种子”</strong>，可以使用如下语句：</p>
<p><code>srand(static_cast&lt;unsigned int&gt;(time(NULL) ) );</code></p>
</li>
</ol>
<hr>
<h3 id="-3"><a href="#-3" class="headerlink" title="&lt;cctype&gt;"></a>&lt;cctype&gt;</h3><ol>
<li><p><code>int isalnum(int c)</code></p>
<p>字符是否为<strong>数字或字母</strong></p>
</li>
<li><p><code>int isalpha(int c)</code></p>
<p>字符是否是<strong>字母</strong></p>
</li>
<li><p><code>int isdigit(int c)</code></p>
<p>字符是否是十进制<strong>数字</strong></p>
</li>
<li><p><code>int islower(int c)</code></p>
<p>是否是<strong>小写字母</strong></p>
</li>
<li><p><code>int isupper(int c)</code></p>
<p>是否是<strong>大写字母</strong></p>
</li>
<li><p><code>int tolower(int c)</code></p>
<p>把大写字母 <strong>转换为 小写字母</strong></p>
<p><strong>不会改变非字母字符的值</strong></p>
</li>
<li><p><code>int toupper(int c)</code></p>
<p>把小写字母 <strong>转换为 大写字母</strong></p>
<p><strong>不会改变非字母字符的值</strong></p>
</li>
</ol>
<hr>
<h3 id="-4"><a href="#-4" class="headerlink" title="&lt;algorithm&gt;"></a>&lt;algorithm&gt;</h3><ol>
<li><p><code>max(x, y)</code>和<code>min(x, y)</code></p>
</li>
<li><p><code>abs(x)</code>：<code>x</code>必须是<strong>整数</strong>，因此更推荐使用<code>&lt;cmath&gt;</code>下的<code>fabs(x)</code></p>
</li>
<li><p><code>swap(x, y)</code></p>
</li>
<li><p><code>reverse(it1, it2)</code></p>
<p><strong>可以将 数组指针在[it1, it2)之间的元素 或 容器的迭代器在[it1, it2)之间的元素 进行反转</strong>。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a[10] &#x3D; &#123;10, 11, 12, 13, 14, 15&#125;;
reverse(a, a + 4); &#x2F;&#x2F;将 a[0] ~ a[3]反转
for(int i &#x3D; 0; i &lt; 6; i++)
    cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;
&#x2F;&#x2F;输出结果：13 12 11 10 14 15

string str &#x3D; &quot;abcdefghi&quot;;
reverse(str.begin() + 2, str.begin() + 6); &#x2F;&#x2F;对str[2] ~ str[5]反转
for(int i &#x3D; 0; i &lt; str.size(); i++) &#123;
    cout &lt;&lt; str[i];
&#125;
&#x2F;&#x2F;输出结果：abfedcghi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>next_permutation</code>函数</p>
<p>给出一个序列在<strong>全排列中的下一个序列</strong>。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a[10] &#x3D; &#123;1, 2, 3&#125;;
do&#123;
    cout &lt;&lt; a[0] &lt;&lt; a[1] &lt;&lt; a[2] &lt;&lt; endl;
&#125; while(next_permutation(a, a + 3)); &#x2F;&#x2F;a[0]~a[2]之间的序列求解下一个序列<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>fill</code>函数</p>
<p>对数组或容器中某一段区间元素<strong>赋相同的值</strong>。和<code>&lt;cstring&gt;</code>的<code>memset</code>不同(基本只用于赋<strong>0或-1</strong>)，可以赋<strong>数组类型对应范围中的任意值</strong>。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a[5] &#x3D; &#123;1, 2, 3, 4, 5&#125;
fill(a, a + 5, 233); &#x2F;&#x2F;a[0] ~ a[4] 均赋值为 233
for(int i &#x3D; 0; i &lt; 5; i++)
    cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;
&#x2F;&#x2F;输出结果：233 233 233 233 233<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>


</li>
<li><p><code>sort</code>函数</p>
<p>C语言的<code>qsort</code>函数的使用需要运用指针，且写法上没有C++的<code>sort</code>函数简洁。<code>sort</code>函数<strong>根据具体情形使用不同的排序方法</strong>，效率较高，在实现中<strong>规避了经典快速排序中可能出现的会导致实际复杂度退化到$O(n^2)$的极端情况</strong>。</p>
<p>因此<strong>更推荐使用C++的<code>sort</code>函数</strong>进行代码编写。</p>
<p><code>sort(首元素地址, 尾元素地址的下一个地址, 比较函数cmp(非必填))</code></p>
<p>如果<strong>不写比较函数cmp</strong>，则<strong>默认升序</strong>排序。如果想要<strong>降序</strong>排序，需要编写比较函数cmp：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool cmp(int a, int b) &#123; &#x2F;&#x2F;返回值为true时，a被排在b之前
    return a &gt; b; &#x2F;&#x2F;降序
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>在STL标准容器中，<strong>只有<code>vector</code>、<code>string</code>、<code>deque</code>可以使用<code>sort</code>，因为像<code>set</code>、<code>map</code>这种容器是用红黑树实现的，元素本身有序，故不允许使用<code>sort</code>排序</strong>。</p>
</li>
<li><p><code>lower_bound</code>和<code>upper_bound</code></p>
<p><code>lower_bound(first, last, val)</code>用来寻找在数组或容器中的[first, last)范围内<strong>第一个值$\geq$<code>val</code>的元素的位置</strong>。</p>
<p><code>upper_bound(first, last, val)</code>用来寻找在数组或容器中的[first, last)范围内<strong>第一个值&gt;<code>val</code>的元素的位置</strong>。</p>
<p><strong>如果是数组，则返回该位置的指针；如果是容器，则返回该位置的迭代器。如果没有找到相应元素，则返回可以插入该元素的位置的指针或迭代器</strong>。</p>
</li>
<li><p><code>max_element</code>和<code>min_element</code></p>
<p><code>max_element(first, last)</code>用来寻找在数组或容器中的[first, last)范围内<strong>最大元素的位置</strong>。</p>
<p><code>min_element(first, last, val)</code>用来寻找在数组或容器中的[first, last)范围内<strong>最小元素的位置</strong>。</p>
<p><strong>如果是数组，则返回该位置的指针；如果是容器，则返回该位置的迭代器</strong>。</p>
</li>
</ol>
<hr>
<h3 id="常用容器"><a href="#常用容器" class="headerlink" title="常用容器"></a>常用容器</h3><h4 id="-5"><a href="#-5" class="headerlink" title="&lt;vector&gt;"></a>&lt;vector&gt;</h4><p><strong>向量</strong>(“<strong>变长数组</strong>”的叫法更容易理解)，<strong>长度可以根据需要进行变化，比较节省空间</strong>。试题中，有时会碰到<strong>只用普通数组会超内存的情况，使用<code>vector</code>会让问题的解决便捷许多</strong>；另外，<code>vector</code>还可以用来<strong>以邻接表的方式存储图</strong>。</p>
<ol>
<li><p><code>vector</code>的定义</p>
<p><code>vector&lt;typename&gt; name</code></p>
<p>如果<code>typename</code>也是一个STL(Standard Template Library)容器，<strong>在C++11之前，定义的时候，在符号<code>&gt;&gt;</code>之间要加上空格</strong>。如：<code>vector&lt;vector&lt;int&gt; &gt; name;</code>，可以理解为<strong>两个维都可变长的二维数组</strong>。</p>
<p>而vector数组的定义，如：<code>vector&lt;typename&gt; Arrayname[arraySize];</code>，<strong>一维长度已固定，注意两者的区别</strong>。</p>
</li>
<li><p><code>vector</code>常用函数</p>
<ol>
<li><p><code>push_back(typename x)</code>：在 vector <strong>末尾添加</strong>一个元素 x</p>
</li>
<li><p><code>pop_back()</code>：<strong>删除</strong> vector 的<strong>末尾元素</strong></p>
</li>
<li><p><code>begin()</code>：取 vector 的<strong>首元素地址</strong></p>
</li>
<li><p><code>end()</code>：取 vector 的 <strong>尾后(尾元素地址的下一个)地址</strong>（美国人思维比较习惯<strong>左闭右开</strong>）</p>
</li>
<li><p><code>size()</code>：获取 vector 中的<strong>元素个数</strong></p>
</li>
<li><p><code>clear()</code>：<strong>清空</strong> vector 中所有元素</p>
</li>
<li><p><code>insert(vector&lt;typename&gt;::iterator it, typename x)</code>：向vector的 <strong>任意迭代器 it 处</strong> 插入一个元素 x</p>
<p>如<code>vi.insert(vi.begin() + 2, -1); //将 -1 插入vi[2]</code></p>
</li>
<li><p><code>erase()</code></p>
<ul>
<li>删除迭代器为 it 处的元素：<code>erase(it);</code></li>
<li>删除 [firstIt, lastIt) 内所有元素：<code>erase(firstIt, lastIt);</code></li>
</ul>
</li>
</ol>
</li>
<li><p><code>vector</code>容器内元素的访问</p>
<ol>
<li><p>通过<strong>下标</strong>访问</p>
</li>
<li><p>通过<strong>迭代器iterator</strong>访问</p>
<p><code>vector&lt;typename&gt;::iterator it;</code>，这样就得到了迭代器<code>it</code>，可以通过**<code>*it</code>来访问<code>vector</code>里的元素**。</p>
<p>例如：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

int main() &#123;
	vector&lt;int&gt; vi;
    for(int i &#x3D; 1; i &lt;&#x3D; 5; i++)
        vi.push_back(i); &#x2F;&#x2F;在 vi 的 末尾 添加元素 i
    vector&lt;int&gt;::iterator it &#x3D; vi.begin(); &#x2F;&#x2F;vi.begin() 为取 vi 的首元素地址
    for(int i &#x3D; 0; i &lt; 5; i++)
        cout &lt;&lt; *(it + i);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看出<code>vi[i]</code>和<code>vi.begin() + i</code><strong>等价</strong>。在常用的STL容器中，<strong>只有<code>vector</code>和<code>string</code>中，才允许使用<code>vi.begin() + 1</code>这种 迭代器加上整数 的写法</strong>。</p>
<p>迭代器还实现了自增和自减的操作，于是还有一种遍历<code>vector</code>中元素的写法：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;vector 的迭代器不支持 it &lt; vi.end() 写法
for(vector&lt;int&gt;::iterator it &#x3D; vi.begin(); it !&#x3D; vi.end(); it++)
    cout &lt;&lt; *it;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ol>
</li>
</ol>
<hr>
<h4 id="-6"><a href="#-6" class="headerlink" title="&lt;set&gt;"></a>&lt;set&gt;</h4><p><strong>集合</strong>，是一个<strong>内部自动递增排序 且 不含重复元素</strong>的容器。试题中，可能出现需要<strong>去掉重复元素</strong>的情况，而且<strong>有可能因为这些元素 比较大 或者 类型不是<code>int</code>型 而不能直接开散列表</strong>，这种情况下就可以用<code>set</code>来保留元素本身而不考虑个数。虽然上述情况<strong>也可以通过再开一个数组进行下标和元素对应来解决</strong>，但<code>set</code>提供了<strong>更为直观</strong>的接口，并且可以实现<strong>自动排序</strong>，可以在做某些题时<strong>减少思维量</strong>。</p>
<ol>
<li><p><code>set</code>的定义</p>
<p><code>set&lt;typename&gt; name;</code></p>
<p>和<code>vector</code>相同，如果<code>typename</code>也是一个STL容器，<strong>在C++11之前，定义的时候，在符号<code>&gt;&gt;</code>之间要加上空格</strong>。如：<code>set&lt;vector&lt;int&gt; &gt; name;</code>，可以理解为<strong>两个维都可变长的二维数组</strong>。</p>
</li>
<li><p><code>set</code>常用函数</p>
<ol>
<li><p><code>begin()</code>：取 set 的<strong>首元素地址</strong></p>
</li>
<li><p><code>end()</code>：取 set 的 <strong>尾后(尾元素地址的下一个)地址</strong>（美国人思维比较习惯<strong>左闭右开</strong>）</p>
</li>
<li><p><code>size()</code>：获取 set 中的<strong>元素个数</strong></p>
</li>
<li><p><code>clear()</code>：<strong>清空</strong> set 中所有元素</p>
</li>
<li><p><code>insert(typename x)</code>：将 x 插入 set 容器中，并自动递增排序和去重，时间复杂度为$O(logN)$</p>
</li>
<li><p><code>find(typename value)</code>：返回 set 中<strong>对应值为 value 的迭代器</strong></p>
<p>如：<code>set&lt;int&gt;::iterator it = st.find(2);</code> &#x2F;&#x2F;在 set 中查找2，返回其迭代器</p>
</li>
<li><p><code>erase()</code></p>
<ul>
<li><p>删除单个元素</p>
<ul>
<li><p>删除迭代器为 it 处的元素：<code>erase(it);</code></p>
<p>可以结合<code>find</code>函数使用，如：<code>st.erase(st.find(100))</code></p>
</li>
<li><p>删除值为 value 的元素：<code>erase(value);</code></p>
</li>
</ul>
</li>
<li><p>删除 [firstIt, lastIt) 内所有元素：<code>erase(firstIt, lastIt)</code></p>
</li>
</ul>
</li>
</ol>
</li>
<li><p><code>set</code>容器内元素的访问</p>
<p><code>set</code><strong>只能通过 迭代器iterator 访问</strong>，因为<strong>只有<code>vector</code>和<code>string</code>中，才允许使用<code>vi.begin() + 1</code>这种 迭代器加上整数 的写法</strong>，因此只能按如下方式枚举：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;set&gt;
using namespace std;

int main() &#123;
	set&lt;int&gt; st;
	st.insert(3);
    st.insert(5);
    st.insert(2);
    st.insert(3);
    &#x2F;&#x2F;set 的迭代器不支持 it &lt; vi.end() 写法
	for(set&lt;int&gt;::iterator it &#x3D; st.begin(); it !&#x3D; st.end(); it++)
		cout &lt;&lt; *it;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出为：<code>2 3 5</code>，可以发现，<code>set</code>内的元素自动<strong>递增</strong>排序，且自动去除了重复元素。</p>
</li>
<li><p>延伸</p>
<p><code>set</code>中元素是唯一的，如果<strong>处理元素不唯一的情况，需要使用<code>multiset</code></strong>。C++11 标准中还增加了<code>unordered_set</code>，<strong>以散列代替<code>set</code>内部的红黑树(一种自平衡二叉查找树)实现</strong>，使其可以用来<strong>去重但不排序</strong>的需求，速度比set快得多。</p>
</li>
</ol>
<hr>
<h4 id="-7"><a href="#-7" class="headerlink" title="&lt;string&gt;"></a>&lt;string&gt;</h4><ol>
<li><p><code>string</code>中内容的访问</p>
<ol>
<li><p>通过下标访问</p>
<p>一般来说，<strong>可以直接像字符数组那样去 访问</strong><code>string</code>，如果要读入和输出<strong>整个字符串</strong>，则<strong>只能用<code>cin</code>和<code>cout</code></strong>。那么有办法用<code>printf</code>输出<code>string</code>吗？</p>
<p>用<code>string</code>的函数<code>c_str()</code>可以将<code>string</code>类型<strong>转换为字符数组</strong>进行输出。示例：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string str &#x3D; &quot;abcd&quot;;
printf(&quot;%s\n&quot;, str.c_str());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>通过迭代器访问</p>
<p>有些函数比如<code>insert()</code>与<code>erase()</code>要求以迭代器为参数进行访问。由于<code>string</code>不像其他STL容器那样需要参数，因此可以直接如下定义：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string::iterator it;
for(it &#x3D; str.begin(); it !&#x3D; str.end(); i++)
    cout &lt;&lt; *it;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong><code>string</code>和<code>vector</code>一样，允许使用<code>vi.begin() + 1</code>这种 迭代器加上整数 的写法</strong></p>
</li>
</ol>
</li>
<li><p><code>string</code>常用函数</p>
<ol>
<li><p><code>operator+=</code></p>
<p><code>string</code>的加法，可以将两个<code>string</code><strong>直接拼接</strong>。</p>
</li>
<li><p><code>compare operator</code></p>
<p>两个<code>string</code>类型可以<strong>直接使用 比较符 比较大小</strong>，比较规则是<strong>按字典序</strong>。</p>
</li>
<li><p><code>begin()</code>：取 string 的<strong>首元素地址</strong></p>
</li>
<li><p><code>end()</code>：取 string 的 <strong>尾后(尾元素地址的下一个)地址</strong>（美国人思维比较习惯<strong>左闭右开</strong>）</p>
</li>
<li><p><code>size()/length()</code>：返回 string 的长度</p>
</li>
<li><p><code>clear()</code>：清空 string 中的数据</p>
</li>
<li><p><code>insert</code></p>
<ul>
<li><p>在 pos 位置插入字符串：<code>insert(int pos, string str)</code>，<strong>原来位置的字符串顺延</strong>。</p>
</li>
<li><p>在 迭代器it 位置插入字符串：</p>
<p><code>insert(it, firstIt, lastIt)</code>，<code>firstIt</code>和<code>lastIt</code>为<strong>待插字符串的首尾迭代器</strong>，用来表示串 [firstIt, lastIt) 将被插在 it 位置上</p>
</li>
</ul>
</li>
<li><p><code>string::npos</code>：是一个<strong>常数</strong>，本身值为**-1**，但由于是<code>unsigned_int</code>类型，因此实际上<strong>可以认为是最大值</strong>。用于作为<code>find</code>函数失配时的返回值。</p>
</li>
<li><p><code>find()</code></p>
<ul>
<li><code>str.find(string str1)</code>：当 str1 是子串时，返回在 str 中<strong>第一次出现的位置</strong>；如果不是字串，则返回<code>string::npos</code></li>
<li><code>str.find(string str1, int pos)</code>：从 pos 位置开始匹配 str1</li>
</ul>
</li>
<li><p><code>erase()</code></p>
<ul>
<li>删除单个元素：<code>erase(it)</code>，目标字符<strong>之后的字符字串 前移</strong>。</li>
<li>删除一个区间内的所有元素，目标区间<strong>之后的字符字串 前移</strong>。<ul>
<li><code>erase(firstIt, lastIt)</code>，删除 [firstIt, lastIt) 间的所有字符</li>
<li><code>erase(int pos, int length)</code>，pos 是删除的起始位置</li>
</ul>
</li>
</ul>
</li>
<li><p><code>substr(int pos, int length)</code>：<strong>返回</strong>从 pos 位置开始，长度为 length 的<strong>字串</strong>。</p>
</li>
<li><p><code>replace()</code></p>
<ul>
<li><code>str.replace(int pos, int lenth, str1)</code>：把 str 从 pos 位置开始，长度为 length 的字串替换为 str1，<strong>替换位置之后的字符串不变</strong>。</li>
<li><code>str.replace(it1, it2, str1)</code>：把 str 的迭代器 [it1, it2) 范围的字串替换为 str1，<strong>替换位置之后的字符串不变</strong>。</li>
</ul>
</li>
</ol>
</li>
</ol>
<hr>
<h4 id="-8"><a href="#-8" class="headerlink" title="&lt;map&gt;"></a>&lt;map&gt;</h4><p><strong>映射</strong>，<code>map</code><strong>可以将 任何基本类型(包括STL容器) 映射到 任何基本类型(包括STL容器)</strong>。</p>
<p>来看一个情况：判定给的一些数字在某个文件中是否出现过。如果数字很大，那么就不便建立散列的数组。这时，<strong>可以通过<code>map</code>，将这些数字当成字符串，建立<code>string</code>至<code>int</code>的映射</strong>。</p>
<ol>
<li><p><code>map</code>的定义</p>
<p><code>map&lt;typename1, typename2&gt; mp;</code>：<code>&lt; &gt;</code>内第一个是 键(key) 的类型，第二个是 值(value) 的类型。<strong>map 会以 键 从小到大的顺序自动排序(因为 map 内部是使用红黑树实现的，set也是如此)</strong>。<strong>map 的一个键只能对应一个值</strong>。如果是 int 型映射到 int 型，就相当于普通的 int 型数组。</p>
<p>如果是<strong>字符串到整型的映射，必须使用 string 而不能使用 char数组</strong>：<code>map&lt;string, int&gt; mp;</code>，因为<strong>数组不能作为键值</strong>。</p>
</li>
<li><p><code>map</code>常用函数</p>
<ol>
<li><p><code>begin()</code>：取 map 的<strong>首元素地址</strong></p>
</li>
<li><p><code>end()</code>：取 map 的 <strong>尾后(尾元素地址的下一个)地址</strong>（美国人思维比较习惯<strong>左闭右开</strong>）</p>
</li>
<li><p><code>find(key)</code>：返回 键key的对应映射值 的迭代器</p>
<p><code>map&lt;char int&gt;::iterator it = mp.find(&#39;b&#39;);</code></p>
</li>
<li><p><code>erase()</code></p>
<ul>
<li>删除单个元素：<ul>
<li><code>erase(it)</code>：it 为待删除映射的迭代器</li>
<li><code>erase(key)</code>：key 为待删除映射的键</li>
</ul>
</li>
<li>删除一个区间内的所有映射：<code>erase(firstIt, lastIt)</code></li>
</ul>
</li>
<li><p><code>size()</code>：获取映射的对数</p>
</li>
<li><p><code>clear()</code>：清空 map 中的所有映射</p>
</li>
</ol>
</li>
<li><p><code>map</code>容器内元素的访问</p>
<ol>
<li><p>通过下标访问</p>
<p>例如定义为<code>map&lt;char, int&gt; mp</code>的map来说，可以直接使用<code>mp[&#39;c&#39;]</code>的方式来访问对应的整数。</p>
</li>
<li><p>通过迭代器访问</p>
<p><code>map&lt;typename1, typename2&gt;::iterator it;</code>，因为 map 的每一对映射都有两个 typename，这决定了必须<strong>能通过一个 it 来同时访问键和值</strong>。事实上，<code>map</code>可以使用<code>it-&gt;first</code>来访问键，<code>it-&gt;second</code>来访问值。</p>
</li>
</ol>
</li>
<li><p>延伸</p>
<p>map 的 键和值是唯一的(一对一)，而<strong>如果需要一个键对应多个值(一对多)，就只能用<code>multimap</code></strong>。C++11 标准中还增加了<code>unordered_map</code>，以散列代替 map 内部的红黑树实现，使其可以只处理映射而不按key值排序，速度比 map 快得多。</p>
</li>
</ol>
<hr>
<h4 id="-9"><a href="#-9" class="headerlink" title="&lt;queue&gt;"></a>&lt;queue&gt;</h4><p>队列，先进先出。</p>
<ol>
<li><p><code>queue</code>的定义</p>
<p><code>queue&lt;typename&gt; name;</code></p>
</li>
<li><p><code>queue</code>常用函数</p>
<ol>
<li><code>push(x)</code>：将 x 进<strong>行入 队尾</strong></li>
<li><code>front()</code>、<code>back()</code>：分别获得队首和队尾元素</li>
<li><code>pop()</code>：令<strong>队首</strong>元素<strong>出队</strong></li>
<li><code>empty()</code>：<strong>检测 queue 是否为空</strong></li>
<li><code>size()</code>：返回队列内元素个数</li>
</ol>
</li>
<li><p><code>queue</code>容器内元素的访问</p>
<p>由于队列是一种先进先出的限制性数据结构，因此<strong>只能通过<code>front()</code>来访问队首元素，<code>back()</code>访问队尾元素</strong>。</p>
</li>
<li><p><code>queue</code>的常见用途</p>
<p>当需要实现**广度优先搜索(BFS)**时，可以不用手动实现一个队列，以提高程序的准确性。需要注意的时是，<strong>使用<code>front()</code>和<code>pop()</code>函数之前，必须用<code>empty()</code>判断队列是否为空</strong>，否则可能因为队空而出现错误。</p>
<p>延伸：STL的容器中还有两种跟队列有关：</p>
<ul>
<li><p><strong>双端队列<code>deque</code></strong>：<strong>首尾皆可插入和删除</strong>的队列。</p>
</li>
<li><p><strong>优先队列<code>priority_queue</code></strong>：使用<strong>堆</strong>实现的<strong>默认当前队列 最大元素置于队首</strong>的容器。</p>
</li>
</ul>
</li>
</ol>
<h5 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a><code>priority_queue</code></h5><ol>
<li><p><code>priority_queue</code>的定义</p>
<p><code>priority_queue&lt;typename&gt; name;</code></p>
</li>
<li><p><code>priority_queue</code>常用函数</p>
<ol>
<li><code>push(x)</code>：将 x入队，时间复杂度为O(<strong>logN</strong>)</li>
<li><code>top()</code>：获得队首(即堆顶)元素</li>
<li><code>pop()</code>：令队首元素(即堆顶)元素出队，时间复杂度为O(<strong>logN</strong>)</li>
<li><code>empty()</code>：检测优先队列是否为空</li>
<li><code>size()</code>：返回优先队列内元素个数</li>
</ol>
</li>
<li><p><code>priority_queue</code>容器内元素的访问</p>
<p><strong>只能通过<code>top()</code>函数访问队首元素(优先级最高的元素)</strong>。</p>
</li>
<li><p><code>priority_queue</code>内<strong>元素优先级的设置</strong></p>
<ol>
<li><p>基本数据类型的优先级设置</p>
<p>下列两种优先队列的定义是等价的(以<code>int</code>型为例)</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">priority_queue&lt;int&gt; q;
priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; q;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li><code>vector&lt;int&gt;</code>：用来<strong>承载底层数据结构—堆</strong>的容器</li>
<li><code>less&lt;int&gt;</code>：表示<strong>数字大的优先级越大</strong>(<strong>默认优先级</strong>)；<code>greater&lt;int&gt;</code>即为<strong>数字小的优先级越大</strong>。</li>
</ul>
<p>因此，如果想让最小的元素放在队首，需要如下定义：</p>
<p><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;</code></p>
</li>
<li><p>结构体的优先级设置</p>
<p>比如定义水果的结构体：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct fruit &#123;
	string name;
    int price;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>现在希望<strong>按水果价格高的为优先级高</strong>，就需要<strong>重载小于号<code>&lt;</code></strong>：</p>
<ul>
<li><p>方式一：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct fruit &#123;
    string name;
    int price;
    friend bool operator &lt; (fruit f1, fruit f2) &#123;
        return f1.price &lt; f2.price; &#x2F;&#x2F;水果价格高的为优先级高
        &#x2F;&#x2F; return f1.price &gt; f2.price; &#x2F;&#x2F;水果价格低的为优先级高
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>其中，<code>friend</code>为<strong>友元</strong>。<code>bool operator &lt; (fruit f1, fruit f2)</code><strong>对<code>&lt;</code>进行了重载</strong>。此时就可以直接定义<code>fruit</code>类型的优先队列，其内部就是以<strong>水果价格高的为优先级高</strong>：<code>priority_queue&lt;fruit&gt; q;</code></p>
</li>
<li><p>方式二：<strong>将重载的函数写在结构体外</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct cmp &#123;
    bool operator () (fruit f1, fruit f2) &#123;
        return f1.price &gt; f2.price;
    &#125;
&#125;

priority_queue&lt;fruit, vector&lt;fruit&gt;, cmp&gt; q;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<p>即便是<strong>基本数据类型或者其他STL容器(如 set)</strong>，<strong>也可以通过同样的方式来定义优先级</strong>。如果结构体内的数据较为庞大，<strong>建议使用引用来提高效率</strong>：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">friend bool operate &lt; (const fruit &amp;f1, const fruit &amp;f2) &#123;
    reutrn f1.price &gt; f2.price;
&#125;
&#x2F;&#x2F;或如下
bool operator () (const fruit &amp;f1, const fruit &amp;f2) &#123;
    return f1.price &gt; f2.price;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
</li>
<li><p><code>priority_queue</code>的常见用途</p>
<p>可以解决一些<strong>贪心问题</strong>，也可以<strong>对 Dijkstra 算法进行优化</strong>(因为优先队列的本质是堆)。需要注意的时是，<strong>使用<code>top()</code>函数之前，必须用<code>empty()</code>判断队列是否为空</strong>，否则可能因为队空而出现错误。</p>
</li>
</ol>
<hr>
<h4 id="-10"><a href="#-10" class="headerlink" title="&lt;stack&gt;"></a>&lt;stack&gt;</h4><p>栈</p>
<ol>
<li><p><code>stack</code>的定义</p>
<p><code>stack&lt;typename&gt; name;</code></p>
</li>
<li><p><code>stack</code>常用函数</p>
<ol>
<li><code>push(x)</code>：将 x 压入栈</li>
<li><code>top()</code>：获得栈顶元素</li>
<li><code>pop()</code>：弹出栈顶元素</li>
<li><code>empty()</code>：检测 stack 是否为空</li>
<li><code>size()</code>：返回 stack 内元素的个数</li>
</ol>
</li>
<li><p><code>stack</code>容器内元素的访问</p>
<p><strong>只能通过<code>top()</code>函数访问栈顶元素</strong>。</p>
</li>
<li><p><code>stack</code>的常见用途</p>
<p>stack 用来<strong>模拟实现一些 递归</strong>，防止程序<strong>对栈内存的限制</strong>而导致程序运行出错。对有些题目来说，<strong>如果用普通的函数进行递归，一旦递归层数过深，则会导致程序运行崩溃。如果用栈来模拟递归算法的实现，则可以避免这一方面的问题</strong>。</p>
</li>
</ol>
<hr>
<h4 id="-11"><a href="#-11" class="headerlink" title="&lt;utility&gt;"></a>&lt;utility&gt;</h4><h5 id="pair"><a href="#pair" class="headerlink" title="pair"></a><code>pair</code></h5><p>当想要<strong>将两个元素绑在一起作为一个合成元素</strong>，又<strong>不想因此定义结构体</strong>时，使用<code>pair</code>可以很方便地作为一个替代品，即 pair 可以<strong>看作 内部有两个元素 的结构体</strong>。</p>
<ol>
<li><p><code>pair</code>的定义</p>
<p>注意：因为 映射map 的内部实现中涉及 pair，因此<strong>添加 map头文件 时会自动添加 utility头文件</strong>，因此，<strong>记不住 utility头文件，则可以用 map头文件 来代替</strong>。</p>
<p>pair 有两个参数：<code>pair&lt;typeName1, typeName2&gt; name;</code></p>
<ul>
<li><p>如果想<strong>在定义 pair 时进行初始化</strong>，只需要跟上一个小括号，填写两个初始化元素即可：</p>
<p><code>pair &lt;string, int&gt; p(&quot;haha&quot;, 5);</code></p>
</li>
<li><p>如果想<strong>临时构建一个 pair</strong>：</p>
<ul>
<li><code>pair&lt;string, int&gt;(&quot;haha&quot;, 5)</code></li>
<li>使用自带的<code>make_pair</code>函数：<code>make_pair(&quot;haha&quot;, 5)</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>pair</code>中元素的访问</p>
<p>pair 中<strong>只有两个元素，分别是<code>first</code>和<code>second</code></strong>，只需要<strong>按 正常结构体的方式 访问</strong>即可。</p>
</li>
<li><p><code>pair</code>常用函数</p>
<p><strong>比较操作数</strong>：</p>
<p>两个 pair 类型数据可以<strong>直接使用比较符比较大小</strong>，比较规则是<strong>先以<code>first</code>的大小作为标准，<code>first</code>相等时去比较<code>second</code>的大小</strong>。</p>
</li>
<li><p><code>pair</code>的常见用途</p>
<ul>
<li><p>代替二元结构体及其构造函数，节省编码时间</p>
</li>
<li><p>作为<code>map</code>的<strong>键值对</strong>来进行插入：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">map&lt;string, int&gt; mp;
mp.insert(make_pair(&quot;heihei&quot;, 5));
mp.insert(pair&lt;string, int&gt;(&quot;haha&quot;, 10));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ol>
<hr>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol>
<li><p><strong>一维数组初始化</strong></p>
<p><strong>如果数组没有初始化，数组中每个元素为随机数</strong>。一维数组的初始化，<strong>未被赋初始值</strong>的元素将<strong>默认初始化为0</strong>，因此，如果想要给整个数组初始化为0，只需第一个元素初始化为0即可。<code>int a[10] = &#123;0&#125;;</code>(<strong>不适用C语言</strong>)</p>
</li>
<li><p><strong>二维数组初始化</strong></p>
<p>二维数组初始化需要<strong>按第一维的顺序</strong>，依次<strong>用大括号</strong>给出<strong>第二维初始化</strong>的情况，<strong>未被赋初始值</strong>的元素将<strong>默认初始化为0</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a[4][2] &#x3D; &#123;&#123;3&#125;, &#123;&#125;, &#123;8, 4&#125;&#125;; &#x2F;&#x2F;第二行使用大括号跳过
&#x2F;**
数组初始化为：
3 0
0 0
8 4
0 0
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>如果数组大小较大(大概$10^6$级别)，需要定义在主函数外(即全局变量)</strong></p>
<p>否则程序会异常退出（局部变量来自系统栈，允许申请空间较小；全局变量来自静态存储区，允许申请的空间较大）</p>
</li>
<li><p><strong>对数组中每一个元素赋相同的值</strong></p>
<p><strong>需要<code>#include &lt;cstring&gt;</code></strong></p>
<p><code>void* memset(数组名, 值, sizeof(数组名));</code></p>
<p>memset <strong>按字节赋值</strong>，即对每个字节赋同样的值，<strong>组成int型的4个字节就会被赋成相同的值</strong>。故建议<strong>只用于赋 0或 -1</strong>(0的二进制补码为全0，-1的二进制补码为全1)，不易出错。</p>
<p><strong>如果要对数组赋其他数字(如 1)，则使用 fill函数（执行速度比 memset 慢）</strong>。</p>
</li>
</ol>
<hr>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3><ul>
<li><p>输入</p>
<ul>
<li><pre><code class="language-c++">#include &lt;cstdio&gt;
<pre class="line-numbers language-none"><code class="language-none">
  - &#96;scanf(&quot;%s&quot;, str);&#96; 识别**空格或换行**作为输入结束，且**空格或回车符会留在缓冲区**

  - &#96;char c &#x3D; getchar();&#96; 能够读入**空格和换行符**

  - &#96;gets(char* str);&#96; 识别**换行**作为输入结束，且**回车符会被舍弃，不在缓冲区**

    因此，**scanf一个输入后，如果要使用gets，需要先用 getchar 接收scanf后的空格或换行符**。
  
    另外，**PAT使用C++提交时**，使用&#96;gets()&#96;函数会出现**编译错误**，建议使用C++函数。
  
- &#96;&#96;&#96;c++
  #include &lt;iostream&gt;
  using std::cin;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

- `cin &gt;&gt;`

- `cin.getline(数组名称, 数组大小)`

  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char str[100];
&#x2F;*
指定最多读入 9 个字符，超出即报错
（实际数组最多能存放99个字符，空字符\0 占用一个字符位）
*&#x2F;
cin.getline(str, 10);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
</ul>
</li>
<li><p>输出</p>
<ul>
<li><pre><code class="language-c++">#include &lt;cstdio&gt;
<pre class="line-numbers language-none"><code class="language-none">
  - &#96;printf(str);&#96; 
  - &#96;putchar(char c);&#96;
  - &#96;puts(char* str);&#96; 输出数组内容后，**紧跟一个换行**

- &#96;&#96;&#96;c++
  #include &lt;iostream&gt;
  using std::cout;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

- `cout &lt;&lt;`
</code></pre>
</li>
</ul>
</li>
<li><p>字符数组的存放方式</p>
<p>字符数组的<strong>末尾都有一个 空字符<code>\0</code>(即NULL)，表示存放的字符串的结尾</strong>。空字符<code>\0</code> 在<strong>gets</strong>和<strong>scanf</strong>输入字符串时，会<strong>自动添加在输入的字符串后面</strong>，并<strong>占用一个字符位</strong>。<strong>puts</strong>和<strong>printf</strong>就是<strong>通过识别<code>\0</code>作为字符串的结尾进行输出</strong>。</p>
<ul>
<li>空字符<code>\0</code><strong>占用一个字符位</strong>，因此<strong>字符数组的长度一定要比实际存储字符串的长度 至少多1</strong>。</li>
<li>如果<strong>使用<code>getchar()</code>输入字符串</strong>，一定要在<strong>每个字符串后加入<code>\0</code>，否则printf和puts输出字符串会因无法识别字符串末尾而输出一大堆乱码</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="C-的标准库类-string"><a href="#C-的标准库类-string" class="headerlink" title="C++ 的标准库类 string"></a>C++ 的标准库类 string</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;string&gt;
using std::string;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>若引用了<code>&lt;iostream&gt;</code>头文件，创建string对象时，无须引用<code>&lt;string&gt;</code>，因为<code>&lt;iostream&gt;</code>有对<code>std::string</code>的间接引用。但时要对string对象运用相关的函数操作，仍须引用<code>&lt;string&gt;</code>。</p>
<ul>
<li><p>输入一整行</p>
<p><code>getline(cin, str)</code></p>
</li>
<li><p>比较字符串大小</p>
<ul>
<li><p><code>str1.compare(str2)</code></p>
<p><strong>按字典顺序(顺序越靠后，越大)</strong>，返回两个字符串大小的比较</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="-12"><a href="#-12" class="headerlink" title="&lt;cstring&gt;"></a>&lt;cstring&gt;</h3><ol>
<li><p><code>strlen(str)</code></p>
<p>得到字符数组中<strong>第一个<code>\0</code>前 的字符个数</strong></p>
</li>
<li><p><code>strcmp(str1, str2)</code></p>
<p><strong>按字典顺序(顺序越靠后，越大)</strong>，返回两个字符串大小的比较结果：</p>
<ul>
<li><code>str1 &lt; str2</code>，返回一个<strong>负整数</strong>(不同编译器处理不同，<strong>不一定是 -1</strong>)</li>
<li><code>str1 == str2</code>，返回一个0</li>
<li><code>str1 &gt; str2</code>，返回一个<strong>正整数</strong>(不同编译器处理不同，<strong>不一定是 +1</strong>)</li>
</ul>
</li>
<li><p><code>strcpy(str1, str2)</code></p>
<p>把 str2 复制给 str1，<strong>包括结束符<code>\0</code></strong></p>
</li>
<li><p><code>strcat(str1, str2)</code></p>
<p>把 str2 <strong>拼接</strong>到 str1 后面</p>
</li>
</ol>
<hr>
<h3 id="字符串与数字的相互转换"><a href="#字符串与数字的相互转换" class="headerlink" title="字符串与数字的相互转换"></a>字符串与数字的相互转换</h3><h4 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h4><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstdlib&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>字符串 <strong>转为 数字</strong></p>
<ul>
<li><code>atoi(str)</code>：将字符串转为 int型</li>
<li><code>atol(str)</code>：将字符串转为 long long型</li>
<li><code>atof(str)</code>：将字符串转为 double型</li>
</ul>
<hr>
<h5 id="方法二：-sscanf-与-sprintf"><a href="#方法二：-sscanf-与-sprintf" class="headerlink" title="方法二： sscanf 与 sprintf"></a>方法二： sscanf 与 sprintf</h5><p>如果想从屏幕输入 int型变量n 并将 n 输出到屏幕：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">scanf(&quot;%d&quot;, &amp;n);
printf(&quot;%d&quot;, n);
&#x2F;&#x2F;其实可以表示成如下
scanf(screen, &quot;%d&quot;, &amp;n);
printf(screen, &quot;%d&quot;, n);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>sscanf</code>与<code>sprintf</code>的格式如出一辙，只是把screen换成了字符数组</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">sscanf(str, &quot;%d&quot;, &amp;n); &#x2F;&#x2F;将字符数组str中的内容以&quot;%d&quot;格式写到n中
sprintf(str, &quot;%d&quot;, n); &#x2F;&#x2F;把n以&quot;%d&quot;的格式写到str数组中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>例：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstdio&gt;

int main() &#123;
    int n;
    double db;
    char str[100] &#x3D; &quot;2048:3.14,hello&quot;, str2[100];
    &#x2F;*
    从字符串读取格式化输入
    使得 n &#x3D; 2048, db &#x3D; 3.14, str2 &#x3D; hello
    *&#x2F;
    sscanf(str, &quot;%d:%lf,%s&quot;, &amp;n, &amp;db, str2);
    n &#x3D; 12;
    db &#x3D; 3.1415;
    str2[100] &#x3D; &quot;good&quot;;
    &#x2F;*
    发送格式化输出到字符串
    使得 str &#x3D; &quot;12:3.14,good&quot;
    *&#x2F;
    sprintf(str, &quot;%d:%.2f,%s&quot;, n, db, str2);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h4 id="C-："><a href="#C-：" class="headerlink" title="C++："></a>C++：</h4><p>数字 <strong>转为 字符串</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;string&gt;
using namespace std;

string str &#x3D; to_string(num);
len &#x3D; str.length();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h2 id="数组作为函数参数"><a href="#数组作为函数参数" class="headerlink" title="数组作为函数参数"></a>数组作为函数参数</h2><ul>
<li>参数中数组的<strong>第一维不需要填写长度</strong>(如果是二维数组，<strong>第二维需要填写长度</strong>)</li>
<li><strong>在函数中对数组元素的修改 等同于 对原数组元素的修改</strong>(与普通局部变量不同)</li>
</ul>
<p>例：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstdio&gt;

void change(int a[], int b[][5]) &#123;&#x2F;&#x2F;参数数组 第一维不需要填写长度，第二维需要填写长度
    a[0] &#x3D; 1;
    a[1] &#x3D; 3;
    a[2] &#x3D; 5;
    b[0][0] &#x3D; 1;
&#125;

int main() &#123;
    int a[3] &#x3D; &#123;0&#125;; &#x2F;&#x2F;不适用C语言
    int b[5][5] &#x3D; &#123;0&#125;; &#x2F;&#x2F;不适用C语言
    change(a, b);
    for (int i &#x3D; 0; i &lt; 3; i++) &#123;
        printf(&quot;%d\n&quot;, a[i]);
    &#125;
    &#x2F;*
    输出结果为：
    1
    3
    5
    *&#x2F;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>数组不允许作为返回类型出现，<strong>想要返回数组，只能通过参数返回</strong></li>
</ul>
<hr>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ul>
<li><p>C语言习惯于把<code>*</code>放在变量名之前：<code>int *p;</code>(声明多个指针时，<strong>易统一</strong>)</p>
</li>
<li><p>C++习惯把<code>*</code>放在数据类型之后：<code>int* p;</code></p>
</li>
<li><p><strong>地址赋给<code>p</code>而不是<code>*p</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a;
int* p;
p &#x3D; &a; &#x2F;&#x2F;等价于 int* p &#x3D; &a;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>指针的加减法</p>
<ul>
<li>两个指针相减，得到两个地址的距离</li>
<li><code>p + 1</code>指 p所指的int型变量 的<strong>下一个int型变量地址</strong></li>
<li>指针<strong>支持自增和自减操作</strong></li>
</ul>
</li>
</ul>
<hr>
<h3 id="指针变量作为函数参数"><a href="#指针变量作为函数参数" class="headerlink" title="指针变量作为函数参数"></a>指针变量作为函数参数</h3><p>例子：<strong>交换两个数</strong></p>
<p><strong>只有在获取地址的情况下对元素进行操作，才能真正修改变量</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstdio&gt;

void swap(int* a, int* b) &#123;
    int tmp &#x3D; *a;
    *a &#x3D; *b;
    *b &#x3D; tmp;
&#125;

int main() &#123;
    int a &#x3D; 1, b &#x3D; 2;
    int *p1 &#x3D; &amp;a, *p2 &#x3D; &b;
    swap(p1, p2);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>错误写法：</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void swap1(int* a, int* b) &#123;
    int* tmp;
    *tmp &#x3D; *a;
    *a &#x3D; *b;
    *b &#x3D; *tmp;   
&#125;
&#x2F;*
tmp未初始化，存放的地址很大概率指向系统工作区间，不能修改，故后续报错
初始化tmp即可
*&#x2F;
void swap2(int* a, int* b) &#123;
    int x;
    int* tmp &#x3D; &x;
    *a &#x3D; *b;
    *b &#x3D; *tmp;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h4 id="引用的含义"><a href="#引用的含义" class="headerlink" title="引用的含义"></a>引用的含义</h4><p>引用是C++的语法，在编程时极为实用。如果要<strong>修改传入函数的参数，且不使用指针</strong>，可以通过<strong>C++的引用</strong>。引用<strong>不产生副本</strong>，只是<strong>给原变量起个别名</strong>。</p>
<p>引用的方法：在函数的<strong>参数变量名前加个<code>&amp;</code>即可</strong>。要将**引用<code>&amp;</code><strong>与</strong>取地址运算符<code>&amp;</code>**区分开来，<strong>引用并不是取地址的意思</strong>。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstdio&gt;

void change(int &amp;x) &#123;
    x &#x3D; 1;
&#125;

int main() &#123;
    int x &#x3D; 10;
    change(x);
    printf(&quot;%d\n&quot;, x); &#x2F;&#x2F;输出1
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="指针的引用"><a href="#指针的引用" class="headerlink" title="指针的引用"></a>指针的引用</h4><p>例子：<strong>交换两个数</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;错误写法
void swap(int* a, int* b) &#123;
    int* tmp &#x3D; a;
    a &#x3D; b; &#x2F;&#x2F;交换的地址 是 值传递，不会修改原指针的地址
    b &#x3D; tmp;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>通过引用实现交换</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstdio&gt;

void  swap(int* &amp;a, int* &amp;b) &#123; &#x2F;&#x2F;通过引用实现交换
    int* tmp &#x3D; a;
    a &#x3D; b;
    b &#x3D; tmp;
&#125;

int main() &#123;
    int a &#x3D; 1, b &#x3D; 2;
    int *p1 &#x3D; &amp;a, *p2 &#x3D; &b;
    swap(p1, p2); &#x2F;&#x2F;不能写成 swap(&amp;a, &amp;b);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>引用是产生<strong>变量的别名，常量不可使用引用</strong>。故上述</p>
<blockquote>
<p><code>swap(p1, p2); //不能写成 swap(&amp;a, &amp;b);</code></p>
</blockquote>
<hr>
<h2 id="结构体（struct）的使用"><a href="#结构体（struct）的使用" class="headerlink" title="结构体（struct）的使用"></a>结构体（struct）的使用</h2><h3 id="访问结构体内的元素"><a href="#访问结构体内的元素" class="headerlink" title="访问结构体内的元素"></a>访问结构体内的元素</h3><p>假设<code>p</code>是一个指向结构的指针，可以用**<code>p-&gt;结构成员</code>的形式（等价于<code>(*p).结构成员</code>）**，引用相应的结构成员。</p>
<hr>
<h2 id="申请动态内存空间"><a href="#申请动态内存空间" class="headerlink" title="申请动态内存空间"></a>申请动态内存空间</h2><p>如需要定义链表的结点时。</p>
<p>C语言有<code>malloc</code>和<code>free</code>函数用于内存的申请和释放，C++有<code>new</code>和<code>delete</code>运算符用于内存的申请和释放。<strong>推荐使用C++进行内存的申请和释放(用法更简洁)</strong>。</p>
<ul>
<li><p>申请内存空间 — <code>new</code>运算符：</p>
<p>使用<strong>new + 类型名</strong>即可分配一块该类型的内存空间，<strong>返回申请的同变量类型的指针</strong>：<code>typename* p = new typename;</code></p>
<p>示例：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int* p &#x3D; new int;
node* p &#x3D; new node;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>通常情况下，内存空间的申请不会失败。失败一般发生在使用<code>new</code><strong>申请了较大的动态数组</strong>，如：<code>int* p = new int[1000000];</code>。<strong>申请失败会发生异常</strong>。</p>
</li>
<li><p>释放内存 — <code>delete</code>运算符：</p>
<p>以<strong>需要释放的内存空间的指针变量</strong>为参数：<code>delete(p);</code>，执行之后，<strong>指针变量<code>p</code>没有消失，只是指向了空地址<code>NULL</code></strong>。</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hunter1023.github.io/2020/02/01/C%E8%AF%AD%E8%A8%80%E5%92%8CC++%E7%9A%84%E6%AF%94%E8%BE%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hunter">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talk is cheap">
      <meta itemprop="description" content="Tough times never last, but tough people do.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Talk is cheap">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/01/C%E8%AF%AD%E8%A8%80%E5%92%8CC++%E7%9A%84%E6%AF%94%E8%BE%83/" class="post-title-link" itemprop="url">C语言和C++的比较</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-01 13:36:33" itemprop="dateCreated datePublished" datetime="2020-02-01T13:36:33+08:00">2020-02-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-23 23:29:13" itemprop="dateModified" datetime="2025-01-23T23:29:13+08:00">2025-01-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><table>
<thead>
<tr>
<th>C语言</th>
<th>C++</th>
<th>比较</th>
</tr>
</thead>
<tbody><tr>
<td><strong>scanf函数<br />printf函数</strong></td>
<td>cin<br />cout</td>
<td>cin 和 cout <strong>无需指定输入输出格式</strong>，<br />但<strong>消耗的时间</strong>比 scanf 和 printf <strong>多得多</strong></td>
</tr>
</tbody></table>
<hr>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><table>
<thead>
<tr>
<th>内容</th>
<th>C语言</th>
<th>C++</th>
</tr>
</thead>
<tbody><tr>
<td>输入输出库</td>
<td>#include &lt;stdio.h&gt;</td>
<td><strong>#include &lt;cstdio&gt;</strong><br /><strong>#include &lt;iostream&gt;</strong></td>
</tr>
<tr>
<td>数学函数</td>
<td>#include &lt;math.h&gt;</td>
<td><strong>#include &lt;cmath&gt;</strong></td>
</tr>
<tr>
<td>字符串有关函数</td>
<td>#include &lt;string.h&gt;</td>
<td><strong>#include &lt;cstring&gt;</strong></td>
</tr>
</tbody></table>
<hr>
<h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><h3 id="布尔型变量"><a href="#布尔型变量" class="headerlink" title="布尔型变量"></a>布尔型变量</h3><table>
<thead>
<tr>
<th>C语言</th>
<th>C++</th>
<th>比较</th>
</tr>
</thead>
<tbody><tr>
<td>#include &lt;stdbool.h&gt;</td>
<td><strong>可直接使用</strong></td>
<td>true(存储时为1)<br />false(存储时为0)</td>
</tr>
</tbody></table>
<hr>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><table>
<thead>
<tr>
<th>内容</th>
<th>C语言</th>
<th>C++</th>
</tr>
</thead>
<tbody><tr>
<td>表示方法</td>
<td>通过 字符数组 表示</td>
<td>通过 string类 表示</td>
</tr>
<tr>
<td>字符串长度的表示</td>
<td>#include &lt;string.h&gt;<br />strlen(str)</td>
<td>#include &lt;string&gt;<br />str.length()</td>
</tr>
<tr>
<td>字符串拼接</td>
<td>#include &lt;string.h&gt;<br />strcat(str1, str2); &#x2F;&#x2F;把str2拼接到str1之后</td>
<td>str1 +&#x3D; str2;</td>
</tr>
</tbody></table>
<hr>
<h2 id="排序函数"><a href="#排序函数" class="headerlink" title="排序函数"></a>排序函数</h2><ul>
<li>C语言 — qsort</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>

<span class="token keyword">int</span> <span class="token function">cmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>a <span class="token operator">-</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>b<span class="token punctuation">;</span> <span class="token comment">//升序</span>
<span class="token punctuation">&#125;</span>

<span class="token function">qsort</span><span class="token punctuation">(</span>排序数组<span class="token punctuation">,</span> 元素数量<span class="token punctuation">,</span> 每个元素的大小<span class="token punctuation">(</span>可用<span class="token keyword">sizeof</span>获得<span class="token punctuation">)</span><span class="token punctuation">,</span> 比较函数cmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>C++ — sort</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;algorithm&gt;

bool cmp(int a, int b) &#123;
    return a &gt; b; &#x2F;&#x2F;降序
&#125;

sort(首元素地址, 尾元素地址的下一个地址, 比较函数cmp(非必填));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<table>
<thead>
<tr>
<th>cmp函数的区别</th>
<th>C语言</th>
<th>C++</th>
</tr>
</thead>
<tbody><tr>
<td>返回值类型</td>
<td>int</td>
<td>bool</td>
</tr>
<tr>
<td>排序的判断</td>
<td>返回值 &gt; 0, a 将被排在b后面;<br />返回值 &lt; 0, a 将被排在b前面;</td>
<td><strong>默认升序</strong><br />返回值为<strong>true</strong>时，a将被排在b<strong>前面</strong></td>
</tr>
<tr>
<td>比较方式</td>
<td>元素<strong>相减</strong><br />不能用$&gt;$、$&lt;$比较符（<strong>返回无负值</strong>）</td>
<td>$&gt;$、$&lt;$比较符</td>
</tr>
</tbody></table>
<p><code>qsort</code>函数的使用需要运用指针，且写法上没有<code>sort</code>函数简洁。<code>sort</code>函数<strong>根据具体情形使用不同的排序方法</strong>，效率较高，在实现中<strong>规避了经典快速排序中可能出现的会导致实际复杂度退化到$O(n^2)$的极端情况</strong>。</p>
<p>因此<strong>更推荐使用C++的<code>sort</code>函数</strong>进行代码编写。</p>
<hr>
<h2 id="申请动态内存空间"><a href="#申请动态内存空间" class="headerlink" title="申请动态内存空间"></a>申请动态内存空间</h2><p><strong>内存泄露</strong>是指申请到的内存空间在<strong>使用过后没有释放</strong>，导致一些程序<strong>内存消耗过快，最后无内存可分配</strong>的情况。一般考试中，分配的内存空间在程序结束时即被释放，因此即便不是放空间，也不会产生什么影响，并且内存大小一般也足够一道题的使用。但是<strong>从编程习惯上，需要养成即时释放空间的习惯</strong>。</p>
<ul>
<li><p>C语言</p>
<p><code>&lt;stdlib.h&gt;</code></p>
<ul>
<li><p>申请内存空间 — <code>malloc</code>函数：</p>
<p>以<strong>需要申请的内存空间</strong>为参数，返回<strong>指向这块空间的指针</strong>，因为<strong>返回的指针是<code>void*</code>型，因此需要强制转换为对应类型</strong>：<code>typename* p = (typename*)malloc(sizeof(typename));</code></p>
<p>示例：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
node<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token punctuation">(</span>node<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>通常情况下，内存空间的申请不会失败。失败一般发生在使用<code>malloc</code><strong>申请了较大的动态数组</strong>，如：<code>int* p = (int*)malloc(1000000 * sizeof(int));</code>。<strong>申请失败会返回空指针<code>NULL</code></strong>。</p>
</li>
<li><p>释放内存 — <code>free</code>函数：</p>
<p>以<strong>需要释放的内存空间的指针变量</strong>为参数：<code>free(p);</code>，执行之后，<strong>指针变量<code>p</code>没有消失，只是指向了空地址<code>NULL</code></strong>。</p>
</li>
</ul>
</li>
<li><p>C++</p>
<ul>
<li><p>申请内存空间 — <code>new</code>运算符：</p>
<p>使用<strong>new + 类型名</strong>即可分配一块该类型的内存空间，<strong>返回申请的同变量类型的指针</strong>：<code>typename* p = new typename;</code></p>
<p>示例：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int* p &#x3D; new int;
node* p &#x3D; new node;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>通常情况下，内存空间的申请不会失败。失败一般发生在使用<code>new</code><strong>申请了较大的动态数组</strong>，如：<code>int* p = new int[1000000];</code>。<strong>申请失败会发生异常</strong>。</p>
</li>
<li><p>释放内存 — <code>delete</code>运算符：</p>
<p>以<strong>需要释放的内存空间的指针变量</strong>为参数：<code>delete(p);</code>，执行之后，<strong>指针变量<code>p</code>没有消失，只是指向了空地址<code>NULL</code></strong>。</p>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hunter1023.github.io/2020/01/17/%E5%90%AF%E5%8A%A8U%E7%9B%98%E5%AE%89%E8%A3%85Ubuntu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hunter">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talk is cheap">
      <meta itemprop="description" content="Tough times never last, but tough people do.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Talk is cheap">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/01/17/%E5%90%AF%E5%8A%A8U%E7%9B%98%E5%AE%89%E8%A3%85Ubuntu/" class="post-title-link" itemprop="url">启动U盘安装Ubuntu(单系统)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-17 20:40:24" itemprop="dateCreated datePublished" datetime="2020-01-17T20:40:24+08:00">2020-01-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-23 23:29:13" itemprop="dateModified" datetime="2025-01-23T23:29:13+08:00">2025-01-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%BD%AF%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">操作系统与软件</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>由于<strong>PE方式只适用于安装windows</strong>，因此选择常规的<strong>制作启动U盘</strong>进行Ubuntu的安装。</p>
<h3 id="操作系统镜像下载（桌面版，文件名后缀-iso-torrent）"><a href="#操作系统镜像下载（桌面版，文件名后缀-iso-torrent）" class="headerlink" title="操作系统镜像下载（桌面版，文件名后缀 .iso.torrent）"></a>操作系统镜像下载（桌面版，文件名后缀 .iso.torrent）</h3><ul>
<li>方式一：<a target="_blank" rel="noopener" href="https://ubuntu.com/#download">Ubuntu官网直接下载镜像</a></li>
<li>方式二：<a target="_blank" rel="noopener" href="http://releases.ubuntu.com/18.04/">Ubuntu官网下载镜像种子</a> + 迅雷下载镜像 （速度快，<strong>推荐</strong>）</li>
</ul>
<h3 id="3G及以上空间的U盘-移动硬盘-用于装载系统镜像"><a href="#3G及以上空间的U盘-移动硬盘-用于装载系统镜像" class="headerlink" title="3G及以上空间的U盘&#x2F;移动硬盘(用于装载系统镜像)"></a><strong>3G及以上空间</strong>的U盘&#x2F;移动硬盘(用于装载系统镜像)</h3><h3 id="制作启动U盘"><a href="#制作启动U盘" class="headerlink" title="制作启动U盘"></a>制作启动U盘</h3><ul>
<li><p>方式一：<strong>Windows 10 可以直接打开 iso镜像文件，不用下载任何工具</strong></p>
<ol>
<li><p>格式化U盘</p>
</li>
<li><p>双击ISO文件，然后选中打开的所有文件，复制到U盘即可</p>
</li>
</ol>
</li>
<li><p>方式二：<a target="_blank" rel="noopener" href="http://rufus.ie/">下载U盘制作制作工具Rufus</a>(<strong>无需安装，可直接运行</strong>)</p>
<ol>
<li><p>选择设备(需要被制作的U盘&#x2F;移动硬盘)</p>
<ul>
<li>只有一个外接设备时会自动读取</li>
<li>如果<strong>外接设备是移动硬盘</strong>，需要<strong>显示高级设备选项 — 显示USB外置硬盘</strong></li>
</ul>
</li>
<li><p>选择操作系统镜像</p>
</li>
<li><p><strong>分区类型</strong>（<strong>理论上</strong>（联想Y480不知道为什么无法通过UEFI成功安装））</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av45677113">硬盘格式与引导方式、MBR与GPT、UEFI 与LEGACY bios的区别</a></p>
<ul>
<li><p>若选择GPT，之后系统安装时选择<strong>UEFI启动</strong>（<strong>推荐</strong>）</p>
</li>
<li><p>若选择MBR，之后系统安装时<strong>选择BIOS启动，否则报错</strong>（该模式一定能够安装成功）</p>
</li>
</ul>
</li>
<li><p>其余选项默认，点击<strong>开始</strong>，即可制作启动U盘</p>
</li>
</ol>
<img src="https://i.loli.net/2020/01/17/9KOmaTAQcIqdkpo.png" alt="Rufus制作启动U盘" style="zoom:80%;" /></li>
</ul>
<hr>
<h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><ol>
<li><p>重启电脑，进入<strong>选择启动方式界面</strong>（联想笔记本：F12；惠普笔记本：F9）</p>
</li>
<li><p>选择启动U盘</p>
<ul>
<li>想要安装系统的硬盘的格式为<strong>GPT</strong>，选择<strong>UEFI启动，即 EFI USB Device</strong></li>
<li>启动U盘分区类型为<strong>MBR</strong>，选择<strong>BIOS启动，即 选择对应的U盘</strong></li>
</ul>
</li>
<li><p>欢迎 — 中文 — 安装Ubuntu</p>
</li>
<li><p>键盘布局 — 汉语</p>
</li>
<li><p>无线 — 不连接</p>
</li>
<li><p>更新和其他软件 — <strong>最小安装</strong></p>
</li>
<li><p>安装类型 — 其他选项 — 进行分区</p>
<p>硬盘大小110GB</p>
<ul>
<li><p><strong>UEFI</strong>启动：</p>
<table>
<thead>
<tr>
<th>空间大小</th>
<th>主分区&#x2F;逻辑分区</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>200MB</td>
<td><strong>逻辑分区</strong></td>
<td><strong>EFI</strong></td>
</tr>
<tr>
<td>8GB<br />（和内存大小一致）</td>
<td>主分区</td>
<td>swap(交换)</td>
</tr>
<tr>
<td>40GB</td>
<td>逻辑分区</td>
<td>ext4<br />挂载至 “&#x2F;”</td>
</tr>
<tr>
<td>剩余空间</td>
<td>逻辑分区</td>
<td>ext4<br />挂载至 “&#x2F;home”</td>
</tr>
</tbody></table>
</li>
<li><p><strong>BIOS</strong>启动：</p>
<table>
<thead>
<tr>
<th>空间大小</th>
<th>主分区&#x2F;逻辑分区</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>200MB</td>
<td><strong>主分区</strong></td>
<td><strong>biosxx</strong></td>
</tr>
<tr>
<td>8GB （和内存大小一致）</td>
<td>主分区</td>
<td>swap(交换)</td>
</tr>
<tr>
<td>40GB</td>
<td>逻辑分区</td>
<td>ext4 挂载至 “&#x2F;”</td>
</tr>
<tr>
<td>剩余空间</td>
<td>逻辑分区</td>
<td>ext4 挂载至 “&#x2F;home”</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>完成安装，根据提示重启即可(可拔去启动U盘&#x2F;硬盘，避免再次从启动U盘启动)</p>
</li>
</ol>
<hr>
<h2 id="将-从主服务器下载-更换为-国内镜像站点下载"><a href="#将-从主服务器下载-更换为-国内镜像站点下载" class="headerlink" title="将 从主服务器下载 更换为 国内镜像站点下载"></a>将 从主服务器下载 更换为 国内镜像站点下载</h2><p>​	显示应用程序 - 软件和更新 - Ubuntu软件 - 下载自 - 其他站点 - 选择最佳服务器（自动选择最合适的站点）</p>
<hr>
<h2 id="更新系统文件"><a href="#更新系统文件" class="headerlink" title="更新系统文件"></a>更新系统文件</h2><p><strong>打开终端</strong>的快捷键：<code>Ctrl</code>+<code>Alt</code>+<code>T</code></p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">sudo apt update
sudo apt upgrade<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<hr>
<h2 id="获得各种开发工具"><a href="#获得各种开发工具" class="headerlink" title="获得各种开发工具"></a>获得各种开发工具</h2><p><code>sudo apt-get install build-essential</code></p>
<ul>
<li><p>安装<strong>文字编辑器vim</strong>和<strong>浏览器chromium</strong></p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">sudo apt-get install vim
sudo apt-get install chromium-browser<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>树视图</p>
<p><code>sudo apt-get install tree</code></p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hunter1023.github.io/2019/04/16/Cmder/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hunter">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talk is cheap">
      <meta itemprop="description" content="Tough times never last, but tough people do.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Talk is cheap">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/04/16/Cmder/" class="post-title-link" itemprop="url">Cmder</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-04-16 17:38:25" itemprop="dateCreated datePublished" datetime="2019-04-16T17:38:25+08:00">2019-04-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-23 23:29:13" itemprop="dateModified" datetime="2025-01-23T23:29:13+08:00">2025-01-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%BD%AF%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">操作系统与软件</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>官网下载Cmder（压缩包，解压即用），有两种不同的版本可供选择：</p>
<ul>
<li>Mini</li>
<li>Full（附带msysgit工具）</li>
</ul>
<p>可根据设备是否已安装git自行选择</p>
<hr>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="添加系统环境变量"><a href="#添加系统环境变量" class="headerlink" title="添加系统环境变量"></a>添加系统环境变量</h3><p>我的电脑 - 右键属性 - 高级系统设置 - 环境变量 - 系统变量，在<code>Path</code>中添加Cmder路径</p>
<p><img src="https://i.loli.net/2019/04/16/5cb5a739330de.png"></p>
<hr>
<h3 id="添加Cmder到右键菜单"><a href="#添加Cmder到右键菜单" class="headerlink" title="添加Cmder到右键菜单"></a>添加Cmder到右键菜单</h3><ol>
<li><code>Win + R</code> - 输入<code>Cmder</code>，确认，打开Cmder</li>
<li>点击右下方的<code>Create new console</code></li>
<li>Startup command or {Task} name - {bash::bash}</li>
<li>Run as administrator</li>
<li>Start，即打开一个管理员权限的控制台 <img src="https://i.loli.net/2019/04/17/5cb6b470b7f0f.png"></li>
<li>输入 <code>Cmder.exe /REGISTER ALL</code>，回车。即可在每个文件夹中鼠标右键右键 - <code>Cmder here</code>，打开Cmder</li>
</ol>
<hr>
<h2 id="默认开启设置"><a href="#默认开启设置" class="headerlink" title="默认开启设置"></a>默认开启设置</h2><p>Cmder窗口右下角右键<code>Show system menu</code> - General - Choose your startup task or even a shell with arguments: - {bash::bash} - Save settings</p>
<p><img src="https://i.loli.net/2019/04/17/5cb6bbe028a30.png"></p>
<hr>
<h2 id="关闭Tab不提示"><a href="#关闭Tab不提示" class="headerlink" title="关闭Tab不提示"></a>关闭Tab不提示</h2><p>Cmder窗口右下角右键<code>Show system menu</code> - General - Confirm - Close confirmations下的复选框全不勾选 - Save settings</p>
<p><img src="https://i.loli.net/2019/04/17/5cb6bd25b23b6.png"></p>
<hr>
<p>参考：<a target="_blank" rel="noopener" href="http://weikeqin.cn/2017/04/28/cmder-notes/">Cmder 使用 笔记</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hunter1023.github.io/2019/04/16/Dev-Cpp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hunter">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talk is cheap">
      <meta itemprop="description" content="Tough times never last, but tough people do.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Talk is cheap">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/04/16/Dev-Cpp/" class="post-title-link" itemprop="url">Dev-C++</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-04-16 16:37:07" itemprop="dateCreated datePublished" datetime="2019-04-16T16:37:07+08:00">2019-04-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-23 23:29:13" itemprop="dateModified" datetime="2025-01-23T23:29:13+08:00">2025-01-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%BD%AF%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">操作系统与软件</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Dev-C++是一个SourceForge的项目，<strong>早已停止更新</strong>。</p>
<p>缺点：</p>
<ul>
<li>分辨率低，脱节于屏幕素质的提升，使用感官不佳</li>
<li>中文注释容易乱码，且没有明显的选项用来修改编码格式</li>
</ul>
<hr>
<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>安装过程中的语言没有中文选项，选择English即可，按照默认选项安装。首次运行时，选择<strong>使用软件时的语言</strong>为简体中文即可，按照默认选项完成初运行配置。</p>
<hr>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><ul>
<li>菜单栏 - 工具 - 编辑器选项 - 语法 - 预设 - Obsidian 黑曜石主题</li>
</ul>
<p><img src="https://i.loli.net/2019/04/16/5cb598b4cba28.png" alt="工具 - 编辑器选项"></p>
<p><img src="https://i.loli.net/2019/04/16/5cb599bfef712.png" alt="语法 - 预设 - Obsidian 黑曜石主题"></p>
<ul>
<li><p>菜单栏 - 工具 - 编辑器选项 - 基本</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 显示编辑器提示</li>
<li><input checked="" disabled="" type="checkbox"> 显示函数提示</li>
<li>高亮显示当前行 - 色彩 - Black</li>
</ul>
<p><img src="https://i.loli.net/2019/04/16/5cb59bb680afc.png"></p>
</li>
</ul>
<hr>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>菜单栏 - 工具 - 编辑器选项 - 显示 - 字体 - YaHei Consolas Hybrid</p>
<p>字体下载： <a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1kldCHl7A5SIZaCLJniLzwQ"><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1kldCHl7A5SIZaCLJniLzwQ">Consolas和微软雅黑混合字体</a></a></p>
<hr>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><table>
<thead>
<tr>
<th>功能</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>自动整理代码</td>
<td>Ctrl + Shift + A</td>
</tr>
<tr>
<td>代码补全</td>
<td>Ctrl + Space(<strong>和输入法切换快捷键冲突</strong>)</td>
</tr>
</tbody></table>
<p>自定义快捷键：工具 - 快捷键选项 - 菜单项的底部 - Show Code Completion(代码补全)，自定义即可。</p>
<hr>
<h2 id="添加-C99-C-11-标准"><a href="#添加-C99-C-11-标准" class="headerlink" title="添加 C99&#x2F;C++11 标准"></a>添加 C99&#x2F;C++11 标准</h2><p>工具 - 编译选项 - 编译时加入以下命令 - <code>-std=c99</code>或<code>-std=C++11</code></p>
<p><img src="https://i.loli.net/2019/04/16/5cb59e4d63a98.png"></p>
<hr>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="初次启用调试，出现“项目没有调试信息，您想打开项目调试选项并重新生成吗”"><a href="#初次启用调试，出现“项目没有调试信息，您想打开项目调试选项并重新生成吗”" class="headerlink" title="初次启用调试，出现“项目没有调试信息，您想打开项目调试选项并重新生成吗”"></a>初次启用调试，出现“项目没有调试信息，您想打开项目调试选项并重新生成吗”</h3><p>菜单栏 - 工具 - 编译选项 - 代码生成&#x2F;优化 - 连接器 - 产生调试信息 - Yes</p>
<p><img src="https://i.loli.net/2019/04/17/5cb6d8b4f11b0.png"></p>
<h3 id="调试窗口查看变量的实时数据"><a href="#调试窗口查看变量的实时数据" class="headerlink" title="调试窗口查看变量的实时数据"></a>调试窗口查看变量的实时数据</h3><p>开启调试后，有三种方式可以查看变量的实时数据：</p>
<ol>
<li>左侧调试窗口 - 空白处鼠标右键 - 添加查看</li>
<li>下侧调试窗口 - 添加查看</li>
<li>代码界面鼠标在变量名处停留，会显示当前变量值</li>
</ol>
<p><img src="https://i.loli.net/2019/04/17/5cb6dc99352a7.png"></p>
<hr>
<p>参考：</p>
<ul>
<li><del><a target="_blank" rel="noopener" href="https://ice1000.org/2016/10/28/DevCpp/">如何正确使用 DEV C++</a></del></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/MonkeyWang98/article/details/80202024">DEV-C++调试时出现“项目没有调试信息，你想打开调试选项并重新生成吗”</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hunter1023.github.io/2019/03/25/%E9%A6%99%E6%B8%AF%E6%B8%B8%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hunter">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talk is cheap">
      <meta itemprop="description" content="Tough times never last, but tough people do.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Talk is cheap">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/03/25/%E9%A6%99%E6%B8%AF%E6%B8%B8%E8%AE%B0/" class="post-title-link" itemprop="url">香港两日半 | 不妨长作岭南人</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-03-25 18:00:01" itemprop="dateCreated datePublished" datetime="2019-03-25T18:00:01+08:00">2019-03-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-13 21:08:26" itemprop="dateModified" datetime="2025-02-13T21:08:26+08:00">2025-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%B8%B8%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">游记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="情之所起"><a href="#情之所起" class="headerlink" title="情之所起"></a>情之所起</h2><p>说起香港，脑海中闪过的第一个念头就是《重庆森林》——重庆大厦里奔走的林青霞、趴在半山扶梯上窥看编号633住处的王菲和她哼唱的《California Dreamin’》。终于要去见识这个憧憬太久的目的地了啊。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/03/25/%E9%A6%99%E6%B8%AF%E6%B8%B8%E8%AE%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/8/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/10/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Hunter</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"Hunter1023/Hunter1023.github.io","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>

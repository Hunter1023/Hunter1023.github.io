<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"hunter1023.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":3,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="第1章 了解SQL 数据库软件应称为DBMS（数据库管理系统）。 数据库是通过DBMS创建和操纵的容器。 在很大程度上说，数据库究竟是文件还是别的什么东西并不重要，因为你并不直接访问数据库；你使用的是DBMS，它替你访问数据库。 模式（schema）： 关于数据库和表的布局及特性的信息。 有时，模式用作数据库的同义词。遗憾的是，模式的含义通常在上下文中并不是很清晰。 主键（primary key）">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL必知必会">
<meta property="og:url" content="https://hunter1023.github.io/2020/06/14/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/index.html">
<meta property="og:site_name" content="Talk is cheap">
<meta property="og:description" content="第1章 了解SQL 数据库软件应称为DBMS（数据库管理系统）。 数据库是通过DBMS创建和操纵的容器。 在很大程度上说，数据库究竟是文件还是别的什么东西并不重要，因为你并不直接访问数据库；你使用的是DBMS，它替你访问数据库。 模式（schema）： 关于数据库和表的布局及特性的信息。 有时，模式用作数据库的同义词。遗憾的是，模式的含义通常在上下文中并不是很清晰。 主键（primary key）">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-06-14T00:26:30.000Z">
<meta property="article:modified_time" content="2025-01-23T15:29:13.000Z">
<meta property="article:author" content="Hunter">
<meta property="article:tag" content="MySQL">
<meta property="article:tag" content="SQL">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://hunter1023.github.io/2020/06/14/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://hunter1023.github.io/2020/06/14/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/","path":"2020/06/14/MySQL必知必会/","title":"MySQL必知必会"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>MySQL必知必会 | Talk is cheap</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Talk is cheap</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC1%E7%AB%A0-%E4%BA%86%E8%A7%A3SQL"><span class="nav-number">1.</span> <span class="nav-text">第1章 了解SQL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC2%E7%AB%A0-MySQL%E7%AE%80%E4%BB%8B"><span class="nav-number">2.</span> <span class="nav-text">第2章 MySQL简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AEMySQL%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">2.1.</span> <span class="nav-text">配置MySQL环境变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%9F%E4%B8%80%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%BAUTF-8"><span class="nav-number">2.2.</span> <span class="nav-text">统一字符集为UTF-8</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC3%E7%AB%A0-%E4%BD%BF%E7%94%A8MySQL"><span class="nav-number">3.</span> <span class="nav-text">第3章 使用MySQL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5"><span class="nav-number">3.1.</span> <span class="nav-text">连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">3.2.</span> <span class="nav-text">选择数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8"><span class="nav-number">3.3.</span> <span class="nav-text">了解数据库和表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC4%E7%AB%A0-%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE"><span class="nav-number">4.</span> <span class="nav-text">第4章 检索数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E7%B4%A2%E5%8D%95%E4%B8%AA%E5%88%97"><span class="nav-number">4.1.</span> <span class="nav-text">检索单个列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E7%B4%A2%E5%A4%9A%E4%B8%AA%E5%88%97"><span class="nav-number">4.2.</span> <span class="nav-text">检索多个列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E7%B4%A2%E6%89%80%E6%9C%89%E5%88%97"><span class="nav-number">4.3.</span> <span class="nav-text">检索所有列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E7%B4%A2%E4%B8%8D%E5%90%8C%E7%9A%84%E8%A1%8C"><span class="nav-number">4.4.</span> <span class="nav-text">检索不同的行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E7%BB%93%E6%9E%9C"><span class="nav-number">4.5.</span> <span class="nav-text">限制结果</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC5%E7%AB%A0-%E6%8E%92%E5%BA%8F%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE"><span class="nav-number">5.</span> <span class="nav-text">第5章 排序检索数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E6%95%B0%E6%8D%AE"><span class="nav-number">5.1.</span> <span class="nav-text">排序数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%89%E5%A4%9A%E4%B8%AA%E5%88%97%E6%8E%92%E5%BA%8F"><span class="nav-number">5.2.</span> <span class="nav-text">按多个列排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E6%8E%92%E5%BA%8F%E6%96%B9%E5%90%91"><span class="nav-number">5.3.</span> <span class="nav-text">指定排序方向</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC6%E7%AB%A0-%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE"><span class="nav-number">6.</span> <span class="nav-text">第6章 过滤数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8WHERE%E5%AD%90%E5%8F%A5"><span class="nav-number">6.1.</span> <span class="nav-text">使用WHERE子句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WHERE%E5%AD%90%E5%8F%A5%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">6.2.</span> <span class="nav-text">WHERE子句操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E5%8D%95%E4%B8%AA%E5%80%BC"><span class="nav-number">6.2.1.</span> <span class="nav-text">检查单个值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%8C%B9%E9%85%8D%E6%A3%80%E6%9F%A5"><span class="nav-number">6.2.2.</span> <span class="nav-text">不匹配检查</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4%E5%80%BC%E6%A3%80%E6%9F%A5"><span class="nav-number">6.2.3.</span> <span class="nav-text">范围值检查</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E5%80%BC%E6%A3%80%E6%9F%A5"><span class="nav-number">6.2.4.</span> <span class="nav-text">空值检查</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC7%E7%AB%A0-%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4"><span class="nav-number">7.</span> <span class="nav-text">第7章 数据过滤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88WHERE%E5%AD%90%E5%8F%A5"><span class="nav-number">7.1.</span> <span class="nav-text">组合WHERE子句</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%AC%A1%E5%BA%8F"><span class="nav-number">7.1.1.</span> <span class="nav-text">计算次序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IN%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">7.2.</span> <span class="nav-text">IN操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NOT%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">7.3.</span> <span class="nav-text">NOT操作符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC8%E7%AB%A0-%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4"><span class="nav-number">8.</span> <span class="nav-text">第8章 用通配符进行过滤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LIKE%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">8.1.</span> <span class="nav-text">LIKE操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%99%BE%E5%88%86%E5%8F%B7-%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-number">8.1.1.</span> <span class="nav-text">百分号(%)通配符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8B%E5%88%92%E7%BA%BF-%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-number">8.1.2.</span> <span class="nav-text">下划线(_)通配符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E6%8A%80%E5%B7%A7"><span class="nav-number">8.2.</span> <span class="nav-text">使用通配符的技巧</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC9%E7%AB%A0-%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%90%9C%E7%B4%A2"><span class="nav-number">9.</span> <span class="nav-text">第9章 用正则表达式进行搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BB%8B%E7%BB%8D"><span class="nav-number">9.1.</span> <span class="nav-text">正则表达式介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8MySQL%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">9.2.</span> <span class="nav-text">使用MySQL正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D"><span class="nav-number">9.2.1.</span> <span class="nav-text">基本字符匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E8%A1%8COR%E5%8C%B9%E9%85%8D"><span class="nav-number">9.2.2.</span> <span class="nav-text">进行OR匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B9%8B%E4%B8%80"><span class="nav-number">9.2.3.</span> <span class="nav-text">匹配几个字符之一</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E8%8C%83%E5%9B%B4"><span class="nav-number">9.2.4.</span> <span class="nav-text">匹配范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6"><span class="nav-number">9.2.5.</span> <span class="nav-text">匹配特殊字符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E5%AD%97%E7%AC%A6%E7%B1%BB"><span class="nav-number">9.2.6.</span> <span class="nav-text">匹配字符类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E5%A4%9A%E4%B8%AA%E5%AE%9E%E4%BE%8B"><span class="nav-number">9.2.7.</span> <span class="nav-text">匹配多个实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%BD%8D%E7%AC%A6"><span class="nav-number">9.2.8.</span> <span class="nav-text">定位符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC10%E7%AB%A0-%E5%88%9B%E5%BB%BA%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5"><span class="nav-number">10.</span> <span class="nav-text">第10章 创建计算字段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5"><span class="nav-number">10.1.</span> <span class="nav-text">计算字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%BC%E6%8E%A5%E5%AD%97%E6%AE%B5"><span class="nav-number">10.2.</span> <span class="nav-text">拼接字段</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC11%E7%AB%A0-%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-number">11.</span> <span class="nav-text">第11章 使用数据处理函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">11.1.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-number">11.2.</span> <span class="nav-text">使用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%87%BD%E6%95%B0"><span class="nav-number">11.2.1.</span> <span class="nav-text">转换数据类型函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-number">11.2.2.</span> <span class="nav-text">文本处理函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-number">11.2.3.</span> <span class="nav-text">日期和时间处理函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-number">11.2.4.</span> <span class="nav-text">数值处理函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IF%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">11.2.5.</span> <span class="nav-text">IF表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IFNULL%E5%87%BD%E6%95%B0"><span class="nav-number">11.2.6.</span> <span class="nav-text">IFNULL函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%80%E7%AA%97%E5%87%BD%E6%95%B0-%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="nav-number">11.2.7.</span> <span class="nav-text">开窗函数&#x2F;窗口函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">11.2.7.1.</span> <span class="nav-text">窗口函数的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="nav-number">11.2.7.2.</span> <span class="nav-text">什么是窗口函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%93%E7%94%A8%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0RANK"><span class="nav-number">11.2.7.3.</span> <span class="nav-text">专用窗口函数RANK</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E4%B8%93%E7%94%A8%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="nav-number">11.2.7.4.</span> <span class="nav-text">其他专用窗口函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="nav-number">11.2.7.5.</span> <span class="nav-text">聚合函数作为窗口函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">11.2.7.6.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL-8-0%E5%89%8D%E6%B2%A1%E6%9C%89%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="nav-number">11.2.8.</span> <span class="nav-text">MySQL 8.0前没有窗口函数，怎么办</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%8C%E8%BD%AC%E5%88%97Pivot%E5%87%BD%E6%95%B0-MySQL%E6%B2%A1%E6%9C%89%EF%BC%8CSQL-Server%E6%9C%89"><span class="nav-number">11.2.9.</span> <span class="nav-text">行转列Pivot函数(MySQL没有，SQL Server有)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%97%E8%BD%AC%E8%A1%8CUNPIVOT%E5%87%BD%E6%95%B0"><span class="nav-number">11.2.10.</span> <span class="nav-text">列转行UNPIVOT函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC12%E7%AB%A0-%E6%B1%87%E6%80%BB%E6%95%B0%E6%8D%AE"><span class="nav-number">12.</span> <span class="nav-text">第12章 汇总数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0"><span class="nav-number">12.1.</span> <span class="nav-text">聚集函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AVG-%E5%87%BD%E6%95%B0"><span class="nav-number">12.1.1.</span> <span class="nav-text">AVG()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#COUNT-%E5%87%BD%E6%95%B0"><span class="nav-number">12.1.2.</span> <span class="nav-text">COUNT()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MAX-%E5%87%BD%E6%95%B0"><span class="nav-number">12.1.3.</span> <span class="nav-text">MAX()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MIN-%E5%87%BD%E6%95%B0"><span class="nav-number">12.1.4.</span> <span class="nav-text">MIN()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SUM-%E5%87%BD%E6%95%B0"><span class="nav-number">12.1.5.</span> <span class="nav-text">SUM()函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%9A%E9%9B%86%E4%B8%8D%E5%90%8C%E5%80%BC"><span class="nav-number">12.2.</span> <span class="nav-text">聚集不同值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0"><span class="nav-number">12.3.</span> <span class="nav-text">组合聚集函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC13%E7%AB%A0-%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE"><span class="nav-number">13.</span> <span class="nav-text">第13章 分组数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%88%86%E7%BB%84"><span class="nav-number">13.1.</span> <span class="nav-text">数据分组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%88%86%E7%BB%84"><span class="nav-number">13.2.</span> <span class="nav-text">创建分组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E5%88%86%E7%BB%84"><span class="nav-number">13.3.</span> <span class="nav-text">过滤分组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E5%92%8C%E6%8E%92%E5%BA%8F"><span class="nav-number">13.4.</span> <span class="nav-text">分组和排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SELECT%E5%AD%90%E5%8F%A5%E9%A1%BA%E5%BA%8F"><span class="nav-number">13.5.</span> <span class="nav-text">SELECT子句顺序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC14%E7%AB%A0-%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-number">14.</span> <span class="nav-text">第14章 使用子查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-number">14.1.</span> <span class="nav-text">子查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4"><span class="nav-number">14.2.</span> <span class="nav-text">利用子查询进行过滤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E4%B8%BA%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-number">14.3.</span> <span class="nav-text">作为计算字段使用子查询</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC15%E7%AB%A0-%E8%81%94%E7%BB%93%E8%A1%A8"><span class="nav-number">15.</span> <span class="nav-text">第15章 联结表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%94%E7%BB%93"><span class="nav-number">15.1.</span> <span class="nav-text">联结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E8%A1%A8"><span class="nav-number">15.1.1.</span> <span class="nav-text">关系表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E8%81%94%E7%BB%93"><span class="nav-number">15.1.2.</span> <span class="nav-text">为什么要使用联结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%81%94%E7%BB%93"><span class="nav-number">15.2.</span> <span class="nav-text">创建联结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#WHERE%E5%AD%90%E5%8F%A5%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="nav-number">15.2.1.</span> <span class="nav-text">WHERE子句的重要性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E8%81%94%E7%BB%93"><span class="nav-number">15.2.2.</span> <span class="nav-text">内部联结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%94%E7%BB%93%E5%A4%9A%E4%B8%AA%E8%A1%A8"><span class="nav-number">15.2.3.</span> <span class="nav-text">联结多个表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC16%E7%AB%A0-%E5%88%9B%E5%BB%BA%E9%AB%98%E7%BA%A7%E8%81%94%E7%BB%93"><span class="nav-number">16.</span> <span class="nav-text">第16章 创建高级联结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E8%81%94%E7%BB%93"><span class="nav-number">16.1.</span> <span class="nav-text">自联结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E7%84%B6%E8%81%94%E7%BB%93"><span class="nav-number">16.2.</span> <span class="nav-text">自然联结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E8%81%94%E7%BB%93"><span class="nav-number">16.3.</span> <span class="nav-text">外部联结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%81%94%E7%BB%93%E5%92%8C%E8%81%94%E7%BB%93%E6%9D%A1%E4%BB%B6"><span class="nav-number">16.4.</span> <span class="nav-text">使用联结和联结条件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC17%E7%AB%A0-%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="nav-number">17.</span> <span class="nav-text">第17章 组合查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="nav-number">17.1.</span> <span class="nav-text">组合查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="nav-number">17.2.</span> <span class="nav-text">创建组合查询</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8UNION"><span class="nav-number">17.2.1.</span> <span class="nav-text">使用UNION</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UNION%E8%A7%84%E5%88%99"><span class="nav-number">17.2.2.</span> <span class="nav-text">UNION规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%85%E5%90%AB%E6%88%96%E5%8F%96%E6%B6%88%E9%87%8D%E5%A4%8D%E7%9A%84%E8%A1%8C"><span class="nav-number">17.2.3.</span> <span class="nav-text">包含或取消重复的行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E6%8E%92%E5%BA%8F"><span class="nav-number">17.2.4.</span> <span class="nav-text">对组合查询结果排序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95"><span class="nav-number">18.</span> <span class="nav-text">索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="nav-number">18.1.</span> <span class="nav-text">MySQL创建索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="nav-number">18.1.1.</span> <span class="nav-text">索引的介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CREATE-INDEX%E8%AF%AD%E5%8F%A5"><span class="nav-number">18.1.2.</span> <span class="nav-text">CREATE INDEX语句</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="nav-number">18.2.</span> <span class="nav-text">MySQL删除索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL%E6%9F%A5%E8%AF%A2%E7%B4%A2%E5%BC%95%E4%BF%A1%E6%81%AF"><span class="nav-number">18.3.</span> <span class="nav-text">MySQL查询索引信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%EF%BC%8C%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D"><span class="nav-number">18.4.</span> <span class="nav-text">使用唯一索引，避免重复</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90"><span class="nav-number">18.4.1.</span> <span class="nav-text">例子</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">18.5.</span> <span class="nav-text">索引的使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E7%B4%A2%E5%BC%95"><span class="nav-number">18.6.</span> <span class="nav-text">强制索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC18%E7%AB%A0-%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2"><span class="nav-number">19.</span> <span class="nav-text">第18章 全文本搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%A7%A3%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2"><span class="nav-number">19.1.</span> <span class="nav-text">理解全文本搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2"><span class="nav-number">19.2.</span> <span class="nav-text">使用全文本搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E7%94%A8%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2%E6%94%AF%E6%8C%81"><span class="nav-number">19.2.1.</span> <span class="nav-text">启用全文本搜索支持</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E8%A1%8C%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2"><span class="nav-number">19.2.2.</span> <span class="nav-text">进行全文本搜索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%9F%A5%E8%AF%A2%E6%89%A9%E5%B1%95-QUERY-EXPANSION"><span class="nav-number">19.2.3.</span> <span class="nav-text">使用查询扩展(QUERY EXPANSION)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2"><span class="nav-number">19.2.4.</span> <span class="nav-text">布尔文本搜索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="nav-number">19.2.5.</span> <span class="nav-text">全文本搜索的使用说明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%9F%A5%E8%AF%A2%E9%A1%BA%E5%BA%8F"><span class="nav-number">20.</span> <span class="nav-text">SQL语句的查询顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CASE%E8%AF%AD%E5%8F%A5"><span class="nav-number">21.</span> <span class="nav-text">CASE语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC19%E7%AB%A0-%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="nav-number">22.</span> <span class="nav-text">第19章 插入数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%8F%92%E5%85%A5"><span class="nav-number">22.1.</span> <span class="nav-text">数据插入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E5%AE%8C%E6%95%B4%E7%9A%84%E8%A1%8C"><span class="nav-number">22.2.</span> <span class="nav-text">插入完整的行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E5%A4%9A%E4%B8%AA%E8%A1%8C"><span class="nav-number">22.3.</span> <span class="nav-text">插入多个行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%A3%80%E7%B4%A2%E5%87%BA%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">22.4.</span> <span class="nav-text">插入检索出的数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC20%E7%AB%A0-%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="nav-number">23.</span> <span class="nav-text">第20章 更新和删除数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE"><span class="nav-number">23.1.</span> <span class="nav-text">更新数据</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E4%B8%80%E5%BC%A0%E8%A1%A8%E7%9A%84%E8%AE%B0%E5%BD%95%E5%8E%BB%E6%9B%B4%E6%96%B0%E5%8F%A6%E4%B8%80%E5%BC%A0%E8%A1%A8%E7%9A%84%E8%AE%B0%E5%BD%95"><span class="nav-number">23.1.0.1.</span> <span class="nav-text">用一张表的记录去更新另一张表的记录</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="nav-number">23.2.</span> <span class="nav-text">删除数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E7%9A%84%E6%8C%87%E5%AF%BC%E5%8E%9F%E5%88%99"><span class="nav-number">23.3.</span> <span class="nav-text">更新和删除的指导原则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC21%E7%AB%A0-%E5%88%9B%E5%BB%BA%E5%92%8C%E6%93%8D%E7%BA%B5%E8%A1%A8"><span class="nav-number">24.</span> <span class="nav-text">第21章 创建和操纵表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%A1%A8"><span class="nav-number">24.1.</span> <span class="nav-text">创建表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E5%88%9B%E5%BB%BA%E5%9F%BA%E7%A1%80"><span class="nav-number">24.1.1.</span> <span class="nav-text">表创建基础</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8NULL%E5%80%BC"><span class="nav-number">24.1.2.</span> <span class="nav-text">使用NULL值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%E5%86%8D%E4%BB%8B%E7%BB%8D"><span class="nav-number">24.1.3.</span> <span class="nav-text">主键再介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8AUTO-INCREMENT"><span class="nav-number">24.1.4.</span> <span class="nav-text">使用AUTO_INCREMENT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-number">24.1.5.</span> <span class="nav-text">指定默认值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E6%93%8E%E7%B1%BB%E5%9E%8B"><span class="nav-number">24.1.6.</span> <span class="nav-text">引擎类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">24.1.7.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E8%A1%A8"><span class="nav-number">24.2.</span> <span class="nav-text">更新表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E8%A1%A8"><span class="nav-number">24.3.</span> <span class="nav-text">删除表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%91%BD%E5%90%8D%E8%A1%A8"><span class="nav-number">24.4.</span> <span class="nav-text">重命名表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80"><span class="nav-number">24.4.1.</span> <span class="nav-text">方式一</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC22%E7%AB%A0-%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE"><span class="nav-number">25.</span> <span class="nav-text">第22章 使用视图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE"><span class="nav-number">25.1.</span> <span class="nav-text">视图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE"><span class="nav-number">25.1.1.</span> <span class="nav-text">为什么使用视图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE%E7%9A%84%E8%A7%84%E5%88%99%E5%92%8C%E9%99%90%E5%88%B6"><span class="nav-number">25.1.2.</span> <span class="nav-text">视图的规则和限制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE"><span class="nav-number">25.2.</span> <span class="nav-text">使用视图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E8%A7%86%E5%9B%BE%E7%AE%80%E5%8C%96%E5%A4%8D%E6%9D%82%E7%9A%84%E8%81%94%E7%BB%93"><span class="nav-number">25.2.1.</span> <span class="nav-text">利用视图简化复杂的联结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E8%A7%86%E5%9B%BE%E9%87%8D%E6%96%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A3%80%E7%B4%A2%E5%87%BA%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">25.2.2.</span> <span class="nav-text">用视图重新格式化检索出的数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E8%A7%86%E5%9B%BE%E8%BF%87%E6%BB%A4%E4%B8%8D%E6%83%B3%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">25.2.3.</span> <span class="nav-text">用视图过滤不想要的数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE%E4%B8%8E%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5"><span class="nav-number">25.2.4.</span> <span class="nav-text">使用视图与计算字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E8%A7%86%E5%9B%BE"><span class="nav-number">25.2.5.</span> <span class="nav-text">更新视图</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%8F%98%E9%87%8F%E5%92%8CSET%E8%AF%AD%E5%8F%A5"><span class="nav-number">26.</span> <span class="nav-text">用户变量和SET语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="nav-number">26.1.</span> <span class="nav-text">用户变量定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">26.2.</span> <span class="nav-text">用户变量的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SET-%E8%AF%AD%E5%8F%A5"><span class="nav-number">26.2.1.</span> <span class="nav-text">SET 语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SELECT-%E8%AF%AD%E5%8F%A5"><span class="nav-number">26.2.2.</span> <span class="nav-text">SELECT 语句</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%8F%98%E9%87%8F%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">26.3.</span> <span class="nav-text">用户变量注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC23%E7%AB%A0-%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">27.</span> <span class="nav-text">第23章 使用存储过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">27.1.</span> <span class="nav-text">存储过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">27.2.</span> <span class="nav-text">为什么要使用存储过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">27.3.</span> <span class="nav-text">使用存储过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">27.3.1.</span> <span class="nav-text">执行存储过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">27.3.2.</span> <span class="nav-text">创建存储过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">27.3.3.</span> <span class="nav-text">删除存储过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0"><span class="nav-number">27.3.4.</span> <span class="nav-text">使用参数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BE%8B1"><span class="nav-number">27.3.4.1.</span> <span class="nav-text">例1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BE%8B2"><span class="nav-number">27.3.4.2.</span> <span class="nav-text">例2</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E6%99%BA%E8%83%BD%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">27.3.5.</span> <span class="nav-text">建立智能存储过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">27.3.6.</span> <span class="nav-text">检查存储过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#information-schema-%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">28.</span> <span class="nav-text">information_schema 数据库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC24%E7%AB%A0-%E4%BD%BF%E7%94%A8%E6%B8%B8%E6%A0%87"><span class="nav-number">29.</span> <span class="nav-text">第24章 使用游标</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%B8%E6%A0%87"><span class="nav-number">29.1.</span> <span class="nav-text">游标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%B8%B8%E6%A0%87"><span class="nav-number">29.2.</span> <span class="nav-text">使用游标</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%B8%B8%E6%A0%87"><span class="nav-number">29.2.1.</span> <span class="nav-text">创建游标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%93%E5%BC%80%E5%92%8C%E5%85%B3%E9%97%AD%E6%B8%B8%E6%A0%87"><span class="nav-number">29.2.2.</span> <span class="nav-text">打开和关闭游标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%B8%B8%E6%A0%87%E6%95%B0%E6%8D%AE"><span class="nav-number">29.2.3.</span> <span class="nav-text">使用游标数据</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC25%E7%AB%A0-%E4%BD%BF%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-number">30.</span> <span class="nav-text">第25章 使用触发器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-number">30.1.</span> <span class="nav-text">触发器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-number">30.2.</span> <span class="nav-text">创建触发器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-number">30.3.</span> <span class="nav-text">删除触发器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-number">30.4.</span> <span class="nav-text">使用触发器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#INSERT%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-number">30.4.1.</span> <span class="nav-text">INSERT触发器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DELETE%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-number">30.4.2.</span> <span class="nav-text">DELETE触发器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UPDATE%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-number">30.4.3.</span> <span class="nav-text">UPDATE触发器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E8%A7%A6%E5%8F%91%E5%99%A8%E7%9A%84%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BB%8B%E7%BB%8D"><span class="nav-number">30.4.4.</span> <span class="nav-text">关于触发器的进一步介绍</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC26%E7%AB%A0-%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86"><span class="nav-number">31.</span> <span class="nav-text">第26章 管理事务处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC27%E7%AB%A0-%E5%85%A8%E7%90%83%E5%8C%96%E5%92%8C%E6%9C%AC%E5%9C%B0%E5%8C%96"><span class="nav-number">32.</span> <span class="nav-text">第27章 全球化和本地化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC28%E7%AB%A0-%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86"><span class="nav-number">33.</span> <span class="nav-text">第28章 安全管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC29%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%B4%E6%8A%A4"><span class="nav-number">34.</span> <span class="nav-text">第29章 数据库维护</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC30%E7%AB%A0-%E6%94%B9%E5%96%84%E6%80%A7%E8%83%BD"><span class="nav-number">35.</span> <span class="nav-text">第30章 改善性能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87"><span class="nav-number">35.1.</span> <span class="nav-text">SQL如何提高查询效率</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%8F%82%E6%95%B0%E6%98%AF%E5%AD%90%E6%9F%A5%E8%AF%A2-14%E7%AB%A0-%E6%97%B6%EF%BC%8C%E4%BD%BF%E7%94%A8-EXISTS-%E8%BF%98%E6%98%AF-IN"><span class="nav-number">35.1.1.</span> <span class="nav-text">1. 参数是子查询(14章)时，使用 EXISTS 还是 IN</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E9%81%BF%E5%85%8D%E6%8E%92%E5%BA%8F"><span class="nav-number">35.1.2.</span> <span class="nav-text">2. 避免排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8UNION-ALL%E4%BB%A3%E6%9B%BFUNION"><span class="nav-number">35.1.2.1.</span> <span class="nav-text">使用UNION ALL代替UNION</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8EXISTS%E4%BB%A3%E6%9B%BFDISTINCT"><span class="nav-number">35.1.2.2.</span> <span class="nav-text">使用EXISTS代替DISTINCT</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E6%9E%81%E5%80%BC%E5%87%BD%E6%95%B0-MAX-MIN-%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="nav-number">35.1.2.3.</span> <span class="nav-text">在极值函数(MAX&#x2F;MIN)中使用索引</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%83%BD%E5%86%99%E5%9C%A8WHERE%E5%AD%90%E5%8F%A5%E9%87%8C%E7%9A%84%E6%9D%A1%E4%BB%B6%E4%B8%8D%E8%A6%81%E5%86%99%E5%9C%A8HAVING%E5%AD%90%E5%8F%A5%E9%87%8C"><span class="nav-number">35.1.2.4.</span> <span class="nav-text">能写在WHERE子句里的条件不要写在HAVING子句里</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E7%9C%9F%E6%AD%A3%E6%8A%8A%E7%B4%A2%E5%BC%95%E5%88%A9%E7%94%A8%E8%B5%B7%E6%9D%A5"><span class="nav-number">35.1.3.</span> <span class="nav-text">3. 真正把索引利用起来</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%8F%E5%B0%91%E4%B8%AD%E9%97%B4%E8%A1%A8"><span class="nav-number">35.1.4.</span> <span class="nav-text">减少中间表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%84%E5%BD%95C-MySQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="nav-number">36.</span> <span class="nav-text">附录C MySQL语句的语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%84%E5%BD%95D-MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">37.</span> <span class="nav-text">附录D MySQL数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">37.1.</span> <span class="nav-text">字符串数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">37.2.</span> <span class="nav-text">数值数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">37.3.</span> <span class="nav-text">日期和时间数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">37.4.</span> <span class="nav-text">二进制数据类型</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hunter</p>
  <div class="site-description" itemprop="description">Tough times never last, but tough people do.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">98</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">175</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hunter1023.github.io/2020/06/14/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hunter">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talk is cheap">
      <meta itemprop="description" content="Tough times never last, but tough people do.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="MySQL必知必会 | Talk is cheap">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL必知必会<a href="https://github.com/Hunter1023/hexo_blog/edit/gh-pages/source/_posts/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pen-nib"></i></a>
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-14 08:26:30" itemprop="dateCreated datePublished" datetime="2020-06-14T08:26:30+08:00">2020-06-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-23 23:29:13" itemprop="dateModified" datetime="2025-01-23T23:29:13+08:00">2025-01-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="第1章-了解SQL"><a href="#第1章-了解SQL" class="headerlink" title="第1章 了解SQL"></a>第1章 了解SQL</h2><ul>
<li>数据库软件应称为DBMS（数据库管理系统）。</li>
<li>数据库是通过DBMS创建和操纵的容器。</li>
<li>在很大程度上说，数据库究竟是文件还是别的什么东西并不重要，因为你并不直接访问数据库；你使用的是DBMS，它替你访问数据库。</li>
<li>模式（schema）： 关于<strong>数据库</strong>和<strong>表</strong>的<strong>布局及特性</strong>的信息。</li>
<li>有时，模式用作数据库的同义词。遗憾的是，模式的含义通常在上下文中并不是很清晰。</li>
<li>主键（primary key）</li>
<li>SQL（发音为字母S-Q-L或sequel）是**结构化查询语言（Structured Query Language）**的缩写。</li>
</ul>
<span id="more"></span>

<h2 id="第2章-MySQL简介"><a href="#第2章-MySQL简介" class="headerlink" title="第2章 MySQL简介"></a>第2章 MySQL简介</h2><ul>
<li>DBMS可分为两类：一类为<strong>基于共享文件系统</strong>的DBMS，另一类为<strong>基于客户机——服务器</strong>的DBMS。前者（包括诸如<strong>Microsoft Access</strong>和<strong>FileMaker</strong>）用于<strong>桌面用途</strong>，通常不用于高端或更关键的应用。</li>
<li>MySQL、Oracle以及Microsoft SQL Server等数据库是基于客户机——服务器的数据库。客户机—服务器应用分为两个不同的部分。<strong>服务器</strong>部分是负责<strong>所有数据访问和处理</strong>的一个软件。</li>
<li>为进行所有数据库交互，客户机软件都要与服务器软件进行通信。</li>
<li>每个MySQL安装都有一个名为mysql的简单命令行实用程序。</li>
</ul>
<hr>
<h3 id="配置MySQL环境变量"><a href="#配置MySQL环境变量" class="headerlink" title="配置MySQL环境变量"></a>配置MySQL环境变量</h3><ul>
<li><code>Win</code> + <code>Pause Break</code> 打开<strong>系统</strong>窗口。</li>
<li>高级系统设置 - 高级 - 环境变量 - 系统变量</li>
<li>找到<strong>Path</strong>，点击<strong>编辑</strong> - 浏览</li>
<li>选择MySQL安装目录下的bin文件夹所在路径，默认路径为<code>C:\Program Files\MySQL\MySQL Server 5.7\bin</code></li>
<li>一路确定，即完成环境变量的配置。此时打开命令行窗口，即通过<code>mysql -u root -p</code>命令并输入密码后访问数据库。</li>
</ul>
<hr>
<h3 id="统一字符集为UTF-8"><a href="#统一字符集为UTF-8" class="headerlink" title="统一字符集为UTF-8"></a>统一字符集为UTF-8</h3><p>为了中文字符的顺利存储，需要将数据库的字符集统一为UTF-8。</p>
<p>修改<code>C:\ProgramData\MySQL\MySQL Server 5.7\my.ini</code>：</p>
<ul>
<li><p>找到<code>[mysql]</code></p>
<p>在下方添加<code>default-character-set=utf8</code></p>
</li>
<li><p>找到<code>[mysqld]</code></p>
<p>在下方添加<code>character-set-server=utf8</code></p>
</li>
<li><p>找到<code>[client]</code></p>
<p>在下方添加<code>default-character-set=utf8</code></p>
</li>
</ul>
<hr>
<ul>
<li>在操作系统命令提示符下输入mysql将出现一个如下的简单提示：<ul>
<li>为了指定<strong>用户登录名</strong>ben，应该使用<code>mysql -u ben</code>。为了给出<strong>用户名</strong>、<strong>主机名</strong>、<strong>端口</strong>和<strong>口令</strong>，应该使用<code>mysql -u ben -p -h myserver -P 9999</code>。<strong>完整的命令行选项和参数列表</strong>可用<code>mysql --help</code>获得。</li>
</ul>
</li>
<li>命令用<code>；</code>或<code>\g</code><strong>结束</strong>，换句话说，<strong>仅按Enter不执行命令</strong>；</li>
<li>输入<code>quit</code>或<code>exit</code><strong>退出命令行实用程序</strong>。</li>
</ul>
<h2 id="第3章-使用MySQL"><a href="#第3章-使用MySQL" class="headerlink" title="第3章 使用MySQL"></a>第3章 使用MySQL</h2><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><ul>
<li>在最初安装MySQL时，很可能会要求你输入一个管理登录（通常为root）和一个口令。如果你使用的是自己的本地服务器，并且是简单地试验一下MySQL，使用上述登录就可以了。但现实中，管理登录受到密切保护。</li>
<li>为了连接到MySQL，需要以下信息：<ol>
<li>主机名（计算机名）——如果连接到本地MySQL服务器，为localhost</li>
<li>端口（如果使用默认端口3306之外的端口）</li>
<li>一个合法的用户名</li>
<li>用户口令（如果需要）</li>
</ol>
</li>
</ul>
<hr>
<h3 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h3><ul>
<li>在你最初连接到MySQL时，没有任何数据库打开供你使用。<strong>在你能执行任意数据库操作前，需要选择一个数据库</strong>。为此，可使用<strong>USE关键字</strong>。</li>
<li>关键字是一些用于执行MySQL操作的特殊词汇，决不要用<strong>关键字</strong>命名一个表或列。</li>
<li><strong>USE语句</strong>并不返回任何结果。依赖于使用的客户机，显示某种形式的通知。</li>
<li>在MySQL Query Browser中，双击Schemata列表中列出的任一数据库以使用它。你看不到USE命令的实际执行，但会看到被选择的数据库（黑体加亮），而且应用标题栏将显示所选择的数据库名。必须先使用USE打开数据库，才能读取其中的数据。</li>
</ul>
<hr>
<h3 id="了解数据库和表"><a href="#了解数据库和表" class="headerlink" title="了解数据库和表"></a>了解数据库和表</h3><ul>
<li><p><strong>数据库、表、列、用户、权限等信息</strong>被存储在数据库和表中（MySQL使用MySQL来存储这些信息）。不过，<strong>内部的表一般不直接访问</strong>。</p>
</li>
<li><p>可用MySQL的<strong>SHOW命令</strong>来显示这些信息（MySQL从内部表中提取这些信息）</p>
<ul>
<li><p><code>SHOW DATABASES;</code></p>
<p>返回<strong>可用数据库</strong>的一个列表。包含在这个列表中的可能是MySQL内部使用的数据库</p>
</li>
<li><p><code>SHOW TABLES;</code></p>
<p>获得<strong>当前选择的数据库内可用表</strong></p>
</li>
<li><p><code>SHOW COLUMNS FROM table_name;</code>&#x2F;<code>DESCRIBE table_name;</code></p>
<p>要求给出一个表名，<strong>显示对应的所有表列及其具体属性</strong></p>
<p><code>DESCRIBE customers;</code>是<code>SHOW COLUMNS FROM customers;</code>的一种<strong>快捷方式</strong>。</p>
</li>
<li><p><code>SHOW STATUS;</code></p>
<p>用于显示广泛的<strong>服务器状态</strong>信息</p>
</li>
<li><p><code>SHOW CREATE DATABASE database_name;</code>和<code>SHOW CREATE TABLE table_name;</code></p>
<p>分别用来显示<strong>创建特定数据库或表的MySQL语句</strong>。</p>
</li>
<li><p><code>SHOW GRANTS;</code></p>
<p>用来<strong>显示授予用户（所有用户或特定用户）的安全权限</strong>；</p>
</li>
<li><p><code>SHOW ERRORS;</code>和<code>SHOW WARNINGS;</code></p>
<p>用来<strong>显示服务器错误</strong>或<strong>警告消息</strong>。 </p>
</li>
<li><p><code>SHOW PROCESSLIST;</code></p>
<p>  显示<strong>所有活动进程</strong>(以及它们的线程ID和执行时间)</p>
</li>
</ul>
</li>
<li><p><strong>自动增量(aotu_increment)</strong>：</p>
<p>在<strong>每个行添加到表中</strong>时，MySQL可以<strong>自动地为每个行分配下一个可用编号</strong>，<strong>不用在添加一行时手动分配唯一值</strong>。如果需要它，则必须在<strong>用CREATE语句创建表时</strong>把它作为<strong>表定义的组成部分</strong>。</p>
</li>
</ul>
<blockquote>
<p>MySQL 5支持一个新的INFORMA-TION_SCHEMA命令，可用它来获得和过滤模式信息。</p>
</blockquote>
<h2 id="第4章-检索数据"><a href="#第4章-检索数据" class="headerlink" title="第4章 检索数据"></a>第4章 检索数据</h2><h3 id="检索单个列"><a href="#检索单个列" class="headerlink" title="检索单个列"></a>检索单个列</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> column_name
<span class="token keyword">FROM</span> table_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>所需的列名在SELECT关键字之后给出，FROM关键字指出从其中检索数据的表名。</p>
<ul>
<li><p>如果<strong>没有明确排序查询结果</strong>，则返回的数据的<strong>顺序没有特殊意义</strong>。返回数据的顺序可能是数据被添加到表中的顺序，也可能不是。<strong>只要返回相同数目的行，就是正常的</strong>。 </p>
</li>
<li><p><strong>多条</strong>SQL语句<strong>必须以分号（;）分隔</strong>。MySQL如同多数DBMS一样，不需要在单条SQL语句后加分号，但即使不一定需要，但加上分号肯定没有坏处。如果你使用的是<strong>mysql命令行，必须加上分号来结束SQL语句</strong>。</p>
</li>
<li><p>SQL语句<strong>不区分大小写</strong></p>
</li>
<li><p>许多SQL开发人员喜欢<strong>对所有SQL关键字使用大写</strong>，而<strong>对所有列和表名使用小写</strong>，这样做使代码更<strong>易于阅读和调试</strong>。</p>
</li>
</ul>
<hr>
<h3 id="检索多个列"><a href="#检索多个列" class="headerlink" title="检索多个列"></a>检索多个列</h3><p>SQL语句一般<strong>返回原始的、无格式的数据</strong>。数据的格式化是一个表示问题，而不是一个检索问题。</p>
<hr>
<h3 id="检索所有列"><a href="#检索所有列" class="headerlink" title="检索所有列"></a>检索所有列</h3><p>这可以通过<strong>在实际列名的位置使用星号（*）通配符</strong>来达到。</p>
<ul>
<li>虽然使用通配符可能会使你自己省事，不用明确列出所需列，但<strong>检索不需要的列通常会降低检索和应用程序的性能</strong>。</li>
</ul>
<hr>
<h3 id="检索不同的行"><a href="#检索不同的行" class="headerlink" title="检索不同的行"></a>检索不同的行</h3><p>使用DISTINCT关键字，顾名思义，此关键字指示MySQL只返回不同的值。</p>
<ul>
<li><p><strong>不能部分使用DISTINCT</strong>：</p>
<p>  DISTINCT关键字<strong>应用于所有列</strong>而不仅是前置它的列</p>
</li>
</ul>
<hr>
<h3 id="限制结果"><a href="#限制结果" class="headerlink" title="限制结果"></a>限制结果</h3><p>为了返回第一行或前几行，可使用LIMIT子句：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> prod_name
<span class="token keyword">FROM</span> products
<span class="token keyword">LIMIT</span> <span class="token number">5</span> <span class="token keyword">OFFSET</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">-- 从第4行开始，取5行；等价于 LIMIT 4, 5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>MySQL检索出来的<strong>第一行</strong>是行<strong>0</strong>而不是行1。</p>
<p><strong>Sql Server不支持LIMIT语句</strong>，通过<strong>TOP</strong>实现结果的限制：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">TOP</span> <span class="token number">5</span> prod_name
<span class="token keyword">FROM</span> products
<span class="token keyword">WHERE</span> prod_name <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token keyword">TOP</span> <span class="token number">3</span> prod_name
                        <span class="token keyword">FROM</span> peoducts<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h2 id="第5章-排序检索数据"><a href="#第5章-排序检索数据" class="headerlink" title="第5章 排序检索数据"></a>第5章 排序检索数据</h2><h3 id="排序数据"><a href="#排序数据" class="headerlink" title="排序数据"></a>排序数据</h3><ul>
<li>关系数据库设计理论认为，如果不明确规定排序顺序，则不应该假定检索出的数据的顺序有意义</li>
<li>为了明确地<strong>排序</strong>用SELECT语句检索出的数据，可使用<strong>ORDER BY</strong>子句</li>
<li>取一个或多个列的名字，据此对输出进行排序，也可以<strong>通过非选择列进行排序</strong></li>
</ul>
<hr>
<h3 id="按多个列排序"><a href="#按多个列排序" class="headerlink" title="按多个列排序"></a>按多个列排序</h3><ul>
<li>在按多个列排序时，排序完全按所规定的顺序进行</li>
</ul>
<hr>
<h3 id="指定排序方向"><a href="#指定排序方向" class="headerlink" title="指定排序方向"></a>指定排序方向</h3><ul>
<li><strong>默认</strong>的排序顺序：<strong>升序</strong>排序（从A到Z）。为了进行<strong>降序</strong>排序，必须指定<strong>DESC</strong>关键字。</li>
<li><strong>DESC</strong>关键字<strong>只应用到直接位于其前面</strong>的列名（<strong>和DISTINCT关键字不同</strong>）</li>
<li>如果想在多个列上进行降序排序，<strong>必须对每个列指定DESC关键字</strong>。</li>
<li>在字典（dictionary）排序顺序中，<strong>A被视为与a相同</strong>，这是<strong>MySQL</strong>（和大多数DBMS）的<strong>默认</strong>行为。但是，许多数据库管理员能够在需要时改变这种行为（如果你的数据库包含大量外语字符，可能必须这样做）。这里，关键的问题是，如果确实需要改变这种排序顺序，用简单的ORDER BY子句做不到。你必须请求数据库管理员的帮助。</li>
<li>如果使用<strong>LIMIT</strong>，它<strong>必须位于ORDER BY之后</strong>。使用子句的次序不对将产生错误消息。</li>
</ul>
<hr>
<h2 id="第6章-过滤数据"><a href="#第6章-过滤数据" class="headerlink" title="第6章 过滤数据"></a>第6章 过滤数据</h2><h3 id="使用WHERE子句"><a href="#使用WHERE子句" class="headerlink" title="使用WHERE子句"></a>使用WHERE子句</h3><ul>
<li><p>只检索所需数据<strong>需要指定搜索条件（search criteria），搜索条件也称为过滤条件（filter condition）</strong>。在SELECT语句中，数据根据WHERE子句中指定的搜索条件进行过滤。<strong>WHERE子句在表名（FROM子句）之后给出</strong>。</p>
</li>
<li><p>应该让ORDER BY位于WHERE之后，否则将会产生错误</p>
</li>
</ul>
<hr>
<h3 id="WHERE子句操作符"><a href="#WHERE子句操作符" class="headerlink" title="WHERE子句操作符"></a>WHERE子句操作符</h3><ul>
<li><p>MySQL支持下列所有条件操作符：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>=</code></td>
<td>等于</td>
</tr>
<tr>
<td><code>&lt;&gt;</code>&#x2F;<code>!=</code></td>
<td><strong>不等于</strong></td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于等于</td>
</tr>
<tr>
<td><code>BETWEEN</code></td>
<td><strong>在指定的两个值之间</strong></td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="检查单个值"><a href="#检查单个值" class="headerlink" title="检查单个值"></a>检查单个值</h4><ul>
<li>MySQL在<strong>执行匹配时</strong>默认<strong>不区分大小写</strong></li>
</ul>
<hr>
<h4 id="不匹配检查"><a href="#不匹配检查" class="headerlink" title="不匹配检查"></a>不匹配检查</h4><p>以下例子列出不是由供应商1003制造的所有产品：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> vend_id<span class="token punctuation">,</span> prod_name
<span class="token keyword">FROM</span> products
<span class="token keyword">WHERE</span> vend_id <span class="token operator">!=</span> <span class="token number">1003</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>什么时候使用引号：</p>
<p><strong>单</strong>引号用于<strong>限定字符串</strong>(<strong>包括日期类型</strong>)，用来<strong>与数值列进行比较的值不用引号</strong>。</p>
<p>** <strong>用来</strong>限定字符串**。(Python既可以用单引号，也可以用双引号)</p>
<hr>
<h4 id="范围值检查"><a href="#范围值检查" class="headerlink" title="范围值检查"></a>范围值检查</h4><ul>
<li>在使用<code>BETWEEN</code>时，必须<strong>指定两个值</strong>——所需范围的低端值和高端值。<strong>这两个值必须用AND关键字分隔</strong>。BETWEEN匹配范围中所有的值，<strong>包括指定的开始值</strong>和<strong>结束值</strong>。</li>
</ul>
<hr>
<h4 id="空值检查"><a href="#空值检查" class="headerlink" title="空值检查"></a>空值检查</h4><ul>
<li><p>SELECT语句有一个特殊的WHERE子句，可用来<strong>检查具有NULL值的列</strong>。这个WHERE子句就是<strong>IS NULL子句</strong></p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> prod_name
<span class="token keyword">FROM</span> products
<span class="token keyword">WHERE</span> prod_price <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>在通过过滤选择出不具有特定值的行时，<strong>你可能希望返回具有NULL值的行，但是，不行</strong>。因为未知具有特殊的含义，数据库不知道它们是否匹配，所以在匹配过滤或不匹配过滤时不返回它们。</p>
</li>
</ul>
<hr>
<h2 id="第7章-数据过滤"><a href="#第7章-数据过滤" class="headerlink" title="第7章 数据过滤"></a>第7章 数据过滤</h2><h3 id="组合WHERE子句"><a href="#组合WHERE子句" class="headerlink" title="组合WHERE子句"></a>组合WHERE子句</h3><ul>
<li>MySQL允许给出多个WHERE子句。这些子句可以两种方式使用：以<strong>AND子句</strong>的方式或<strong>OR子句</strong>的方式使用。</li>
</ul>
<h4 id="计算次序"><a href="#计算次序" class="headerlink" title="计算次序"></a>计算次序</h4><ul>
<li><p>SQL（像多数语言一样）<strong>在处理OR操作符前，优先处理AND操作符</strong>，为了使机器能够理解，应<strong>使用圆括号明确地分组相应的操作符</strong>。如：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SLECT prod_name<span class="token punctuation">,</span> prod_price
<span class="token keyword">FROM</span> products
<span class="token keyword">WHERE</span> <span class="token punctuation">(</span>vend_id <span class="token operator">=</span> <span class="token number">1002</span> <span class="token operator">OR</span> vend_id <span class="token operator">=</span> <span class="token number">1003</span><span class="token punctuation">)</span> <span class="token operator">AND</span> prod_price <span class="token operator">>=</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>任何时候</strong>使用具有<strong>AND</strong>和<strong>OR</strong>操作符的WHERE子句，<strong>都应该使用圆括号明确地分组操作符</strong>，消除歧义。</p>
</li>
</ul>
<hr>
<h3 id="IN操作符"><a href="#IN操作符" class="headerlink" title="IN操作符"></a>IN操作符</h3><ul>
<li><p>IN操作符后跟<strong>由逗号分隔</strong>的<strong>合法值清单</strong>，<strong>整个清单必须括在圆括号中</strong>。<strong>IN操作符完成与OR相同的功能</strong>。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> prod_name<span class="token punctuation">,</span> prod_price
<span class="token keyword">FROM</span> products
<span class="token keyword">WHERE</span> vend_id <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">1002</span><span class="token punctuation">,</span> <span class="token number">1003</span><span class="token punctuation">)</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> prod_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>为什么要使用IN操作符？其优点具体如下。</p>
<ol>
<li>在使用<strong>长的合法选项清单</strong>时，IN操作符的<strong>语法更清楚且更直观</strong>。</li>
<li>在使用IN时，<strong>计算的次序更容易管理</strong>（因为<strong>使用的操作符更少</strong>）。</li>
<li>IN操作符<strong>一般比OR操作符清单执行更快</strong>。</li>
<li>IN的最大优点是<strong>可以包含其他SELECT语句</strong>，使得<strong>能够更动态地建立WHERE子句</strong>。第14章将对此进行详细介绍。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="NOT操作符"><a href="#NOT操作符" class="headerlink" title="NOT操作符"></a>NOT操作符</h3><ul>
<li><p>NOT操作符有且只有一个功能，那就是<strong>否定它之后所跟的任何条件</strong>。如：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> prod_name<span class="token punctuation">,</span> prod_price
<span class="token keyword">FROM</span> products
<span class="token keyword">WHERE</span> vend_id <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">1002</span><span class="token punctuation">,</span> <span class="token number">1003</span><span class="token punctuation">)</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> prod_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>对于简单的WHERE子句，使用NOT确实没有什么优势。但在更复杂的子句中，NOT是非常有用的。例如，<strong>在与IN操作符联合使用时，NOT使找出与条件列表不匹配的行非常简单</strong>。</p>
</li>
<li><p>MySQL支持使用NOT<strong>对IN、BETWEEN和EXISTS子句取反</strong>，这与多数其他DBMS<strong>允许使用NOT对各种条件取反</strong>有很大的差别。</p>
</li>
</ul>
<hr>
<h2 id="第8章-用通配符进行过滤"><a href="#第8章-用通配符进行过滤" class="headerlink" title="第8章 用通配符进行过滤"></a>第8章 用通配符进行过滤</h2><h3 id="LIKE操作符"><a href="#LIKE操作符" class="headerlink" title="LIKE操作符"></a>LIKE操作符</h3><ul>
<li><p>怎样搜索<strong>产品名中包含文本anvil</strong>的所有产品？用简单的比较操作符肯定不行，<strong>必须使用通配符</strong>。利用通配符可创建比较特定数据的搜索模式</p>
</li>
<li><p><strong>搜索模式</strong>（<strong>search pattern</strong>）：</p>
<p>由<strong>字面值</strong>、<strong>通配符</strong>或<strong>两者组合构成的搜索条件</strong></p>
</li>
<li><p>通配符本身实际是SQL的WHERE子句中<strong>有特殊含义的字符</strong>，SQL支持几种通配符：</p>
<ul>
<li><code>%</code></li>
<li><code>_</code></li>
</ul>
</li>
<li><p><strong>为在搜索子句中使用通配符，必须使用LIKE操作符</strong>。LIKE指示MySQL，后跟的搜索模式利用通配符匹配而不是直接相等匹配进行比较。</p>
</li>
<li><p>操作符何时不是操作符？答案是在它作为谓词（<strong>predi-cate</strong>）时。<strong>从技术上说，LIKE是谓词而不是操作符</strong>。虽然最终的结果是相同的，但应该对此术语有所了解，以免在SQL文档中遇到此术语时不知道。</p>
</li>
</ul>
<h4 id="百分号-通配符"><a href="#百分号-通配符" class="headerlink" title="百分号(%)通配符"></a>百分号(%)通配符</h4><ul>
<li><p>最常使用的通配符是百分号（%）。在搜索串中，<strong>%表示任何字符出现任意次数</strong>。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> prod_id<span class="token punctuation">,</span> prod_name
<span class="token keyword">FROM</span> products
<span class="token keyword">WHERE</span> prod_name <span class="token operator">LIKE</span> <span class="token string">'jet%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>运行结果：</p>
<table>
<thead>
<tr>
<th>prod_id</th>
<th>prod_name</th>
</tr>
</thead>
<tbody><tr>
<td>JP1000</td>
<td>JetPack 1000</td>
</tr>
<tr>
<td>JP2000</td>
<td>JetPack 2000</td>
</tr>
</tbody></table>
</li>
<li><p>根据MySQL的配置方式，<strong>搜索可以是区分大小写的</strong>。如果区分大小写，<code>&#39;jet%&#39;</code>与JetPack 1000将不匹配。</p>
</li>
<li><p>通配符<strong>可以在搜索模式中任意位置使用</strong>，并且<strong>可以使用多个通配符</strong>。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> prod_id<span class="token punctuation">,</span> prod_name
<span class="token keyword">FROM</span> products
<span class="token keyword">WHERE</span> prod_name <span class="token operator">LIKE</span> <span class="token string">'%anvil%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>运行结果：</p>
<table>
<thead>
<tr>
<th>prod_id</th>
<th>prod_name</th>
</tr>
</thead>
<tbody><tr>
<td>ANV01</td>
<td>.5 ton anvil</td>
</tr>
<tr>
<td>ANV02</td>
<td>1 ton anvil</td>
</tr>
<tr>
<td>ANV03</td>
<td>2 ton anvil</td>
</tr>
</tbody></table>
</li>
<li><p>重要的是要注意到，<strong>除了一个或多个字符外，%还能匹配0个字符</strong>。<strong>%代表搜索模式中给定位置的0个、1个或多个字符</strong>。</p>
</li>
<li><p>注意<strong>尾空格</strong>：</p>
<p>尾空格可能会<strong>干扰通配符匹配</strong>。例如，在保存词anvil时，如果它后面有一个或多个空格，则子句WHERE prod_name LIKE ‘%anvil’将不会匹配它们，因为在最后的l后有多余的字符。<strong>解决这个问题的一个简单的办法是在搜索模式最后附加一个%</strong>。一个<strong>更好的办法是使用函数</strong>（第11章将会介绍）<strong>去掉首尾空格</strong>。</p>
</li>
<li><p>虽然<strong>似乎%通配符可以匹配任何东西</strong>，但有一个例外，即<strong>NULL</strong>。<strong>即使是WHERE prod_name LIKE ‘%’也不能匹配用值NULL作为产品名的行</strong>。</p>
</li>
</ul>
<hr>
<h4 id="下划线-通配符"><a href="#下划线-通配符" class="headerlink" title="下划线(_)通配符"></a>下划线(_)通配符</h4><ul>
<li>下划线的<strong>用途与%一样</strong>，但下划线<strong>只匹配单个字符</strong>。</li>
</ul>
<hr>
<h3 id="使用通配符的技巧"><a href="#使用通配符的技巧" class="headerlink" title="使用通配符的技巧"></a>使用通配符的技巧</h3><ol>
<li>不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。</li>
<li>在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处。<strong>把通配符置于搜索模式的开始处，搜索起来是最慢的(会使索引失效)</strong>。</li>
</ol>
<hr>
<h2 id="第9章-用正则表达式进行搜索"><a href="#第9章-用正则表达式进行搜索" class="headerlink" title="第9章 用正则表达式进行搜索"></a>第9章 用正则表达式进行搜索</h2><h3 id="正则表达式介绍"><a href="#正则表达式介绍" class="headerlink" title="正则表达式介绍"></a>正则表达式介绍</h3><p>正则表达式(<strong>Reg</strong>ular <strong>Exp</strong>ression)是用来<strong>匹配文本</strong>的特殊的串（字符集合）。</p>
<p><strong>所有种类</strong>的程序设计语言、文本编辑器、操作系统等<strong>都支持正则表达式</strong>。</p>
<hr>
<h3 id="使用MySQL正则表达式"><a href="#使用MySQL正则表达式" class="headerlink" title="使用MySQL正则表达式"></a>使用MySQL正则表达式</h3><p>MySQL用<strong>WHERE子句对正则表达式提供了初步的支持</strong>，允许你指定正则表达式，过滤SELECT检索出的数据。</p>
<ul>
<li>MySQL<strong>仅支持</strong>多数正则表达式实现的<strong>一个很小的子集</strong></li>
</ul>
<h4 id="基本字符匹配"><a href="#基本字符匹配" class="headerlink" title="基本字符匹配"></a>基本字符匹配</h4><p><strong>例1：</strong></p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> prod_name
<span class="token keyword">FROM</span> products
<span class="token keyword">WHERE</span> prod_name <span class="token operator">REGEXP</span> <span class="token string">'1000'</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> prod_name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>除<strong>关键字LIKE被REGEXP替代</strong>外，这条语句看上去非常像使用LIKE的语句（第8章）。它告诉MySQL，<strong>REGEXP后所跟的东西作为正则表达式</strong>（与文字正文1000匹配的一个正则表达式）处理。</li>
</ul>
<p><strong>例2：</strong></p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> prod_name
<span class="token keyword">FROM</span> products
<span class="token keyword">WHERE</span> prod_name <span class="token operator">REGEXP</span> <span class="token string">'.000'</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> prod_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><code>.</code>是正则表达式语言中一个<strong>特殊的字符</strong>，它表示<strong>匹配任意一个字符</strong>。</li>
</ul>
<p><strong>LIKE 与 REGEXP 的重要区别</strong></p>
<p><strong>例：</strong></p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> prod_name
<span class="token keyword">FROM</span> products
<span class="token keyword">WHERE</span> prod_name <span class="token operator">LIKE</span> <span class="token string">'1000'</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> prod_name<span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> prod_name
<span class="token keyword">FROM</span> products
<span class="token keyword">WHERE</span> prod_name <span class="token operator">REGEXP</span> <span class="token string">'1000'</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> prod_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>LIKE匹配<strong>整个列</strong></p>
<p>  如果被匹配的文本在列值中出现，LIKE将不会找到它，相应的行也不被返回（除非使用通配符）</p>
</li>
<li><p>REGEXP<strong>在列值内进行匹配</strong></p>
<p>  如果被匹配的文本在列值中出现，REGEXP将会找到它，返回相应行。</p>
</li>
</ul>
<p>那么，<strong>REGEXP能不能用来匹配整个列值（从而起与LIKE相同的作用）</strong>？答案是肯定的，使用<code>^</code>和<code>$</code><strong>定位符</strong>（anchor）即可，本章后面介绍。</p>
<ul>
<li>MySQL中的正则表达式匹配（自版本3.23.4后）<strong>不区分大小写</strong>（即，大写和小写都匹配）。为<strong>区分大小写</strong>，可使用<strong>BINARY关键字</strong>，如<code>WHERE prod_name REGEXP BINARY &#39;JetPack .000&#39;</code>。</li>
</ul>
<hr>
<h4 id="进行OR匹配"><a href="#进行OR匹配" class="headerlink" title="进行OR匹配"></a>进行OR匹配</h4><p>为<strong>搜索两个串之一</strong>（或者为这个串，或者为另一个串），使用<code>|</code>。</p>
<ul>
<li><p><code>REGEXP &#39;1000|2000&#39;</code>。</p>
<p>  <code>|</code>为正则表达式的<strong>OR操作符</strong>，它表示<strong>匹配其中之一</strong>。</p>
</li>
<li><p><code>&#39;1000|2000|3000’</code>将匹配1000或2000或3000。</p>
</li>
</ul>
<hr>
<h4 id="匹配几个字符之一"><a href="#匹配几个字符之一" class="headerlink" title="匹配几个字符之一"></a>匹配几个字符之一</h4><p><code>.</code>用于匹配<strong>任一</strong>字符，如果你只想<strong>匹配特定的字符</strong>，怎么办？可通过<strong>指定一组用<code>[]</code>括起来的字符</strong>来完成:</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> prod_name
<span class="token keyword">FROM</span> products
<span class="token keyword">WHERE</span> prod_name <span class="token operator">REGEXP</span> <span class="token string">'[123] Ton'</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> prod_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p><code>[123]</code>定义一组字符，它的意思是<strong>匹配1或2或3</strong></p>
</li>
<li><p>正如所见，<code>[]</code>是另一种形式的OR语句。事实上，正则表达式<code>[123] Ton</code>为<code>[1|2|3] Ton</code>的<strong>缩写</strong>，也可以使用后者</p>
</li>
<li><p>字符集合也可以被否定，即，它们将匹配<strong>除指定字符外</strong>的任何东西。为<strong>否定一个字符集</strong>，在集合的开始处放置一个<code>^</code>即可。因此，尽管[123]匹配字符1、2或3，但<code>[^123]</code>却<strong>匹配除1、2、3字符外的任何东西</strong></p>
</li>
</ul>
<hr>
<h4 id="匹配范围"><a href="#匹配范围" class="headerlink" title="匹配范围"></a>匹配范围</h4><ul>
<li><p>集合可用来定义要匹配的一个或多个字符。集合<code>[0123456789]</code>将<strong>匹配数字0到9</strong>。为<strong>简化</strong>这种类型的集合，可使用<code>-</code>来定义一个范围：<code>[0-9]</code>功能上等同于上述数字列表。</p>
</li>
<li><p>范围不限于完整的集合，<code>[1-3]</code>和<code>[6-9]</code>也是合法的范围。此外，范围不一定只是数值的，<code>[a-z]</code>匹配任意字母字符。</p>
  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> prod_name
<span class="token keyword">FROM</span> products
<span class="token keyword">WHERE</span> prod_name <span class="token operator">REGEXP</span> <span class="token string">'[1-5] Ton'</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> prod_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<hr>
<h4 id="匹配特殊字符"><a href="#匹配特殊字符" class="headerlink" title="匹配特殊字符"></a>匹配特殊字符</h4><p>为了匹配特殊字符，必须用<code>\\</code>为前导。<code>\\-</code>表示查找<code>-</code>, <code>\\.</code>表示查找<code>.</code>。</p>
<p>这种处理就是所谓的<strong>转义（escaping）</strong>，<strong>正则表达式内具有特殊意义的所有字符都必须以这种方式转义</strong>。</p>
<p><strong>多数正则表达式实现</strong>使用<strong>单个反斜杠</strong>转义特殊字符，以便能使用这些字符本身。但<strong>MySQL要求两个反斜杠</strong>（MySQL自己解释一个，正则表达式库解释另一个）。</p>
<hr>
<h4 id="匹配字符类"><a href="#匹配字符类" class="headerlink" title="匹配字符类"></a>匹配字符类</h4><p>为更方便工作，可以使用<strong>预定义的字符集，称为字符类（character class）</strong>。下表列出字符类以及它们的含义：</p>
<table>
<thead>
<tr>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>[:alpha:]</code></td>
<td>任意<strong>字母</strong><br />(同<code>[a-zA-Z]</code>)</td>
</tr>
<tr>
<td><code>[:lower:]</code></td>
<td>任意<strong>小写</strong>字母</td>
</tr>
<tr>
<td><code>[:upper:]</code></td>
<td>任意<strong>大写</strong>字母</td>
</tr>
<tr>
<td><code>[:digit:]</code></td>
<td>任意<strong>数字</strong><br />(同<code>[0-9]</code>)</td>
</tr>
<tr>
<td><code>[:alnum:]</code></td>
<td>任意<strong>字母和数字</strong><br />(同<code>[a-zA-Z0-9]</code>)</td>
</tr>
<tr>
<td><code>[:blank:]</code></td>
<td><strong>空格和制表</strong><br />(同<code>[\\t]</code>)</td>
</tr>
<tr>
<td><code>[:cntrl:]</code></td>
<td>ASCⅡ控制字符(ASCⅡ 0到31以及127)</td>
</tr>
<tr>
<td><code>[:print:]</code></td>
<td>任意<strong>可打印字符</strong></td>
</tr>
<tr>
<td><code>[:graph:]</code></td>
<td>与<code>[:print:]</code>相同，但<strong>不包括空格</strong></td>
</tr>
<tr>
<td><code>[:space:]</code></td>
<td><strong>包括空格</strong>在内的任意<strong>空白字符</strong></td>
</tr>
<tr>
<td><code>[:punct:]</code></td>
<td>既不在<code>[:alnum:]</code>又不在<code>[:cntrl:]</code>中的任意字符</td>
</tr>
<tr>
<td><code>[:xdigit:]</code></td>
<td>任意<strong>十六进制数字</strong><br />(同<code>[a-fA-F0-9]</code>)</td>
</tr>
</tbody></table>
<hr>
<h4 id="匹配多个实例"><a href="#匹配多个实例" class="headerlink" title="匹配多个实例"></a>匹配多个实例</h4><p>你可能需要<strong>寻找所有的数</strong>，<strong>不管数中包含多少数字</strong>，或者你可能想<strong>寻找一个单词</strong>并且<strong>还能够适应一个尾随的s（如果存在）</strong>，等等。这可以用下表列出的<strong>正则表达式重复元字符</strong>来完成：</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>*</code></td>
<td><strong>0个</strong>或多个匹配</td>
</tr>
<tr>
<td><code>+</code></td>
<td><strong>1个</strong>或多个匹配<br />(等于<code>&#123;1,&#125;</code>)</td>
</tr>
<tr>
<td><code>?</code></td>
<td><strong>0个或1个</strong>匹配<br />(等于<code>&#123;0,1&#125;</code>)</td>
</tr>
<tr>
<td><code>&#123;n&#125;</code></td>
<td><strong>指定数目</strong>的匹配</td>
</tr>
<tr>
<td><code>&#123;n,&#125;</code></td>
<td><strong>不少于指定数目</strong>的匹配</td>
</tr>
<tr>
<td><code>&#123;n,m&#125;</code></td>
<td>匹配数目的范围<br />(m<strong>不超过255</strong>)</td>
</tr>
</tbody></table>
<ul>
<li><p>例1：</p>
  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> prod_name
<span class="token keyword">FROM</span> products
<span class="token keyword">WHERE</span> prod_name <span class="token operator">REGEXP</span> <span class="token string">'\\([0-9] sticks?\\)'</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> prod_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>  其中<code>?</code><strong>作用于之前的一个字符</strong>，即<code>s</code>，获取到两个prod_name：</p>
<ol>
<li><code>TNT (1 stick)</code></li>
<li><code>TNT (5 sticks)</code></li>
</ol>
</li>
<li><p>例2：</p>
  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> prod_name
<span class="token keyword">FROM</span> products
<span class="token keyword">WHERE</span> prod_name <span class="token operator">REGEXP</span> <span class="token string">'[[:digit:]&#123;4&#125;]'</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> prod_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>  匹配<strong>连在一起的4个</strong>数字，得到如下prod_name：</p>
<ol>
<li><code>JetPack 1000</code></li>
<li><code>JetPack 2000</code></li>
</ol>
<p>  需要注意的是，在使用正则表达式时，<strong>编写某个特殊的表达式几乎总是有不止一种方法</strong>，本例还可以这样编写：</p>
  <pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT prod_name
FROM products
WHERE prod_name REGEXP &#39;[0-9][0-9][0-9][0-9]&#39;
ORDER BY prod_name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<hr>
<h4 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h4><p>上述所有例子都是<strong>匹配一个串中任意位置</strong>的文本。为了<strong>匹配特定位置的文本</strong>，需要使用下表出的<strong>定位符</strong>：</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>^</code></td>
<td><strong>文本</strong>的开始</td>
</tr>
<tr>
<td><code>$</code></td>
<td><strong>文本</strong>的结尾</td>
</tr>
<tr>
<td><code>[[:&lt;:]]</code></td>
<td><strong>词</strong>的开始</td>
</tr>
<tr>
<td><code>[[:&gt;:]]</code></td>
<td><strong>词</strong>的结尾</td>
</tr>
</tbody></table>
<ul>
<li><p>例如，想找出<strong>以一个数(包括以小数点开始的数)开始</strong>的所有产品：</p>
  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> prod_name
<span class="token keyword">FROM</span> products
<span class="token keyword">WHERE</span> prod_name <span class="token operator">REGEXP</span> <span class="token string">'^[0-9\\.]'</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> prod_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>  <code>^</code>匹配<strong>串的开始</strong>。</p>
</li>
<li><p><code>^</code>的<strong>双重用途</strong></p>
<ol>
<li>在<strong>集合中</strong>（用<code>[]</code>定义），用它来<strong>否定该集合</strong>（如<code>[^123]</code>）</li>
<li>用来指串的开始处。</li>
</ol>
</li>
<li><p><strong>使REGEXP起类似LIKE的作用</strong></p>
<p>  <code>LIKE</code><strong>匹配整个串</strong>，而<code>REGEXP</code><strong>匹配子串</strong>。利用定位符，通过<strong>用<code>^</code>开始每个表达式，用<code>$</code>结束每个表达式</strong>，可以使REGEXP的作用与LIKE一样。</p>
</li>
<li><p><strong>简单的正则表达式测试</strong></p>
<p>  REGEXP检查总是返回<code>0</code>（<strong>没有匹配</strong>）或<code>1</code>（<strong>匹配</strong>）。可以<strong>用带文字串的REGEXP来测试表达式</strong>，并试验它们。相应的语法如下：</p>
<p>  <code>SELECT &#39;Hello&#39; REGEXP &#39;[0-9]&#39;</code>，这个例子显然返回0。</p>
</li>
</ul>
<hr>
<h2 id="第10章-创建计算字段"><a href="#第10章-创建计算字段" class="headerlink" title="第10章 创建计算字段"></a>第10章 创建计算字段</h2><h3 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a>计算字段</h3><p>计算字段的作用是<strong>将数据库中几列所需的数据进行连接，直接从数据库中检索出转换、计算或格式化过的数据；而不是检索出数据后，在客户端应用程序中重新格式化</strong>。一般来说，在数据库服务器上完成这些操作比在客户端中完成要快得多，因为DBMS是设计来快速有效地完成这种处理的。</p>
<p><strong>计算字段并不实际存在于数据库表中，是运行时在SELECT语句内创建的</strong>。</p>
<hr>
<h3 id="拼接字段"><a href="#拼接字段" class="headerlink" title="拼接字段"></a>拼接字段</h3><p><strong>拼接</strong>(<strong>concat</strong>enate)：将值联结到一起构成单个值，具体就是<strong>把两个列拼接起来</strong>。</p>
<p><strong>多数DBMS使用<code>+</code>或<code>||</code>来实现拼接，MySQL则使用<code>Concat()</code>函数来实现</strong>。当把SQL语句转换成MySQL语句时一定要把这个区别铭记在心。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> Concat<span class="token punctuation">(</span>vend_name<span class="token punctuation">,</span> <span class="token string">'('</span><span class="token punctuation">,</span> vend_country<span class="token punctuation">,</span> <span class="token string">')'</span><span class="token punctuation">)</span>
<span class="token keyword">FROM</span> vendors
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> vend_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ul>
<li><code>Concat()</code>需要一个或多个指定的串，各个串之间<strong>用逗号分隔</strong>。</li>
</ul>
<p>在第8章中曾提到通过<strong>删除数据右侧多余的空格</strong>来整理数据，这可以使用MySQL的<code>RTrim()</code>函数(第11章 文本处理函数)来完成：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> Concat<span class="token punctuation">(</span>RTrim<span class="token punctuation">(</span>vend_name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'('</span><span class="token punctuation">,</span> RTrim<span class="token punctuation">(</span>vend_country<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">')'</span><span class="token punctuation">)</span>
<span class="token keyword">FROM</span> vendors
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> vend_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<hr>
<h2 id="第11章-使用数据处理函数"><a href="#第11章-使用数据处理函数" class="headerlink" title="第11章 使用数据处理函数"></a>第11章 使用数据处理函数</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li><p>相对来说，多数<strong>SQL语句是可移植的</strong>，在SQL实现之间有差异时，这些差异通常不那么难处理。而<strong>函数的可移植性却不强</strong>。几乎每种主要的DBMS的实现都支持其他实现不支持的函数，而且有时差异还很大。</p>
</li>
<li><p>为了代码的可移植，许多SQL程序员不赞成使用特殊实现的功能。虽然这样做很有好处，但不总是利于应用程序的性能。</p>
</li>
<li><p>如果你决定使用函数，应该保证做好代码注释，以便以后你（或其他人）能确切地知道所编写SQL代码的含义。</p>
</li>
</ul>
<hr>
<h3 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h3><p>大多数SQL实现支持以下类型的函数。</p>
<ol>
<li>用于<strong>处理文本串</strong>（如<strong>删除或填充值</strong>，<strong>转换值为大写或小写</strong>）的<strong>文本处理函数</strong>。</li>
<li>用于在数值数据上进行算术操作（如<strong>返回绝对值</strong>，进行<strong>代数运算</strong>）的<strong>数值函数</strong>。</li>
<li>用于<strong>处理日期</strong>和<strong>时间值</strong>并从这些值中<strong>提取特定成分</strong>（例如，返回<strong>两个日期之差</strong>，<strong>检查日期有效性</strong>等）的<strong>日期和时间函数</strong>。</li>
<li>返回DBMS正使用的特殊信息（如返回<strong>用户登录信息</strong>，<strong>检查版本细节</strong>）的<strong>系统函数</strong>。</li>
</ol>
<hr>
<h4 id="转换数据类型函数"><a href="#转换数据类型函数" class="headerlink" title="转换数据类型函数"></a>转换数据类型函数</h4><p><code>CAST(expression AS data_type)</code></p>
<p>可以选择的类型(data_type)：</p>
<ul>
<li>二进制，同带binary前缀的效果 : BINARY   </li>
<li>字符型，可带参数 : CHAR()   </li>
<li>日期 : DATE   </li>
<li>时间: TIME   </li>
<li>日期时间型 : DATETIME   </li>
<li>浮点数 : DECIMAL    </li>
<li>整数 : SIGNED   </li>
<li>无符号整数 : UNSIGNED</li>
</ul>
<hr>
<h4 id="文本处理函数"><a href="#文本处理函数" class="headerlink" title="文本处理函数"></a>文本处理函数</h4><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>TRIM(s)</code></td>
<td>删除字符串首尾的空格</td>
</tr>
<tr>
<td><code>LTRIM(s)</code></td>
<td>删除字符串开头的空格</td>
</tr>
<tr>
<td><code>RTRIM(s)</code></td>
<td>删除字符串末尾的空格</td>
</tr>
<tr>
<td><code>UPPER(s)</code></td>
<td>将字符串转为大写</td>
</tr>
<tr>
<td><code>LOWER(s)</code></td>
<td>将字符串转为小写</td>
</tr>
<tr>
<td><code>LENGTH(s)</code></td>
<td>获取字符串长度</td>
</tr>
<tr>
<td><code>SUBSTRING(s, start, length)</code></td>
<td>获取字符串子集</td>
</tr>
<tr>
<td><code>LEFT(s, n)</code></td>
<td>返回字符串的<strong>前n个字符</strong></td>
</tr>
<tr>
<td><code>RIGHT(s, n)</code></td>
<td>返回字符串的<strong>后n个字符</strong></td>
</tr>
<tr>
<td><code>REPLACE(s, s1, s2)</code></td>
<td>将字符串s中的<strong>子集s1替换为s2</strong></td>
</tr>
<tr>
<td>GROUP_CONCAT([DISTINCT] expression<br />[ORDER BY expression] SEPARATOR sep)</td>
<td>将<strong>分组中的字符串</strong>通过<strong>自定义的分隔符</strong>进行连接</td>
</tr>
</tbody></table>
<ul>
<li><p>例子：</p>
<ul>
<li><p>错误写法：</p>
  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> ID<span class="token punctuation">,</span> NAME<span class="token punctuation">,</span> LENGTH<span class="token punctuation">(</span>NAME<span class="token punctuation">)</span> <span class="token keyword">AS</span> LEN_NAME
<span class="token keyword">FROM</span> world<span class="token punctuation">.</span>city
<span class="token keyword">WHERE</span> LEN_NAME <span class="token operator">>=</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>  <strong>city表中没有LEN_NAME列</strong>，执行会报错。</p>
</li>
<li><p>正确写法：</p>
  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> ID<span class="token punctuation">,</span> NAME<span class="token punctuation">,</span> LENGTH<span class="token punctuation">(</span>NAME<span class="token punctuation">)</span> <span class="token keyword">AS</span> LEN_NAME
<span class="token keyword">FROM</span> world<span class="token punctuation">.</span>city 
<span class="token keyword">WHERE</span> LENGTH<span class="token punctuation">(</span>NAME<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p><code>GROUP_CONCAT()</code>的用法</p>
  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> dept_no<span class="token punctuation">,</span> GROUP_CONCAT<span class="token punctuation">(</span>emp_no SEPARATOR <span class="token string">','</span><span class="token punctuation">)</span> 
<span class="token keyword">FROM</span> dept_emp 
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> dept_no<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ul>
<blockquote>
<p>SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法</p>
</blockquote>
<blockquote>
<p>使得能对串进行发音比较而不是字母比较。</p>
</blockquote>
<blockquote>
<p>虽然SOUNDEX不是SQL概念，但MySQL（就像多数DBMS一样）都提供对SOUNDEX的支持。</p>
</blockquote>
<blockquote>
<p>在这个例子中，WHERE子句使用Soundex()函数来转换cust_contact列值和搜索串为它们的SOUNDEX值。因为Y.Lee和Y.Lie发音相似，所以它们的SOUNDEX值匹配，因此WHERE子句正确地过滤出了所需的数据。</p>
</blockquote>
<hr>
<h4 id="日期和时间处理函数"><a href="#日期和时间处理函数" class="headerlink" title="日期和时间处理函数"></a>日期和时间处理函数</h4><ul>
<li>一般，应用程序不使用用来存储日期和时间的格式，因此日期和时间函数总是被用来读取、统计和处理这些值。由于这个原因，日期和时间函数在MySQL语言中具有重要的作用。</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ADDDATE(d, n)</code></td>
<td>计算起始日期d加上n<strong>天</strong>的日期<br />如<code>SELECT ADDDATE(2017-06-15, INTERVAL 10 DAY)</code></td>
</tr>
<tr>
<td><code>ADDTIME(t, n)</code></td>
<td>时间t加上n<strong>秒</strong>的时间</td>
</tr>
<tr>
<td><code>CURDATE()</code></td>
<td>返回当前<strong>日期</strong></td>
</tr>
<tr>
<td><code>CURTIME()</code></td>
<td>返回当前<strong>时间</strong>(<strong>不含日期</strong>)</td>
</tr>
<tr>
<td><code>NOW()</code></td>
<td>返回<strong>当前日期和时间</strong></td>
</tr>
<tr>
<td><code>DATE()</code></td>
<td><strong>从日期或日期时间表达式中提取日期值</strong><br />如<code>SELECT DATE(&quot;2017-06-15&quot;)</code></td>
</tr>
<tr>
<td><code>DATEDIFF(d1, d2)</code></td>
<td>计算日期d1-&gt;d2之间<strong>相隔的天数</strong></td>
</tr>
<tr>
<td><code>TIMESTAMPDIFF(INTERVAL, datetime_expr1, datetime_expr2)</code></td>
<td>比较两个日期的时间差。<br />interval 确定时间差的<strong>单位</strong>：SECOND、MINUTE、HOUR、DAY、MONTH、YEAR<br />差值为 后一个时间参数 - 前一个时间参数</td>
</tr>
<tr>
<td><code>DATE_ADD(d, INTERVAL expr type)</code></td>
<td>计算起始日期d<strong>加上</strong>一个<strong>时间段</strong>后的日期<br />如<code>DATE_ADD(paidTime, INTERVAL -2 MONTH)</code></td>
</tr>
<tr>
<td><code>DATE_SUB(d,INTERVAL expr unit)</code></td>
<td>计算起始日期d<strong>减去</strong>一个<strong>时间段</strong>后的日期<br />如<code>DATE_SUB(paidTime, INTERVAL 2 MONTH)</code></td>
</tr>
<tr>
<td><code>DATE_FORMAT(d, f)</code></td>
<td>按表达式f的要求显示日期d<br />如<code>SELECT DATE_FORMAT(&#39;2020-07-28&#39;, &quot;%Y-%m&quot;)</code></td>
</tr>
<tr>
<td><code>DAYOFWEEK(d)</code></td>
<td>当前日期是<strong>星期几</strong></td>
</tr>
<tr>
<td><code>YEAR(d)</code></td>
<td>返回<strong>年份</strong></td>
</tr>
<tr>
<td><code>MONTH(d)</code></td>
<td>返回<strong>月份</strong></td>
</tr>
<tr>
<td><code>DAY(d)</code></td>
<td>返回日期值d的<strong>日</strong>部分</td>
</tr>
<tr>
<td><code>HOUR(t)</code></td>
<td>返回<strong>小时值</strong></td>
</tr>
<tr>
<td><code>MINuTE(t)</code></td>
<td>返回<strong>分钟值</strong></td>
</tr>
<tr>
<td><code>SECOND(t)</code></td>
<td>返回<strong>秒钟值</strong></td>
</tr>
<tr>
<td><code>TIME(expression)</code></td>
<td>提取表达式中的<strong>时间部分</strong></td>
</tr>
</tbody></table>
<ul>
<li><p>数据经常需要<strong>用日期进行过滤</strong></p>
<ul>
<li><p>首先需要注意的是MySQL使用的<strong>日期格式</strong>。无论你什么时候指定一个日期，不管是插入或更新表值还是用WHERE子句进行过滤，<strong>日期必须为格式yyyy-mm-dd</strong>。虽然其他的日期格式可能也行，但这是首选的日期格式，因为它<strong>排除了多义性</strong>（如，04&#x2F;05&#x2F;06是2006年5月4日或2006年4月5日或2004年5月6日或……）。</p>
</li>
<li><p><strong>应该总是使用4位数字的年份</strong>。支持2位数字的年份，MySQL处理00-69为2000-2069，处理70-99为1970-1999。虽然它们可能是打算要的年份，但<strong>使用完整的4位数字年份更可靠，因为MySQL不必做出任何假定</strong>。</p>
</li>
</ul>
</li>
<li><p>如果你<strong>想要的仅是日期</strong>，则<strong>使用Date()是一个良好的习惯</strong>，即使你知道相应的列只包含日期也是如此。这样，如果由于某种原因表中以后有日期和时间值，你的SQL代码也不用改变。当然，也存在一个<strong>Time()函数</strong>，在你<strong>只想要时间时</strong>应该使用它。</p>
</li>
<li><p><code>Date()</code>和<code>Time()</code>都是在MySQL 4.1.1中第一次引入的。</p>
</li>
<li><p>还有一种日期比较需要说明。如果你想检索出2005年9月下的所有订单，怎么办？简单的相等测试不行，因为它也要匹配月份中的天数。有几种解决办法。</p>
<ul>
<li><p>其中之一如下所示：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> cust_id<span class="token punctuation">,</span> order_num
<span class="token keyword">FROM</span> orders
<span class="token keyword">WHERE</span> <span class="token keyword">Date</span><span class="token punctuation">(</span>order_date<span class="token punctuation">)</span> <span class="token operator">BETWEEN</span> <span class="token string">'2005-09-01'</span> <span class="token operator">AND</span> <span class="token string">'2005-09-30'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>


</li>
<li><p>另外一种办法（<strong>不需要记住每个月中有多少天或不需要操心闰年2月</strong>）：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> cust_id<span class="token punctuation">,</span> order_num
<span class="token keyword">FROM</span> orders
<span class="token keyword">WHERE</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>order_date<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2005</span> <span class="token operator">AND</span> <span class="token keyword">MONTH</span><span class="token punctuation">(</span>order_date<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ul>
<hr>
<h4 id="数值处理函数"><a href="#数值处理函数" class="headerlink" title="数值处理函数"></a>数值处理函数</h4><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ABS(x)</td>
<td>返回x的绝对值</td>
</tr>
<tr>
<td>SIN(x)</td>
<td>返回正弦值(参数是<strong>弧度</strong>)</td>
</tr>
<tr>
<td>COS(x)</td>
<td>返回余弦值(参数是<strong>弧度</strong>)</td>
</tr>
<tr>
<td>TAN(x)</td>
<td>返回正切值(参数是<strong>弧度</strong>)</td>
</tr>
<tr>
<td>EXP(x)</td>
<td>返回<strong>e的x次方</strong></td>
</tr>
<tr>
<td>MOD(x, y)</td>
<td>返回<strong>x除以y以后的余数</strong></td>
</tr>
<tr>
<td>PI()</td>
<td>返回圆周率(<strong>3.141593</strong>)</td>
</tr>
<tr>
<td>RAND()</td>
<td>返回<strong>0到1</strong>的随机数</td>
</tr>
<tr>
<td>SQRT()</td>
<td>返回x的<strong>平方根</strong></td>
</tr>
<tr>
<td>ROUND(column_name, decimals)</td>
<td>把数值字段<strong>舍入</strong>为<strong>指定的小数位数(decimals)</strong></td>
</tr>
</tbody></table>
<hr>
<h4 id="IF表达式"><a href="#IF表达式" class="headerlink" title="IF表达式"></a>IF表达式</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">IF</span><span class="token punctuation">(</span>expr1<span class="token punctuation">,</span> expr2<span class="token punctuation">,</span> expr3<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>expr1的值为<code>TRUE</code>，则返回值为<code>expr2</code><br>expr1的值为<code>FALSE</code>，则返回值为<code>expr3</code></p>
<hr>
<h4 id="IFNULL函数"><a href="#IFNULL函数" class="headerlink" title="IFNULL函数"></a>IFNULL函数</h4><p><code>IFNULL(check_expression, replacement_value )</code></p>
<ul>
<li><code>replacement_value</code>：在<code>check_expression</code>为<code>NULL</code>时返回的表达式</li>
<li><code>check_expression</code>和<code>replacement_value</code>类型必须相同</li>
</ul>
<p><strong>SQL Server</strong>中相同功能的函数为<code>ISNULL()</code></p>
<p>示例：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> IFNULL<span class="token punctuation">(</span>
        <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> Salary 
        <span class="token keyword">FROM</span> Employee 
        <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Salary <span class="token keyword">DESC</span>
        <span class="token keyword">LIMIT</span> <span class="token number">1</span> <span class="token keyword">OFFSET</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token boolean">NULL</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> SecondHighestSalary<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h4 id="开窗函数-窗口函数"><a href="#开窗函数-窗口函数" class="headerlink" title="开窗函数&#x2F;窗口函数"></a>开窗函数&#x2F;窗口函数</h4><h5 id="窗口函数的作用"><a href="#窗口函数的作用" class="headerlink" title="窗口函数的作用"></a>窗口函数的作用</h5><p>在日常工作中，经常会遇到需要<strong>在每组内排名</strong>，比如下面的业务需求：</p>
<blockquote>
<p>排名问题：<strong>每个部门</strong>按业绩来<strong>排名</strong></p>
<p>topN问题：找出<strong>每个部门排名前N</strong>的员工进行奖励</p>
</blockquote>
<p>面对这类需求，就需要使用SQL的高级功能<strong>窗口函数</strong>了。</p>
<hr>
<h5 id="什么是窗口函数"><a href="#什么是窗口函数" class="headerlink" title="什么是窗口函数"></a>什么是窗口函数</h5><p>窗口函数，也叫OLAP(Online Analytical Processing，<strong>实时分析处理</strong>)函数。</p>
<hr>
<p>基本语法：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token operator">&lt;</span>窗口函数<span class="token operator">></span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> <span class="token operator">&lt;</span>用于分组的列名<span class="token operator">></span> 
             	<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token operator">&lt;</span>用于排序的列名<span class="token operator">></span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>为什么叫窗口函数？</p>
<p>​	因为<code>PARTITION BY</code><strong>分组后的结果</strong>称为”窗口”，<strong>表示范围</strong>的意思。</p>
<p><code>&lt;窗口函数&gt;</code>位置可以放以下两种函数：</p>
<ol>
<li><strong>专用窗口函数</strong></li>
<li><strong>聚合函数</strong></li>
</ol>
<p>因为<strong>窗口函数是对WHERE或者GROUP BY子句处理后的结果进行操作</strong>，所以窗口函数<strong>原则上只能写在SELECT子句中</strong>。</p>
<hr>
<h5 id="专用窗口函数RANK"><a href="#专用窗口函数RANK" class="headerlink" title="专用窗口函数RANK"></a>专用窗口函数RANK</h5><p>如果想在<strong>每个班级内</strong>按成绩排名，需要如下操作：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token punctuation">,</span> RANK<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> 班级
            <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> 成绩 <span class="token keyword">DESC</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> ranking
<span class="token keyword">FROM</span> 班级表<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>在<strong>每个班级内</strong>按成绩排名：</p>
<ul>
<li><p>按班级分组</p>
<p>  <code>PARTITION BY</code>用来对表分组</p>
</li>
<li><p>按成绩排名</p>
<p>  <code>ORDER BY</code>用来<strong>对各分组内的结果排序</strong>(默认升序)</p>
</li>
</ul>
</li>
<li><p>为什么使用窗口函数，而不是<code>GROUP BY</code>+<code>ORDER BY</code>呢？</p>
<p>  因为<code>GROUP BY</code>分组汇总后，<strong>改变了表的行数</strong>，<strong>一行只有一个GROUP</strong>。而**<code>PARTITION BY</code>和<code>RANK</code>函数不会减少原表中的行数**。</p>
</li>
</ul>
<hr>
<h5 id="其他专用窗口函数"><a href="#其他专用窗口函数" class="headerlink" title="其他专用窗口函数"></a>其他专用窗口函数</h5><ul>
<li><code>DENSE_RANK()</code></li>
<li><code>ROW_NUMBER()</code></li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token punctuation">,</span>
	RANK<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> 成绩 <span class="token keyword">DESC</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> ranking<span class="token punctuation">,</span>
    DENSE_RANK<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> 成绩 <span class="token keyword">DESC</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> dense_rank<span class="token punctuation">,</span>
    ROW_NUMBER<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> 成绩 <span class="token keyword">DESC</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> row_num
<span class="token keyword">FROM</span> 班级表<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p><code>NTILE(n)</code>：将指定行<strong>等分成n个组</strong>，赋予<strong>组号</strong>（<strong>1-n</strong>）</p>
<ul>
<li><p><code>n</code>：指定分组数</p>
<p>  如果<strong>分组数n不能被整除</strong>，将会生成<strong>两种大小</strong>的组，组内<strong>行数差距为1</strong>，<strong>行数多的组</strong>以<code>ORDER BY</code>指定的顺序<strong>在前</strong>。</p>
</li>
</ul>
</li>
</ul>
<p><strong>四个专用窗口函数的区别</strong>：</p>
<table>
<thead>
<tr>
<th>窗口函数</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td><code>RANK()</code></td>
<td>如果<strong>有并列名次的行，会占用下一名次的位置</strong><br />(如：1, 1, 1, <strong>4</strong>)</td>
</tr>
<tr>
<td><code>DENSE_RANK()</code></td>
<td>如果<strong>有并列名次的行，不占用下一名次的位置</strong><br />(如：1, 1, 1, <strong>2</strong>)</td>
</tr>
<tr>
<td><code>ROW_NUMBER()</code></td>
<td><strong>不考虑并列名次的情况</strong><br />(如：1, <strong>2</strong>, <strong>3</strong>, 4)</td>
</tr>
<tr>
<td><code>NTILE(n)</code></td>
<td>将指定行<strong>等分成n个组</strong>，赋予<strong>组号</strong>（<strong>1-n</strong>）</td>
</tr>
</tbody></table>
<hr>
<h5 id="聚合函数作为窗口函数"><a href="#聚合函数作为窗口函数" class="headerlink" title="聚合函数作为窗口函数"></a>聚合函数作为窗口函数</h5><p>聚和窗口函数和上面提到的专用窗口函数<strong>用法完全相同</strong>，只需要把聚合函数写在窗口函数的位置即可，但是<strong>函数后面括号里面不能为空，需要指定聚合的列名</strong>。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token punctuation">,</span>
	<span class="token function">SUM</span><span class="token punctuation">(</span>成绩<span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> 学号<span class="token punctuation">)</span> <span class="token keyword">AS</span> current_sum<span class="token punctuation">,</span>
	<span class="token function">AVG</span><span class="token punctuation">(</span>成绩<span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> 学号<span class="token punctuation">)</span> <span class="token keyword">AS</span> current_avg<span class="token punctuation">,</span>
	<span class="token function">COUNT</span><span class="token punctuation">(</span>成绩<span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> 学号<span class="token punctuation">)</span> <span class="token keyword">AS</span> current_count<span class="token punctuation">,</span>
	<span class="token function">MAX</span><span class="token punctuation">(</span>成绩<span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> 学号<span class="token punctuation">)</span> <span class="token keyword">AS</span> current_max<span class="token punctuation">,</span>
	<span class="token function">MIN</span><span class="token punctuation">(</span>成绩<span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> 学号<span class="token punctuation">)</span> <span class="token keyword">AS</span> current_min
<span class="token keyword">FROM</span> 班级表<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上述聚合函数，都是<strong>针对自身记录</strong>以及自身记录**之前(已查询出来的行)**的所有数据进行计算(<strong>从第一行到当前为止</strong>)。</p>
<p>聚合函数作为窗口函数，可以在每一行的数据里直观的看到，<strong>截止到本行数据，统计数据是多少</strong>（最大值、最小值等），同时<strong>可以看出每一行数据，对整体统计数据的影响</strong>。</p>
<hr>
<ul>
<li><p>前后函数</p>
<ul>
<li><code>LAG()</code></li>
<li><code>LEAD(return_value, offset, [,default])</code>：<strong>从当前行访问下一行的数据或下一行之后的行</strong>。</li>
<li><code>return_value</code>： 基于指定偏移量的后续<strong>行的返回值</strong>，必须为单个值。<br> - <code>offset</code>：从当前行转发的行数，值<strong>为正整数，默认是1</strong></li>
</ul>
</li>
<li><p>头尾函数</p>
<ul>
<li><code>FIRST_VAL()</code></li>
<li><code>LAST_VAL()</code></li>
</ul>
</li>
</ul>
<hr>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>PARTITION子句可以省略，即<strong>不指定分组</strong>。但这样就失去了窗口函数的功能，所以<strong>一般不要这么使用</strong>。</p>
<hr>
<h4 id="MySQL-8-0前没有窗口函数，怎么办"><a href="#MySQL-8-0前没有窗口函数，怎么办" class="headerlink" title="MySQL 8.0前没有窗口函数，怎么办"></a>MySQL 8.0前没有窗口函数，怎么办</h4><p>通过<strong>变量</strong>达到相同效果。</p>
<p>例：</p>
<p>创建一个<strong>人员年龄表</strong>。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> person 
<span class="token punctuation">(</span>
    id <span class="token keyword">INT</span><span class="token punctuation">,</span> 
    first_name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
    age <span class="token keyword">INT</span><span class="token punctuation">,</span> 
    gender <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> person 
<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'Bob'</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token string">'M'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> person 
<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'Jane'</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token string">'F'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> person 
<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'Jack'</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token string">'M'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> person 
<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'Bill'</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token string">'M'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> person 
<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">'Nick'</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token string">'M'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> person 
<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">'Kathy'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">'F'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> person 
<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">'Steve'</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">,</span> <span class="token string">'M'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> person 
<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">'Anne'</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token string">'F'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>现在要<strong>根据不同性别进行分组排序他们的年龄，并得到序列号</strong>：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># MySQL8.0之后，用窗口函数</span>
<span class="token keyword">SELECT</span> gender<span class="token punctuation">,</span> first_name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> RANK<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> gender 
                   <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> age <span class="token keyword">DESC</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> 排名
<span class="token keyword">FROM</span> person<span class="token punctuation">;</span>

<span class="token comment"># MySQL8.0之前，用变量</span>
<span class="token keyword">SELECT</span> gender<span class="token punctuation">,</span> first_name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> rank
<span class="token keyword">FROM</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> first_name<span class="token punctuation">,</span> gender<span class="token punctuation">,</span> age<span class="token punctuation">,</span> 
      			<span class="token variable">@rank</span>:<span class="token operator">=</span><span class="token keyword">IF</span><span class="token punctuation">(</span><span class="token variable">@gen</span><span class="token operator">=</span>gender<span class="token punctuation">,</span> <span class="token variable">@rank</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> rank<span class="token punctuation">,</span> <span class="token comment">-- 一开始@gen为空，获得排名为第一，其后相同性别时排名排名递增(按ROW_NUM()窗口函数规则排序) </span>
      			<span class="token variable">@gen</span>:<span class="token operator">=</span>gender <span class="token comment">-- 给gen赋值</span>
      <span class="token keyword">FROM</span> person<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token variable">@rank</span>:<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token variable">@gen</span>:<span class="token operator">=</span><span class="token boolean">NULL</span><span class="token punctuation">)</span> <span class="token keyword">temp</span> <span class="token comment">-- 自然连接，为person表添加两个列</span>
      <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> gender<span class="token punctuation">,</span> age <span class="token keyword">DESC</span><span class="token punctuation">)</span> b <span class="token comment">-- 按性别、年龄排序</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h4 id="行转列Pivot函数-MySQL没有，SQL-Server有"><a href="#行转列Pivot函数-MySQL没有，SQL-Server有" class="headerlink" title="行转列Pivot函数(MySQL没有，SQL Server有)"></a>行转列Pivot函数(MySQL没有，SQL Server有)</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> table_name	
<span class="token keyword">PIVOT</span><span class="token punctuation">(</span>
聚合函数 <span class="token punctuation">(</span>value_column<span class="token punctuation">)</span>
<span class="token keyword">FOR</span> pivot_column
<span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>column_list<span class="token operator">></span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>例：一张各学生各课程的分数表如下：</p>
<table>
<thead>
<tr>
<th>姓名</th>
<th>科目</th>
<th>分数</th>
</tr>
</thead>
<tbody><tr>
<td>张三</td>
<td>语文</td>
<td>74</td>
</tr>
<tr>
<td>张三</td>
<td>数学</td>
<td>83</td>
</tr>
<tr>
<td>张三</td>
<td>物理</td>
<td>93</td>
</tr>
<tr>
<td>李四</td>
<td>语文</td>
<td>74</td>
</tr>
<tr>
<td>李四</td>
<td>数学</td>
<td>84</td>
</tr>
<tr>
<td>李四</td>
<td>物理</td>
<td>94</td>
</tr>
</tbody></table>
<ul>
<li><p>现要根据姓名<strong>分别统计三门成绩</strong>，即：姓名、语文、数学、物理</p>
<ul>
<li><p><strong>MySQL</strong>采用<code>MAX(CASE WHEN ... ELSE ... END)</code></p>
  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> 姓名<span class="token punctuation">,</span> <span class="token function">MAX</span><span class="token punctuation">(</span><span class="token keyword">CASE</span> 
					<span class="token keyword">WHEN</span> 科目<span class="token operator">=</span><span class="token string">'语文'</span> <span class="token keyword">THEN</span> 分数 
              		<span class="token keyword">ELSE</span> <span class="token number">0</span> <span class="token comment">-- MAX 是为了确保筛选出科目为语文的成绩</span>
				<span class="token keyword">END</span><span class="token punctuation">)</span> 语文<span class="token punctuation">,</span> 
			<span class="token function">MAX</span><span class="token punctuation">(</span><span class="token keyword">CASE</span> 
                    <span class="token keyword">WHEN</span> 科目<span class="token operator">=</span><span class="token string">'数学'</span> <span class="token keyword">THEN</span> 分数
                    <span class="token keyword">ELSE</span> <span class="token number">0</span>
                <span class="token keyword">END</span><span class="token punctuation">)</span> 数学<span class="token punctuation">,</span>
			<span class="token function">MAX</span><span class="token punctuation">(</span><span class="token keyword">CASE</span> 
               		<span class="token keyword">WHEN</span> 科目<span class="token operator">=</span><span class="token string">'物理'</span> <span class="token keyword">THEN</span> 分数
                <span class="token keyword">END</span><span class="token punctuation">)</span> 物理
<span class="token keyword">FROM</span> table1
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> 姓名<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>其他可以<strong>使用Pivot函数</strong>的数据库</p>
  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> table1
<span class="token keyword">Pivot</span><span class="token punctuation">(</span><span class="token function">MAX</span><span class="token punctuation">(</span>分数<span class="token punctuation">)</span> <span class="token comment">-- 对 指定列 使用聚合函数</span>
      <span class="token keyword">FOR</span> 科目 <span class="token comment">-- 需要 转换为列 的行</span>
      <span class="token operator">IN</span> <span class="token punctuation">(</span>语文<span class="token punctuation">,</span> 数学<span class="token punctuation">,</span> 物理<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">-- 转换为列后的各列名 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ul>
<hr>
<h4 id="列转行UNPIVOT函数"><a href="#列转行UNPIVOT函数" class="headerlink" title="列转行UNPIVOT函数"></a>列转行UNPIVOT函数</h4><hr>
<h2 id="第12章-汇总数据"><a href="#第12章-汇总数据" class="headerlink" title="第12章 汇总数据"></a>第12章 汇总数据</h2><h3 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h3><ul>
<li>我们经常需要<strong>汇总数据而不用把它们实际检索出来</strong>，为此MySQL提供了专门的函数。使用这些函数，MySQL查询可用于<strong>检索数据，以便分析和报表生成</strong>。这种类型的检索例子有以下几种：<ul>
<li>确定表中<strong>行数</strong>（或者满足某个条件或包含某个特定值的行数）</li>
<li>获得表中<strong>行组的和</strong>。</li>
<li>找出表列（或所有行或某些特定的行）的<strong>最大值、最小值</strong>和<strong>平均值</strong>。</li>
</ul>
</li>
<li>上述例子都需要<strong>对表中数据</strong>（而<strong>不是实际数据本身</strong>）<strong>汇总</strong>。因此，返回实际表数据是对时间和处理资源的一种浪费（更不用说带宽了）。</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>对 列值为NULL的行 的处理</th>
</tr>
</thead>
<tbody><tr>
<td><code>AVG()</code></td>
<td>返回<strong>某列</strong>的平均值</td>
<td>忽略</td>
</tr>
<tr>
<td><code>COUNT()</code></td>
<td>返回<strong>某列</strong>的<strong>行数</strong></td>
<td>COUNT(*****) &#x2F;COUNT(<strong>1</strong>)<strong>不忽略</strong><br />COUNT(<strong>指定列名</strong>)忽略</td>
</tr>
<tr>
<td><code>MAX()</code></td>
<td>返回<strong>某列</strong>的最大值</td>
<td>忽略</td>
</tr>
<tr>
<td><code>MIN()</code></td>
<td>返回<strong>某列</strong>的最小值</td>
<td>忽略</td>
</tr>
<tr>
<td><code>SUM()</code></td>
<td>返回<strong>某列</strong>之和</td>
<td>忽略</td>
</tr>
</tbody></table>
<ul>
<li>MySQL还支持一系列的标准偏差聚集函数，但本书并未涉及这些内容。</li>
</ul>
<h4 id="AVG-函数"><a href="#AVG-函数" class="headerlink" title="AVG()函数"></a>AVG()函数</h4><ul>
<li><p>AVG()通过对表中行数计数并计算特定列值之和，求得该列的平均值。<strong>可返回所有列的平均值</strong>，也可用来返回<strong>特定列或行的平均值</strong>。</p>
<ul>
<li>如下，使用AVG()返回products表中<strong>所有产品的平均价格</strong></li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>prod_price<span class="token punctuation">)</span> <span class="token keyword">AS</span> avg_price
<span class="token keyword">FROM</span> products<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li>如下，返回<strong>特定供应商所提供产品的平均价格</strong></li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>prod_price<span class="token punctuation">)</span> <span class="token keyword">AS</span> avg_price
<span class="token keyword">FROM</span> products
<span class="token keyword">WHERE</span> vend_id <span class="token operator">=</span> <span class="token number">1003</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>AVG()只能用来确定特定数值列得平均值，且<strong>列名必须作为函数参数给出</strong>。<strong>为了获得多个列的平均值，必须使用多个AVG()函数</strong>。</p>
</li>
<li><p><strong>AVG()函数忽略列值为NULL的行。</strong></p>
</li>
</ul>
<hr>
<h4 id="COUNT-函数"><a href="#COUNT-函数" class="headerlink" title="COUNT()函数"></a>COUNT()函数</h4><ul>
<li><p>可利用COUNT()确定<strong>表中行的数目</strong>或<strong>符合特定条件的行的数目</strong>。</p>
</li>
<li><p>COUNT()函数有两种使用方式：</p>
<ol>
<li>使用<code>COUNT(*)</code>&#x2F;<code>COUNT(1)</code>对表中<strong>行的数目</strong>进行计数，<strong>包括空值（NULL）</strong>。</li>
<li>使用<code>COUNT(column)</code>对特定列中具有值的行进行计数，<strong>忽略NULL值</strong>。</li>
</ol>
</li>
<li><p><strong>去重计数</strong></p>
<p>  <code>COUNT(DISTINCT xxx)</code>：xxx为<strong>列名</strong></p>
</li>
</ul>
<hr>
<h4 id="MAX-函数"><a href="#MAX-函数" class="headerlink" title="MAX()函数"></a>MAX()函数</h4><ul>
<li><p>MAX()返回指定列中的最大值。MAX()<strong>要求指定列名</strong>。如：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token function">MAX</span><span class="token punctuation">(</span>prod_price<span class="token punctuation">)</span> <span class="token keyword">AS</span> max_price
<span class="token keyword">FROM</span> products<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>


</li>
<li><p>对<strong>非数值数据</strong>使用MAX()：</p>
<p>虽然MAX()一般用来找出最大的<strong>数值</strong>或<strong>日期值</strong>，但MySQL允许将它用来返回任意列中的最大值，包括返回文本列中的最大值。在<strong>用于文本数据时</strong>，如果数据按相应的列排序，则MAX()<strong>返回最后一行</strong>。</p>
</li>
<li><p>MAX()函数<strong>忽略列值为NULL的行</strong>。</p>
</li>
</ul>
<hr>
<h4 id="MIN-函数"><a href="#MIN-函数" class="headerlink" title="MIN()函数"></a>MIN()函数</h4><ul>
<li><p>MIN()的功能正好与MAX()功能相反，它返回指定列的最小值。与MAX()一样，MIN()要求指定列名</p>
</li>
<li><p>在用于文本数据时，如果数据按相应的列排序，则MIN()<strong>返回最前面的行</strong>。</p>
</li>
<li><p>MIN()函数<strong>忽略列值为NULL的行</strong>。</p>
</li>
</ul>
<hr>
<h4 id="SUM-函数"><a href="#SUM-函数" class="headerlink" title="SUM()函数"></a>SUM()函数</h4><ul>
<li><p>SUM()用来返回<strong>指定列值的和</strong>（总计）</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token function">SUM</span><span class="token punctuation">(</span>quantity<span class="token punctuation">)</span> <span class="token keyword">AS</span> items_ordered
<span class="token keyword">FROM</span> orderitems
<span class="token keyword">WHERE</span> order_num <span class="token operator">=</span> <span class="token number">20005</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>SUM()也可以用来<strong>合计计算值</strong>。在下面的例子中，合计每项物品的item_price*quantity，得出总的订单金额：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token function">SUM</span><span class="token punctuation">(</span>item_price <span class="token operator">*</span> quantity<span class="token punctuation">)</span> <span class="token keyword">AS</span> total_price
<span class="token keyword">FROM</span> orderitems
<span class="token keyword">WHERE</span> order_num <span class="token operator">=</span> <span class="token number">20005</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>SUM()<strong>函数忽略列值为NULL的行</strong>。</p>
</li>
</ul>
<hr>
<h3 id="聚集不同值"><a href="#聚集不同值" class="headerlink" title="聚集不同值"></a>聚集不同值</h3><ul>
<li><p>聚集函数的<strong>DISTINCT</strong>的使用，已经被添加到MySQL <strong>5.0.3</strong>中。下面所述内容<strong>在MySQL 4.x中不能正常运行</strong>。</p>
</li>
<li><p>上述5个聚集函数都可以如下使用：</p>
<ol>
<li><strong>对所有的行执行计算</strong>，指定ALL参数或不给参数（因为<strong>ALL是默认行为</strong>）；</li>
<li><strong>只包含不同的值</strong>，指定<strong>DISTINCT参数</strong>。</li>
</ol>
</li>
<li><p>下面的例子使用AVG()函数返回特定供应商提供的产品的平均价格。它与上面的SELECT语句相同，但<strong>使用了DISTINCT参数</strong>，因此平均值<strong>只考虑各个不同的价格</strong>：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span><span class="token keyword">DISTINCT</span> prod_price<span class="token punctuation">)</span> <span class="token keyword">AS</span> avg_price
<span class="token keyword">FROM</span> products
<span class="token keyword">WHERE</span> vend_id <span class="token operator">=</span> <span class="token number">1003</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>DISTINCT不能用于COUNT(*)，因此不允许使用COUNT（DISTINCT），否则会产生错误</strong>。类似地，<strong>DISTINCT必须使用列名</strong>，<strong>不能用于计算或表达式</strong>。</p>
</li>
</ul>
<hr>
<h3 id="组合聚集函数"><a href="#组合聚集函数" class="headerlink" title="组合聚集函数"></a>组合聚集函数</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> num_items<span class="token punctuation">,</span>
		<span class="token function">MIN</span><span class="token punctuation">(</span>prod_price<span class="token punctuation">)</span> <span class="token keyword">AS</span> price_min<span class="token punctuation">,</span>
		<span class="token function">MAX</span><span class="token punctuation">(</span>prod_price<span class="token punctuation">)</span> <span class="token keyword">AS</span> price_max<span class="token punctuation">,</span>
		<span class="token function">AVG</span><span class="token punctuation">(</span>prod_price<span class="token punctuation">)</span> <span class="token keyword">AS</span> price_avg
<span class="token keyword">FROM</span> products<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>这里用单条SELECT语句执行了4个聚集计算，返回4个值（products表中物品的数目，产品价格的最低、最高以及平均值）</p>
</li>
<li><p>在指定别名以包含某个聚集函数的结果时，不应该使用表中实际的列名。虽然这样做并非不合法，但使用唯一的名字会使你的SQL更易于理解和使用（以及将来容易排除故障）。</p>
</li>
</ul>
<h2 id="第13章-分组数据"><a href="#第13章-分组数据" class="headerlink" title="第13章 分组数据"></a>第13章 分组数据</h2><h3 id="数据分组"><a href="#数据分组" class="headerlink" title="数据分组"></a>数据分组</h3><ul>
<li>如果要返回每个供应商提供的产品数目怎么办？或者返回只提供单项产品的供应商所提供的产品，或返回提供10个以上产品的供应商怎么办？这就是分组显身手的时候了。<strong>分组</strong>允许<strong>把数据分为多个逻辑组</strong>，以便能<strong>对每个组进行聚集计算</strong>。</li>
</ul>
<hr>
<h3 id="创建分组"><a href="#创建分组" class="headerlink" title="创建分组"></a>创建分组</h3><ul>
<li><p>分组是在SELECT语句的<strong>GROUP BY子句中建立</strong>的。理解分组的最好办法是看一个例子：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> vend_id<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> num_prods
<span class="token keyword">FROM</span> products
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> vend_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>结果：</p>
<table>
<thead>
<tr>
<th>vend_id</th>
<th>num_prods</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>3</td>
</tr>
<tr>
<td>1002</td>
<td>2</td>
</tr>
<tr>
<td>1003</td>
<td>7</td>
</tr>
<tr>
<td>1005</td>
<td>2</td>
</tr>
</tbody></table>
</li>
<li><p><strong>GROUP BY子句指示</strong>MySQL<strong>按vend_id排序并分组数据</strong>。这导致<strong>对每个vend_id</strong>而不是整个表<strong>计算num_prods一次</strong></p>
</li>
<li><p>因为使用了GROUP BY，就<strong>不必指定要计算和估值的每个组了</strong>,<strong>系统会自动完成</strong>。<strong>GROUP BY子句</strong>指示MySQL分组数据，然后<strong>对每个组</strong>而不是整个结果集<strong>进行聚集</strong>。</p>
</li>
<li><p>一些重要的规定：</p>
<ul>
<li>GROUP BY子句<strong>可以包含任意数目的列</strong>。这使得<strong>能对分组进行嵌套，为数据分组提供更细致的控制</strong>。</li>
<li>如果在GROUP BY子句中<strong>嵌套了分组</strong>，<strong>数据将在最后规定的分组上进行汇总</strong>。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。</li>
<li><strong>GROUP BY子句中列出的每个列</strong>都必须是<strong>检索列</strong>或<strong>有效的表达式</strong>（但<strong>不能是聚集函数</strong>）。如果<strong>在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式</strong>。<strong>不能使用别名</strong>。</li>
<li><strong>除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出</strong>。</li>
<li>如果<strong>分组列中具有NULL值</strong>，则NULL<strong>将作为一个分组返回</strong>。如果列中有多行NULL值，它们将分为一组。</li>
<li><strong>GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前</strong>。</li>
</ul>
</li>
<li><p>使用<strong>WITH ROLLUP关键字</strong>，<strong>可以得到每个分组以及每个分组汇总级别（针对每个分组）的值</strong>，如下所示:</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> vend_id<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> num_prods
<span class="token keyword">FROM</span> products
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> vend_id <span class="token keyword">WITH ROLLUP</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ul>
<hr>
<h3 id="过滤分组"><a href="#过滤分组" class="headerlink" title="过滤分组"></a>过滤分组</h3><ul>
<li><p><strong>WHERE</strong>子句能<strong>过滤指定的行</strong>；<strong>HAVING</strong>子句用于<strong>过滤分组</strong>。</p>
</li>
<li><p>HAVING非常类似于WHERE。事实上，<strong>目前为止所学过的所有类型的WHERE子句都可以用HAVING来替代</strong>。</p>
</li>
<li><p>过滤分组的例子：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> cust_id<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> orders
<span class="token keyword">FROM</span> orders
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> cust_id
<span class="token keyword">HAVING</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里WHERE子句不起作用，因为过滤是<strong>基于分组聚集值</strong>。</p>
</li>
<li><p>HAVING和WHERE的差别</p>
<p><strong>WHERE</strong>在<strong>数据分组前</strong>进行过滤，<strong>HAVING</strong>在<strong>数据分组后</strong>进行过滤。**这是一个重要的区别，WHERE排除的行不包括在分组中。**这可能会改变计算值，从而影响HAVING子句中基于这些值过滤掉的分组。</p>
</li>
<li><p>有没有在一条语句中<strong>同时使用WHERE和HAVING子句的需要</strong>呢？事实上，确实有。假如想进一步过滤上面的语句，使它返回过去12个月内具有两个以上订单的顾客。为达到这一点，可增加一条WHERE子句，过滤出过去12个月内下过的订单。然后再增加HAVING子句过滤出具有两个以上订单的分组。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> vend_id<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> num_prods
<span class="token keyword">FROM</span> products
<span class="token keyword">WHERE</span> prod_price <span class="token operator">>=</span> <span class="token number">10</span>
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> vend_id
<span class="token keyword">HAVING</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<hr>
<h3 id="分组和排序"><a href="#分组和排序" class="headerlink" title="分组和排序"></a>分组和排序</h3><ul>
<li><p>虽然<strong>GROUP BY</strong>和<strong>ORDER BY</strong>经常完成相同的工作，但它们是非常不同的。</p>
<table>
<thead>
<tr>
<th>ORDER BY</th>
<th>GROUP BY</th>
</tr>
</thead>
<tbody><tr>
<td>排序产生的输出</td>
<td>分组行。但<strong>输出可能不是分组的顺序</strong>。</td>
</tr>
<tr>
<td>任意列都可以使用(甚至非选择的列也可以使用)</td>
<td>只可能使用<strong>选择列</strong>或<strong>表达式列</strong>，<strong>而且必须使用每个选择列表达式</strong></td>
</tr>
<tr>
<td>不一定需要</td>
<td>如果与聚集函数一起使用列(或表达式)，则必须使用</td>
</tr>
</tbody></table>
</li>
<li><p><strong>我们经常发现用GROUP BY分组的数据确实是以分组顺序输出，但情况并不总是这样，它并不是SQL规范所要求的</strong>。</p>
</li>
<li><p><strong>应该提供明确的ORDER BY子句</strong>，即使其效果等同于GROUP BY子句也是如此。<strong>千万不要仅依赖GROUP BY排序数据</strong>。</p>
</li>
</ul>
<hr>
<h3 id="SELECT子句顺序"><a href="#SELECT子句顺序" class="headerlink" title="SELECT子句顺序"></a>SELECT子句顺序</h3><table>
<thead>
<tr>
<th>子句</th>
<th>说明</th>
<th>是否必须使用</th>
</tr>
</thead>
<tbody><tr>
<td>SELECT</td>
<td>要返回的列或表达式</td>
<td>是</td>
</tr>
<tr>
<td>FROM</td>
<td>从中检索数据的表</td>
<td>仅在从表选择数据时使用</td>
</tr>
<tr>
<td>WHERE</td>
<td><strong>行</strong>级过滤</td>
<td>否</td>
</tr>
<tr>
<td>GROUP BY</td>
<td>分组说明</td>
<td>仅在按组计算聚集时使用</td>
</tr>
<tr>
<td>HAVING</td>
<td><strong>组</strong>级过滤</td>
<td>否</td>
</tr>
<tr>
<td>ORDER BY</td>
<td>输出排序顺序</td>
<td>否</td>
</tr>
<tr>
<td>LIMIT</td>
<td>要检索的行数</td>
<td>否</td>
</tr>
</tbody></table>
<hr>
<h2 id="第14章-使用子查询"><a href="#第14章-使用子查询" class="headerlink" title="第14章 使用子查询"></a>第14章 使用子查询</h2><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><ul>
<li><p><strong>MySQL 4.1引入了对子查询的支持</strong>，所以要想使用本章描述的SQL，必须使用MySQL 4.1或更高级的版本。</p>
</li>
<li><p><strong>查询（query）</strong></p>
<p>任何SQL语句都是查询。但此术语<strong>一般指SELECT语句</strong>。</p>
</li>
<li><p>SQL还允许创建<strong>子查询（subquery）</strong>，即<strong>嵌套在其他查询中的查询</strong>。</p>
</li>
</ul>
<hr>
<h3 id="利用子查询进行过滤"><a href="#利用子查询进行过滤" class="headerlink" title="利用子查询进行过滤"></a>利用子查询进行过滤</h3><ul>
<li><p>本书所有章中使用的数据库表都是<strong>关系表</strong>。对于包含订单号、客户ID、订单日期的每个订单，orders表存储一行。各订单的物品存储在相关的orderitems表中。orders表不存储客户信息。它只存储客户的ID。实际的客户信息存储在customers表中。</p>
</li>
<li><p>现在，假如需要<strong>列出订购物品TNT2的所有客户</strong>，应该怎样检索？下面列出具体的步骤：</p>
<ol>
<li>检索包含物品TNT2的所有订单的编号。</li>
<li>检索具有前一步骤列出的订单编号的所有客户的ID。</li>
<li>检索前一步骤返回的所有客户ID的客户信息。</li>
</ol>
<p>上述每个步骤都可以单独作为一个查询来执行。可以把一条SELECT语句返回的结果用于另一条SELECT语句的WHERE子句。也可以<strong>使用子查询来把3个查询组合成一条语句</strong>。</p>
</li>
<li><p>在SELECT语句中，<strong>子查询</strong>总是<strong>从内向外</strong>处理。包含子查询的SELECT语句难以阅读和调试，特别是它们较为复杂时更是如此。<strong>把子查询分解为多行并且适当地进行缩进</strong>，<strong>能极大地简化子查询的使用</strong>。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> cust_name<span class="token punctuation">,</span> cust_contact
<span class="token keyword">FROM</span> customers
<span class="token keyword">WHERE</span> cust_id <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> cust_id
                 <span class="token keyword">FROM</span> orders
                 <span class="token keyword">WHERE</span> order_num <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> order_num
                                     <span class="token keyword">FROM</span> orderitems
                                     <span class="token keyword">WHERE</span> prod_id <span class="token operator">=</span> <span class="token string">'TNT2'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>在WHERE子句中使用子查询能够编写出功能很强并且很灵活的SQL语句。对于能嵌套的子查询的数目没有限制，不过在实际使用时<strong>由于性能的限制，不能嵌套太多的子查询</strong>。</p>
</li>
<li><p><strong>列必须匹配</strong></p>
<p>在WHERE子句中<strong>使用子查询</strong>，<strong>应该保证SELECT语句具有与WHERE子句中相同数目的列</strong>。<strong>通常，子查询将返回单个列并且与单个列匹配，但如果需要也可以使用多个列</strong>。</p>
</li>
<li><p>虽然<strong>子查询一般与IN操作符结合使用</strong>，<strong>但也可以用于测试等于（&#x3D;）、不等于（&lt;&gt;）等</strong>。</p>
</li>
</ul>
<hr>
<h3 id="作为计算字段使用子查询"><a href="#作为计算字段使用子查询" class="headerlink" title="作为计算字段使用子查询"></a>作为计算字段使用子查询</h3><ul>
<li><p>使用子查询的另一方法是<strong>创建计算字段</strong></p>
</li>
<li><p>假如需要显示customers表中每个客户的订单总数，订单与相应的客户ID存储在orders表中。操作应遵循以下步骤：</p>
<ol>
<li>从customers表中检索客户列表</li>
<li>对于检索出的每个客户，统计其在orders表中的订单数目。<strong>对每个客户执行<code>COUNT(*)</code>计算，应该将<code>COUNT(*)</code>作为一个子查询</strong>。</li>
</ol>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> cust_name<span class="token punctuation">,</span>
		cust_state<span class="token punctuation">,</span>
		<span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>
         <span class="token keyword">FROM</span> orders
         <span class="token keyword">WHERE</span> orders<span class="token punctuation">.</span>cust_id <span class="token operator">=</span> customers<span class="token punctuation">.</span>cust_id<span class="token punctuation">)</span> <span class="token keyword">AS</span> orders
<span class="token keyword">FROM</span> customers
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> cust_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>涉及外部查询</strong>的子查询称为<strong>相关子查询</strong>。任何时候<strong>只要列名可能有多义性</strong>，就必须使用这种语法（<strong>表名和列名由一个句点分隔</strong>）。</p>
</li>
</ul>
<h2 id="第15章-联结表"><a href="#第15章-联结表" class="headerlink" title="第15章 联结表"></a>第15章 联结表</h2><h3 id="联结"><a href="#联结" class="headerlink" title="联结"></a>联结</h3><ul>
<li><strong>联结</strong>是利用SQL的<strong>SELECT</strong>能执行的<strong>最重要</strong>的操作</li>
</ul>
<h4 id="关系表"><a href="#关系表" class="headerlink" title="关系表"></a>关系表</h4><ul>
<li>假如有由同一供应商生产的多种物品，那么在何处存储供应商信息（如，供应商名、地址、联系方法等）呢？将这些数据与产品信息分开存储的理由如下。<ul>
<li>因为同一供应商生产的每个产品的供应商信息都是相同的，对每个产品重复此信息既浪费时间又浪费存储空间。</li>
<li>如果供应商信息改变（例如，供应商搬家或电话号码变动），只需改动一次即可。</li>
<li>如果有重复数据（即每种产品都存储供应商信息），很难保证每次输入该数据的方式都相同。不一致的数据在报表中很难利用。</li>
</ul>
</li>
</ul>
<p>相同数据出现多次决不是一件好事，此因素是关系数据库设计的基础。<strong>关系表的设计就是要保证把信息分解成多个表，一类数据一个表</strong>。各表通过某些常用的值（即关系设计中的关系（relational））互相关联。</p>
<p>在这个例子中，可建立两个表，一个存储<strong>供应商信息</strong>，另一个存储<strong>产品信息</strong>。</p>
<ul>
<li><p>vendors表包含所有供应商信息，每个供应商占一行，每个供应商具有唯一的标识。此标识称为<strong>主键（primary key）</strong>，可以是供应商ID或任何其他唯一值。</p>
</li>
<li><p>products表只存储产品信息，它除了存储供应商ID（vendors表的主键）外不存储其他供应商信息。</p>
</li>
<li><p>vendors表的<strong>主键</strong>又叫作<strong>products的外键</strong>，它将vendors表与products表关联，利用供应商ID能从vendors表中找出相应供应商的详细信息。</p>
<blockquote>
<p><strong>外键（foreign key）<strong>为某个表中的一列，它</strong>包含另一个表的主键值</strong>，定义了两个表之间的关系。</p>
</blockquote>
</li>
</ul>
<p>总之，关系数据可以有效地存储和方便地处理。因此，<strong>关系数据库</strong>的<strong>可伸缩性</strong>远比非关系数据库要好。</p>
<blockquote>
<p><strong>可伸缩性（scale）</strong> 能够适应不断增加的工作量而不失败。设计良好的数据库或应用程序称之为可伸缩性好（<strong>scale well</strong>）</p>
</blockquote>
<hr>
<h4 id="为什么要使用联结"><a href="#为什么要使用联结" class="headerlink" title="为什么要使用联结"></a>为什么要使用联结</h4><p>如果数据存储在多个表中，<strong>要使用单条SELECT语句检索出数据</strong>，则需要使用联结。</p>
<p>联结是一种机制，<strong>用来在一条SELECT语句中关联表，因此称之为联结</strong>。使用特殊的语法，可以联结多个表返回一组输出，联结在运行时关联表中正确的行。</p>
<hr>
<h3 id="创建联结"><a href="#创建联结" class="headerlink" title="创建联结"></a>创建联结</h3><p>联结的创建非常简单，规定要联结的所有表以及它们如何关联即可。</p>
<p>例：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> vend_name<span class="token punctuation">,</span> prod_name<span class="token punctuation">,</span> prod_price
<span class="token keyword">FROM</span> vendors<span class="token punctuation">,</span> products
<span class="token keyword">WHERE</span> vendors<span class="token punctuation">.</span>vend_id <span class="token operator">=</span> products<span class="token punctuation">.</span>vend_id
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> vend_name<span class="token punctuation">,</span> prod_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>这条语句的FROM子句列出了两个表，分别是vendors和products</li>
</ul>
<hr>
<h4 id="WHERE子句的重要性"><a href="#WHERE子句的重要性" class="headerlink" title="WHERE子句的重要性"></a>WHERE子句的重要性</h4><ul>
<li><p>在一条SELECT语句中<strong>联结几个表时</strong>，相应的<strong>关系是在运行中构造</strong>的。</p>
</li>
<li><p>在联结两个表时，你实际上做的是<strong>将第一个表中的每一行与第二个表中的每一行配对</strong>。WHERE子句作为过滤条件，它只包含那些匹配给定条件（这里是联结条件）的行</p>
</li>
<li><p><strong>没有WHERE子句，第一个表中的每个行将与第二个表中的每个行配对</strong>，而不管它们逻辑上是否可以配在一起。由没有联结条件的表关系返回的结果为<strong>笛卡儿积</strong>。</p>
<blockquote>
<p>笛卡尔积：检索出的<strong>行的数目</strong>将是<strong>第一个表中的行数乘以第二个表中的行数</strong>。</p>
</blockquote>
<p>  有时我们会听到返回称为**叉联结（cross join）**的笛卡儿积的联结类型。</p>
</li>
</ul>
<hr>
<h4 id="内部联结"><a href="#内部联结" class="headerlink" title="内部联结"></a>内部联结</h4><p>目前上述的联结称为<strong>等值联结（equijoin）</strong>，它基于两个表之间的相等测试，也称为<strong>内部联结</strong>。</p>
<p>下面的SELECT语句返回与前面例子完全相同的数据：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> vend_name<span class="token punctuation">,</span> prod_name<span class="token punctuation">,</span> prod_price
<span class="token keyword">FROM</span> vendors <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> products
<span class="token keyword">ON</span> vendors<span class="token punctuation">.</span>vend_id <span class="token operator">=</span> products<span class="token punctuation">.</span>vend_id
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> vend_name<span class="token punctuation">,</span> prod_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>这里，两个表之间的关系是FROM子句的组成部分，以<strong>INNER JOIN</strong>指定。在使用这种语法时，<strong>联结条件</strong>用特定的<strong>ON子句</strong>而不是WHERE子句给出。传递给ON的实际条件与传递给WHERE的相同。</li>
<li>ANSI SQL规范<strong>首选INNER JOIN语法</strong>。此外，尽管使用WHERE子句定义联结的确比较简单，但是使用明确的联结语法能够确保不会忘记联结条件，有时候这样做也能影响性能。</li>
</ul>
<hr>
<h4 id="联结多个表"><a href="#联结多个表" class="headerlink" title="联结多个表"></a>联结多个表</h4><ul>
<li>MySQL在运行时<strong>关联指定的每个表以处理联结。这种处理可能是非常耗费资源的</strong>，因此应该仔细，不要联结不必要的表。联<strong>结的表越多，性能下降越厉害</strong>。</li>
</ul>
<hr>
<h2 id="第16章-创建高级联结"><a href="#第16章-创建高级联结" class="headerlink" title="第16章 创建高级联结"></a>第16章 创建高级联结</h2><ul>
<li><p>给列起<strong>别名</strong>的语法如下：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> Concat<span class="token punctuation">(</span>RTrim<span class="token punctuation">(</span>vend_name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">' ('</span><span class="token punctuation">,</span> RTrim<span class="token punctuation">(</span>vend_country<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">') '</span><span class="token punctuation">)</span> <span class="token keyword">AS</span>
vend_title
<span class="token keyword">FROM</span> vendors
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> vend_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>别名除了用于<strong>列名</strong>和<strong>计算字段</strong>外，SQL还允许<strong>给表名起别名</strong>。这样做有两个主要理由：</p>
<ol>
<li><p>缩短SQL语句</p>
</li>
<li><p>允许在<strong>单条</strong>SELECT语句中<strong>多次使用</strong>相同的表</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> cust_name<span class="token punctuation">,</span> cust_contact
<span class="token keyword">FROM</span> customers <span class="token keyword">AS</span> c<span class="token punctuation">,</span> orders <span class="token keyword">AS</span> o<span class="token punctuation">,</span> orderitems <span class="token keyword">AS</span> oi
<span class="token keyword">WHERE</span> c<span class="token punctuation">.</span>cust_id <span class="token operator">=</span> o<span class="token punctuation">.</span>cust_id
	<span class="token operator">AND</span> oi<span class="token punctuation">.</span>order_num <span class="token operator">=</span> o<span class="token punctuation">.</span>order_num
	<span class="token operator">AND</span> prod_id <span class="token operator">=</span> <span class="token string">'TNT2'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
</li>
<li><p><strong>表别名</strong>只在<strong>查询</strong>执行中使用。与列别名不一样，<strong>表别名不返回到客户机</strong>。</p>
</li>
</ul>
<hr>
<h3 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a>自联结</h3><ul>
<li><p>假如你发现某物品（其ID为DTNTR）存在问题，因此想知道生产该物品的供应商生产的其他物品是否也存在这些问题。此查询要求首先找到生产ID为DTNTR的物品的供应商，然后找出这个供应商生产的其他物品。</p>
<ul>
<li>方法一（<strong>子查询</strong>）:</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> prod_id<span class="token punctuation">,</span> prod_name
<span class="token keyword">FROM</span> products
<span class="token keyword">WHERE</span> vend_id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> vend_id
                <span class="token keyword">FROM</span> products
                <span class="token keyword">WHERE</span> prod_id <span class="token operator">=</span> <span class="token string">'DTNTR'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>方法二(联结)：</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> p1<span class="token punctuation">.</span>prod_id<span class="token punctuation">,</span> p1<span class="token punctuation">.</span>prod_name
<span class="token keyword">FROM</span> products <span class="token keyword">AS</span> p1<span class="token punctuation">,</span> products <span class="token keyword">AS</span> p2
<span class="token keyword">WHERE</span> p1<span class="token punctuation">.</span>vend_id <span class="token operator">=</span> p2<span class="token punctuation">.</span>vend_id
	<span class="token operator">AND</span> p2<span class="token punctuation">.</span>prod_id <span class="token operator">=</span> <span class="token string">'DTNTR'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p> 此查询中需要的<strong>两个表实际上是相同的表</strong>，因此products表在FROM子句中出现了两次。虽然这是完全合法的，但对products的引用具有<strong>二义性</strong>，因为MySQL不知道你引用的是products表中的哪个实例。为解决此问题，使用了表别名。</p>
</li>
<li><p>自联结通常作为外部语句用来替代从相同表中检索数据时使用的子查询语句。虽然最终的结果是相同的，但有时候<strong>处理联结远比处理子查询快得多</strong>。应该试一下两种方法，以确定哪一种的性能更好。</p>
</li>
</ul>
<hr>
<h3 id="自然联结"><a href="#自然联结" class="headerlink" title="自然联结"></a>自然联结</h3><ul>
<li><p>标准的<strong>内部联结</strong>返回<strong>所有数据</strong>，甚至<strong>相同的列多次出现</strong>。<strong>自然联结排除多次出现，使每个列只返回一次</strong>。</p>
</li>
<li><p>自然联结是这样一种联结，其中你<strong>只能选择那些唯一的列</strong>。这一般是通过对表使用通配符（**SELECT ***），对所有其他表的列使用明确的子集来完成的。如：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> c<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">,</span> o<span class="token punctuation">.</span>order_num<span class="token punctuation">,</span> o<span class="token punctuation">.</span>order_date<span class="token punctuation">,</span>
		oi<span class="token punctuation">.</span>prod_id<span class="token punctuation">,</span> oi<span class="token punctuation">.</span>quality<span class="token punctuation">,</span> oi<span class="token punctuation">.</span>item_price
<span class="token keyword">FROM</span> customers <span class="token keyword">AS</span> c<span class="token punctuation">,</span> orders <span class="token keyword">AS</span> o<span class="token punctuation">,</span> orderitems <span class="token keyword">AS</span> oi
<span class="token keyword">WHERE</span> c<span class="token punctuation">.</span>cust_id <span class="token operator">=</span> o<span class="token punctuation">.</span>cust_id
	<span class="token operator">AND</span> oi<span class="token punctuation">.</span>order_num <span class="token operator">=</span> o<span class="token punctuation">.</span>order_num
	<span class="token operator">AND</span> prod_id <span class="token operator">=</span> <span class="token string">'FB'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>事实上，<strong>迄今为止我们建立的每个内部联结都是自然联结</strong>，很可能我们永远都不会用到不是自然联结的内部联结。</p>
</li>
</ul>
<hr>
<h3 id="外部联结"><a href="#外部联结" class="headerlink" title="外部联结"></a>外部联结</h3><ul>
<li><p>许多联结将一个表中的行与另一个表中的行相关联。但有时候会需要包含没有关联行的那些行。</p>
<ul>
<li><p>下面的SELECT语句给出一个简单的<strong>内部联结</strong>。它检索所有客户及其订单(<strong>不包括没有订单的客户</strong>)：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> customers<span class="token punctuation">.</span>cust_id<span class="token punctuation">,</span> orders<span class="token punctuation">.</span>order_num
<span class="token keyword">FROM</span> customers <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> orders
<span class="token keyword">ON</span> customers<span class="token punctuation">.</span>cust_id <span class="token operator">=</span> orders<span class="token punctuation">.</span>cust_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>外部联结</strong>语法类似。为了检索素有客户(<strong>包括没有订单的客户</strong>)，可如下进行：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> customer<span class="token punctuation">.</span>cust_id<span class="token punctuation">,</span> orders<span class="token punctuation">.</span>order_num
<span class="token keyword">FROM</span> customers <span class="token keyword">LEFT</span> <span class="token keyword">OUTER</span> <span class="token keyword">JOIN</span> orders
<span class="token keyword">ON</span> customers<span class="token punctuation">.</span>cust_id <span class="token operator">=</span> orders<span class="token punctuation">.</span>cust_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>这条SELECT语句使用了关键字<strong>OUTER JOIN</strong>来<strong>指定联结的类型</strong>（而不是在WHERE子句中指定）</p>
</li>
</ul>
</li>
<li><p>在使用<strong>OUTER JOIN</strong>语法时，必须使用<strong>RIGHT</strong>或<strong>LEFT</strong>关键字<strong>指定包括其所有行的表</strong>（RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表）</p>
</li>
<li><p>外部联结的<strong>OUTER可省略</strong></p>
</li>
<li><p>MySQL<strong>不支持</strong>简化字符<code>*=</code>和<code>=*</code>的使用，这两种操作符在其他DBMS中是很流行的。</p>
</li>
<li><p>如果要<strong>检索所有客户及每个客户所下的订单数</strong>，下面使用了<strong>COUNT()函数</strong>的代码可完成此工作：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> customers<span class="token punctuation">.</span>cust_name<span class="token punctuation">,</span>
	customers<span class="token punctuation">.</span>cust_id<span class="token punctuation">,</span>
	<span class="token function">COUNT</span><span class="token punctuation">(</span>orders<span class="token punctuation">.</span>order_num<span class="token punctuation">)</span> <span class="token keyword">AS</span> num_ord
<span class="token keyword">FROM</span> customers <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> orders
<span class="token keyword">ON</span> customers<span class="token punctuation">.</span>cust_id <span class="token operator">=</span> orders<span class="token punctuation">.</span>cust_id
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> customers<span class="token punctuation">.</span>cust_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h3 id="使用联结和联结条件"><a href="#使用联结和联结条件" class="headerlink" title="使用联结和联结条件"></a>使用联结和联结条件</h3><ul>
<li><p>有必要汇总一下关于联结及其使用的某些要点：</p>
<ul>
<li><p>注意所使用的联结类型。一般我们使用内部联结，但使用外部联结也是有效的。</p>
</li>
<li><p>应该总是<strong>提供联结条件</strong>，否则会得出笛卡儿积。</p>
</li>
<li><p>在一个联结中可以包含多个表，甚至对于每个联结可以采用不同的联结类型。虽然这样做是合法的，一般也很有用，但应该在一起测试它们前，分别测试每个联结。这将使故障排除更为简单。</p>
</li>
</ul>
</li>
</ul>
<h2 id="第17章-组合查询"><a href="#第17章-组合查询" class="headerlink" title="第17章 组合查询"></a>第17章 组合查询</h2><h3 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h3><ul>
<li><p>MySQL也允许<strong>执行多个查询</strong>（多条SELECT语句），并<strong>将结果作为单个查询结果集返回</strong>。这些<strong>组合查询</strong>通常称为<strong>并（union）<strong>或</strong>复合查询（compound query）</strong>。</p>
</li>
<li><p>有两种基本情况，其中需要使用组合查询：</p>
<ol>
<li>在<strong>单个查询中</strong>从<strong>不同的表</strong>返回<strong>类似结构</strong>的数据；</li>
<li>对<strong>单个表</strong>执行<strong>多个查询</strong>，<strong>按单个查询返回数据</strong>。</li>
</ol>
</li>
<li><p><strong>任何具有多个WHERE子句的SELECT语句</strong>都可以作为<strong>一个组合查询</strong>给出，在以下段落中可以看到这一点。<strong>这两种技术在不同的查询中性能也不同</strong>。因此，应该试一下这两种技术，以确定对特定的查询哪一种性能更好。</p>
</li>
</ul>
<hr>
<h3 id="创建组合查询"><a href="#创建组合查询" class="headerlink" title="创建组合查询"></a>创建组合查询</h3><p>可用<strong>UNION操作符</strong>来<strong>组合数条SQL查询</strong>。<strong>利用UNION，可给出多条SELECT语句，将它们的结果组合成单个结果集</strong>。</p>
<h4 id="使用UNION"><a href="#使用UNION" class="headerlink" title="使用UNION"></a>使用UNION</h4><ul>
<li><p>UNION的使用很简单，<strong>只需给出每条SELECT语句，在各条语句之间放上关键字UNION</strong>。如：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> vend_id<span class="token punctuation">,</span> prod_id<span class="token punctuation">,</span> prod_price
<span class="token keyword">FROM</span> products
<span class="token keyword">WHERE</span> prod_price <span class="token operator">&lt;=</span> <span class="token number">5</span>
<span class="token keyword">UNION</span>
<span class="token keyword">SELECT</span> vend_id<span class="token punctuation">,</span> prod_id<span class="token punctuation">,</span> prod_price
<span class="token keyword">FROM</span> products
<span class="token keyword">WHERE</span> vend_id <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">1001</span><span class="token punctuation">,</span> <span class="token number">1002</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>结果：</p>
<table>
<thead>
<tr>
<th>vend_id</th>
<th>prod_id</th>
<th>prod_price</th>
</tr>
</thead>
<tbody><tr>
<td>1003</td>
<td>FC</td>
<td>2.50</td>
</tr>
<tr>
<td>1002</td>
<td>FU1</td>
<td>3.42</td>
</tr>
<tr>
<td>1003</td>
<td>SLING</td>
<td>4.49</td>
</tr>
<tr>
<td>1003</td>
<td>TNT1</td>
<td>2.50</td>
</tr>
<tr>
<td>1001</td>
<td>ANV01</td>
<td>5.99</td>
</tr>
<tr>
<td>1001</td>
<td>ANV02</td>
<td>9.99</td>
</tr>
<tr>
<td>1001</td>
<td>ANV03</td>
<td>14.99</td>
</tr>
<tr>
<td>1002</td>
<td>OL1</td>
<td>8.99</td>
</tr>
</tbody></table>
<p>UNION指示MySQL执行两条SELECT语句，并<strong>把输出组合成单个查询结果集</strong>。</p>
<p>作为参考，这里给出使用多条WHERE子句而不是使用UNION的相同查询：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> vend_id<span class="token punctuation">,</span> prod_id<span class="token punctuation">,</span> prod_price
<span class="token keyword">FROM</span> products
<span class="token keyword">WHERE</span> prod_price <span class="token operator">&lt;=</span> <span class="token number">5</span>
	<span class="token operator">OR</span> vend_id <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">1001</span><span class="token punctuation">,</span> <span class="token number">1002</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个简单的例子中，<strong>使用UNION可能比使用WHERE子句更为复杂</strong>。但对于<strong>更复杂的过滤条件</strong>，或者<strong>从多个表中检索数据</strong>的情形，<strong>使用UNION可能会使处理更简单</strong>。</p>
</li>
</ul>
<hr>
<h4 id="UNION规则"><a href="#UNION规则" class="headerlink" title="UNION规则"></a>UNION规则</h4><ul>
<li><p>UNION必须由<strong>两条或两条以上的SELECT语句组成</strong>，语句之间用关键字UNION分隔（因此，如果组合4条SELECT语句，将要使用3个UNION关键字）。</p>
</li>
<li><p>UNION中<strong>每个查询必须包含相同的列、表达式或聚集函数</strong>（不过各个列<strong>不需要以相同的次序列出</strong>）。</p>
</li>
<li><p>列数据类型必须<strong>兼容</strong>。类型不必完全相同，但必须是DBMS可以隐含地转换的类型(如<strong>不同的数值类型</strong>或<strong>不同的日期类型</strong>)。</p>
</li>
</ul>
<hr>
<h4 id="包含或取消重复的行"><a href="#包含或取消重复的行" class="headerlink" title="包含或取消重复的行"></a>包含或取消重复的行</h4><ul>
<li><p><strong>UNION从查询结果集中自动去除了重复的行</strong>（换句话说，它的行为与单条SELECT语句中使用多个WHERE子句条件一样）。</p>
</li>
<li><p>如果<strong>想返回所有匹配行</strong>，可<strong>使用UNION ALL</strong>而不是UNION。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> vend_id<span class="token punctuation">,</span> prod_id<span class="token punctuation">,</span> prod_price
<span class="token keyword">FROM</span> products
<span class="token keyword">WHERE</span> prod_price <span class="token operator">&lt;=</span> <span class="token number">5</span>
<span class="token keyword">UNION</span> <span class="token keyword">ALL</span>
<span class="token keyword">SELECT</span> vend_id<span class="token punctuation">,</span> prod_id<span class="token punctuation">,</span> prod_price
<span class="token keyword">FROM</span> products
<span class="token keyword">WHERE</span> vend id <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">1001</span><span class="token punctuation">,</span> <span class="token number">1002</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>UNION ALL为UNION的一种形式，它完成WHERE子句完成不了的工作</strong>。如果确实需要每个条件的匹配行全部出现（包括<strong>重复行</strong>），则必须使用UNION ALL而不是WHERE。</p>
</li>
</ul>
<hr>
<h4 id="对组合查询结果排序"><a href="#对组合查询结果排序" class="headerlink" title="对组合查询结果排序"></a>对组合查询结果排序</h4><ul>
<li><p>在用UNION组合查询时，只能使用一条ORDER BY子句，它必须出现在最后一条SELECT语句之后**。对于结果集，不存在用一种方式排序一部分，而又用另一种方式排序另一部分的情况，因此不允许使用多条ORDER BY子句**。</p>
  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> vend_id<span class="token punctuation">,</span> prod_id<span class="token punctuation">,</span> prod_price
<span class="token keyword">FROM</span> products
<span class="token keyword">WHERE</span> prod_price <span class="token operator">&lt;=</span> <span class="token number">5</span>
<span class="token keyword">UNION</span>
<span class="token keyword">SELECT</span> vend_id<span class="token punctuation">,</span> prod_id<span class="token punctuation">,</span> prod_price
<span class="token keyword">FROM</span> products
<span class="token keyword">WHERE</span> vend_id <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">1001</span><span class="token punctuation">,</span> <span class="token number">1002</span><span class="token punctuation">)</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> vend_id<span class="token punctuation">,</span> prod_price<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<hr>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="MySQL创建索引"><a href="#MySQL创建索引" class="headerlink" title="MySQL创建索引"></a>MySQL创建索引</h3><h4 id="索引的介绍"><a href="#索引的介绍" class="headerlink" title="索引的介绍"></a>索引的介绍</h4><p>索引是一种数据结构，例如B-Tree，这种数据结构是需要<strong>额外的写入和存储为代价</strong>来<strong>提高表上数据检索的速度</strong>。</p>
<p>其中，当使用<strong>主键或唯一键</strong>创建表时，MySQL会<strong>自动创建名为PRIMARY的特殊索引</strong>, 该索引称为<strong>聚簇索引</strong>，<strong>这个索引本身与数据一起存储在同一个表中</strong>。<strong>PRIMARY索引之外的</strong>索引称为<strong>二级索引</strong>或<strong>非聚簇索引</strong>。</p>
<hr>
<h4 id="CREATE-INDEX语句"><a href="#CREATE-INDEX语句" class="headerlink" title="CREATE INDEX语句"></a>CREATE INDEX语句</h4><ul>
<li><p>通常，<strong>创建表的时候就能为表创建索引</strong>：</p>
  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> t<span class="token punctuation">(</span>
   c1	<span class="token keyword">INT</span>		<span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
   c2	<span class="token keyword">INT</span>		<span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
   c3	<span class="token keyword">INT</span>		<span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
   c4	<span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
   <span class="token keyword">INDEX</span> <span class="token punctuation">(</span>c2<span class="token punctuation">,</span>c3<span class="token punctuation">)</span>  <span class="token comment"># 创建了由c2、c3两列组成的索引</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</li>
<li><p>要为列或一组列<strong>添加索引</strong>，可以使用<code>CREATE INDEX</code>语句：</p>
  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> index_name <span class="token keyword">ON</span> table_name <span class="token punctuation">(</span>column_list<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>默认情况下，如果<strong>未指定索引类型</strong>，MySQL将<strong>创建B-Tree索引</strong>。 以下显示了基于表的存储引擎的允许索引类型：</p>
<table>
<thead>
<tr>
<th>存储引擎</th>
<th>允许的索引类型</th>
</tr>
</thead>
<tbody><tr>
<td>InnoDB</td>
<td>BTREE</td>
</tr>
<tr>
<td>MyISAM</td>
<td>BTREE</td>
</tr>
<tr>
<td>MEMORY&#x2F;HEAP</td>
<td>HASH, BTREE</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<p><strong>举例</strong></p>
<p>查找职位为Sales Rep的员工：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> jobTitle <span class="token keyword">ON</span> employees<span class="token punctuation">(</span>jobTitle<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> employeeNumber<span class="token punctuation">,</span> lastName<span class="token punctuation">,</span> firstName
<span class="token keyword">FROM</span> employees
<span class="token keyword">WHERE</span> jobTitle <span class="token operator">=</span> <span class="token string">'Sales Rep'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h3 id="MySQL删除索引"><a href="#MySQL删除索引" class="headerlink" title="MySQL删除索引"></a>MySQL删除索引</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> index_name <span class="token keyword">ON</span> tabel_name<span class="token punctuation">;</span>

<span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">ON</span> tabel_name<span class="token punctuation">;</span> <span class="token comment"># 删除索引名为PRIMARY的主键</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<hr>
<h3 id="MySQL查询索引信息"><a href="#MySQL查询索引信息" class="headerlink" title="MySQL查询索引信息"></a>MySQL查询索引信息</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SHOW</span> INDEXES <span class="token keyword">FROM</span> employees<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>会得到一张二维表，各表列分别为：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Table</td>
<td>表名</td>
</tr>
<tr>
<td>Non_unique</td>
<td><strong>0</strong>：索引<strong>不能包括</strong>重复值<br /><strong>1</strong>：索引<strong>可以包括</strong>重复值</td>
</tr>
<tr>
<td>Key_name</td>
<td>索引名称。<strong>如果名称相同，表明属于同一个索引，而不是重复</strong>。</td>
</tr>
<tr>
<td>Seq_in_index</td>
<td>索引中的列序列号，<strong>从1开始IN</strong></td>
</tr>
<tr>
<td>Column_name</td>
<td>索引的列名</td>
</tr>
<tr>
<td>Collation</td>
<td>以什么方式存储于索引中</td>
</tr>
<tr>
<td>Cardinality</td>
<td>基数，表示索引中<strong>唯一值的数目的估计值</strong>。某个字段的<strong>重复值越少越适合建索引</strong>，所以<strong>一般根据Cardinality来判断索引是否具有高选择性</strong></td>
</tr>
<tr>
<td>Sub_part</td>
<td>如果列只是被部分地编入索引，则为被编入索引的字符的数目。<br />如果整列被编入索引，则为NULL。</td>
</tr>
<tr>
<td>Packed</td>
<td>指示关键字如何被压缩。如果没有被压缩，则为NULL。压缩一般包括压缩传输协议、压缩列解决方案和压缩表解决方案。</td>
</tr>
<tr>
<td>Null</td>
<td>如果列<strong>含有NULL，则为YES</strong></td>
</tr>
<tr>
<td>Index_type</td>
<td>索引类型，Mysql目前主要有以下几种索引类型：FULLTEXT，HASH，BTREE，RTREE。</td>
</tr>
<tr>
<td>Comment Index_comment</td>
<td>注释</td>
</tr>
</tbody></table>
<hr>
<h3 id="使用唯一索引，避免重复"><a href="#使用唯一索引，避免重复" class="headerlink" title="使用唯一索引，避免重复"></a>使用唯一索引，避免重复</h3><p>为了使一列或多列具有唯一性，通常使用PRIMARY KEY约束。，但<strong>每个表只能有一个主键</strong>。 因此，<strong>如果使多个列或多个组合列具有唯一性，则不能使用主键约束</strong>。</p>
<p>MySQL提供了另一种索引，叫做<strong>唯一索引</strong>，允许我们<strong>一个或者多个列的值具有唯一性</strong>。且<strong>每张表中可以有很多个唯一索引</strong>。</p>
<ol>
<li><p><strong>创建唯一索引</strong></p>
 <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">UNIQUE</span> <span class="token keyword">INDEX</span> index_name
<span class="token keyword">ON</span> tabel_name<span class="token punctuation">(</span>index_column_1<span class="token punctuation">,</span> index_column_1<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p><strong>添加唯一索引</strong></p>
 <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> table_name <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> index_name<span class="token punctuation">(</span> column_1<span class="token punctuation">,</span>column_2 <span class="token punctuation">)</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p> <strong>有一点值得注意:</strong><br> 与其他数据库系统不同，MySQL<strong>将NULL值视为不同的值</strong>，<strong>所以可以在唯一索引中包含很多的空值</strong>。另一个重点是<strong>UNIQUE约束不适用于InnoDB存储引擎之外的NULL值</strong>。</p>
</li>
</ol>
<hr>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>假设我们要管理应用程序中的联系人，并且还希望联系人表的每个联系人的<strong>电子邮件必须唯一</strong>，可以使用<code>CREATE TABLE</code>语句<strong>创建唯一约束</strong>来满足我们的需求：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> contacts <span class="token punctuation">(</span>
    id			<span class="token keyword">INT</span>				<span class="token keyword">AUTO_INCREMENT</span>		<span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
    first_name	<span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> 	<span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    last_name 	<span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> 	<span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    phone 		<span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span> 	<span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    email 		<span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> 	<span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    <span class="token keyword">UNIQUE</span> <span class="token keyword">Index</span> unique_email <span class="token punctuation">(</span>email<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>假设我们要一个<strong>first_name</strong>、<strong>last_name</strong>、<strong>phone</strong>的联合索引，我们可以使用下面的语法来得到：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">UNIQUE</span> <span class="token keyword">INDEX</span> idx_name_phone
<span class="token keyword">ON</span> contacts<span class="token punctuation">(</span>first_name<span class="token punctuation">,</span>last_name<span class="token punctuation">,</span> phone<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<hr>
<h3 id="索引的使用场景"><a href="#索引的使用场景" class="headerlink" title="索引的使用场景"></a>索引的使用场景</h3><ol>
<li>主键(PRIMARY KEY)<strong>自动建立唯一索引</strong></li>
<li>存在<strong>频繁作为查询条件的字段</strong>，应该创建索引</li>
<li>查询中与其他表关联的字段，<strong>外键关系建立索引</strong></li>
<li><strong>频繁更新</strong>的字段<strong>不适合建立索引</strong>，因为每次更新不单单时更新了记录还会更新索引</li>
<li>WHERE条件里<strong>用不到的字段不创建索引</strong></li>
<li>查询中排序的字段，<strong>排序的字段若通过索引去访问将会大大提高排序速度</strong></li>
<li>查询中<strong>统计或者分组的字段</strong></li>
</ol>
<hr>
<h3 id="强制索引"><a href="#强制索引" class="headerlink" title="强制索引"></a>强制索引</h3><p><strong>FORCE INDEX</strong>：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> 
<span class="token keyword">FROM</span> salaries 
<span class="token keyword">FORCE</span> <span class="token keyword">INDEX</span> idx_emp_no <span class="token comment">-- idx_emp_no 是预设的索引</span>
<span class="token keyword">WHERE</span> emp_no <span class="token operator">=</span> <span class="token number">10005</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<hr>
<h2 id="第18章-全文本搜索"><a href="#第18章-全文本搜索" class="headerlink" title="第18章 全文本搜索"></a>第18章 全文本搜索</h2><h3 id="理解全文本搜索"><a href="#理解全文本搜索" class="headerlink" title="理解全文本搜索"></a>理解全文本搜索</h3><p>MySQL支持几种<strong>基本的数据库引擎</strong>。<strong>并非所有的引擎都支持本书所描述的全文本搜索</strong>。两个最常使用的引擎为<strong>MyISAM</strong>和<strong>InnoDB</strong>，<strong>前者支持全文本搜索，而后者不支持</strong>。</p>
<p><strong>第8章和第9章介绍LIKE和正则表达式的搜索机制，存在几个重要的限制</strong>：</p>
<ul>
<li><p><strong>性能</strong></p>
<p>  <strong>通配符</strong>和<strong>正则表达式匹配</strong>通常要求MySQL尝试<strong>匹配表中所有行</strong>（而且这些搜索<strong>极少使用表索引</strong>）。因此，<strong>由于被搜索行数不断增加，这些搜索可能非常耗时</strong>。</p>
</li>
<li><p><strong>明确控制</strong></p>
<p>  使用通配符和正则表达式匹配，<strong>很难（而且并不总是能）明确地控制匹配什么和不匹配什么</strong>。例如，指定一个词必须匹配，一个词必须不匹配，而一个词仅在第一个词确实匹配的情况下才可以匹配或者才可以不匹配。</p>
</li>
<li><p>智能化的结果</p>
<p>  虽然基于通配符和正则表达式的搜索提供了非常灵活的搜索，但它们都<strong>不能提供一种智能化的选择结果的方法</strong>。例如，一个特殊词的搜索将会返回包含该词的所有行，而<strong>不区分包含单个匹配的行和包含多个匹配的行</strong>。</p>
</li>
</ul>
<p>以上的限制都可以<strong>通过全文本搜索来解决</strong>。在使用全文本搜索时，<strong>MySQL不需要分别查看每个行，不需要分别分析和处理每个词</strong>。MySQL<strong>创建指定列中各词的一个索引</strong>，<strong>搜索可以针对这些词进行</strong>。这样，MySQL可以快速有效地决定哪些词匹配（哪些行包含它们），哪些词不匹配，它们匹配的频率，等等。</p>
<hr>
<h3 id="使用全文本搜索"><a href="#使用全文本搜索" class="headerlink" title="使用全文本搜索"></a>使用全文本搜索</h3><p>为了进行全文本搜索，<strong>必须索引被搜索的列</strong>，而且<strong>要随着数据的改变不断地重新索引</strong>。<strong>在对表列进行适当设计后，MySQL会自动进行所有的索引和重新索引</strong>。</p>
<h4 id="启用全文本搜索支持"><a href="#启用全文本搜索支持" class="headerlink" title="启用全文本搜索支持"></a>启用全文本搜索支持</h4><p>一般<strong>在创建表时启用全文本搜索</strong>。<code>CREATE TABLE</code>语句（第21章中介绍）接受<code>FULLTEXT</code>子句，它<strong>给出被索引列的一个逗号分隔的列表</strong>。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> productnotes<span class="token punctuation">(</span>
	note_id		<span class="token keyword">int</span>			<span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
    prod_id		<span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>	<span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    note_date	<span class="token keyword">datetime</span>	<span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    note_text	<span class="token keyword">text</span>		<span class="token boolean">NULL</span><span class="token punctuation">,</span>
    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>note_id<span class="token punctuation">)</span><span class="token punctuation">,</span>
    FULLTEXT<span class="token punctuation">(</span>note_text<span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span>MyISAM<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p><code>FULLTEXT</code><strong>可以索引多个列</strong></p>
</li>
<li><p>在定义之后，MySQL<strong>自动维护该索引</strong>。<strong>在增加、更新或删除行时，索引随之自动更新</strong>。</p>
</li>
<li><p>可以在创建表时指定FULLTEXT，或者<strong>在稍后指定（在这种情况下所有已有数据必须立即索引）</strong>。</p>
</li>
</ul>
<p><strong>不要在导入数据时使用FULLTEXT</strong></p>
<p>​	如果<strong>正在导入数据</strong>到一个新表，此时<strong>不应该启用FULLTEXT索引</strong>。应该<strong>先导入所有数据，再修改表，定义FULLTEXT</strong>。这样有助于更快地导入数据(而且使索引数据的总时间小于在导入每行时分别进行索引所需的总时间)。</p>
<hr>
<h4 id="进行全文本搜索"><a href="#进行全文本搜索" class="headerlink" title="进行全文本搜索"></a>进行全文本搜索</h4><p>在索引之后，使用两个函数<code>Match()</code>和<code>Against()</code>执行全文本搜索，其中<code>Match()</code><strong>指定被搜索的列</strong>，<code>Against()</code><strong>指定要使用的搜索表达式</strong>。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> note_text
<span class="token keyword">FROM</span> productnotes
<span class="token keyword">WHERE</span> <span class="token keyword">Match</span><span class="token punctuation">(</span>note_text<span class="token punctuation">)</span> Against<span class="token punctuation">(</span><span class="token string">'rabbit'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>此SELECT语句检索单个列<code>note_text</code>。由于WHERE子句，一个全文本搜索被执行。</p>
</li>
<li><p>传递给<code>Match()</code>的值必须与<code>FULLTEXT()</code>定义中的相同。<strong>如果指定多个列，则必须列出它们（而且次序正确）</strong>。</p>
</li>
<li><p>除非使用<strong>BINARY</strong>方式（本章中没有介绍），否则<strong>全文本搜索不区分大小写</strong>。</p>
</li>
</ul>
<p>上述搜索也可以简单地用LIKE子句完成：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> note_text
<span class="token keyword">FROM</span> productnotes
<span class="token keyword">WHERE</span> note_text <span class="token operator">LIKE</span> <span class="token string">'%rabbit%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>两种方式都没有使用ORDER BY子句。<strong>LIKE子句以不特别有用的顺序返回数据</strong>；而<strong>使用全文本搜索</strong>会返回<strong>以文本匹配的良好程度排序</strong>的数(<strong>搜索的内容出现的位置越靠前，等级越高</strong>)，<strong>全文本搜索的一个重要部分就是对结果排序</strong>。</p>
<ul>
<li>由于<strong>数据是索引的，全文本搜索还相当快</strong>。</li>
</ul>
<hr>
<h4 id="使用查询扩展-QUERY-EXPANSION"><a href="#使用查询扩展-QUERY-EXPANSION" class="headerlink" title="使用查询扩展(QUERY EXPANSION)"></a>使用查询扩展(QUERY EXPANSION)</h4><p>查询扩展用来设法<strong>放宽所返回的全文本搜索结果的范围</strong>。</p>
<p>如下情况：你想<strong>找出所有提到anvils的注释</strong>，但<strong>还想找出可能与你的搜索有关的所有其他行，即使它们不包含词anvils</strong>。</p>
<p>在使用查询扩展时，MySQL<strong>对数据和索引进行两遍扫描</strong>来完成搜索：</p>
<ul>
<li>首先，进行一个<strong>基本的全文本搜索</strong>，找出<strong>与搜索条件匹配的</strong>所有行</li>
<li>其次，MySQL<strong>检查这些匹配行并选择所有有用的词</strong>（我们将会简要地解释MySQL如何断定什么有用，什么无用）。</li>
<li>再其次，MySQL<strong>再次进行全文本搜索</strong>，这次<strong>不仅使用原来的条件，而且还使用所有有用的词</strong>。</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> note_text
<span class="token keyword">FROM</span> productnotes
<span class="token keyword">WHERE</span> <span class="token keyword">Match</span><span class="token punctuation">(</span>note_text<span class="token punctuation">)</span> Against<span class="token punctuation">(</span><span class="token string">'anvils'</span> <span class="token keyword">WITH</span> QUERY EXPANSION<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>表中的行越多（这些行中的文本就越多），使用查询扩展返回的结果越好</strong>。</p>
<hr>
<h4 id="布尔文本搜索"><a href="#布尔文本搜索" class="headerlink" title="布尔文本搜索"></a>布尔文本搜索</h4><p>MySQL支持<strong>全文本搜索的另外一种形式</strong>，称为<strong>布尔方式（BOOLEAN MODE）</strong>。以布尔方式，可以提供关于如下内容的细节：</p>
<ol>
<li>要匹配的词；</li>
<li>要排斥的词（如果某行包含这个词，则不返回该行，即使它包含其他指定的词也是如此）；</li>
<li>排列提示（指定某些词比其他词更重要，更重要的词等级更高）;</li>
<li>表达式分组；</li>
<li>另外一些内容。</li>
</ol>
<ul>
<li><strong>即使没有定义FULLTEXT索引，也可以使用它</strong>。但<strong>这是一种非常缓慢的操作</strong>（其性能将随着数据量的增加而降低）。</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> note_text
<span class="token keyword">FROM</span> productnotes
<span class="token keyword">WHERE</span> <span class="token keyword">Match</span><span class="token punctuation">(</span>note_text<span class="token punctuation">)</span> Against<span class="token punctuation">(</span><span class="token string">'heavy'</span> <span class="token operator">IN</span> <span class="token keyword">BOOLEAN</span> <span class="token keyword">MODE</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>此全文本搜索检索包含词heavy的所有行。使用了<code>IN BOOLEAN MODE</code>，但没有指定布尔操作符，因此结果与没有指定布尔方式的操作相同。</p>
<ul>
<li><p>为了匹配包含heavy但<strong>不包含</strong> <strong>任意以rope开始的词</strong>的行，可使用以下查询：</p>
  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> note_text
<span class="token keyword">FROM</span> productnotes
<span class="token keyword">WHERE</span> <span class="token keyword">Match</span><span class="token punctuation">(</span>note_text<span class="token punctuation">)</span> Against<span class="token punctuation">(</span><span class="token string">'heavy -rope*'</span> <span class="token operator">IN</span> <span class="token keyword">BOOLEAN</span> <span class="token keyword">MODE</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ul>
<p><strong>全文本布尔操作符</strong>：</p>
<table>
<thead>
<tr>
<th>布尔操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td>包含，词<strong>必须存在</strong></td>
</tr>
<tr>
<td><code>-</code></td>
<td>排除，词<strong>必须不出现</strong></td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>包含，且<strong>增加等级值</strong></td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>包含，且<strong>减少等级值</strong></td>
</tr>
<tr>
<td><code>()</code></td>
<td>把词组成子表达式（允许这些子表达式作为一个组被包含、排除、排列等）</td>
</tr>
<tr>
<td><code>~</code></td>
<td><strong>取消</strong>一个词的<strong>排序值</strong></td>
</tr>
<tr>
<td><code>*</code></td>
<td><strong>词尾</strong>的<strong>通配符</strong></td>
</tr>
<tr>
<td><code>&quot;&quot;</code></td>
<td>定义一个<strong>短语</strong>(匹配一个短语，以便包含或排除这个短语)</td>
</tr>
</tbody></table>
<p>例1：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> note_text
<span class="token keyword">FROM</span> productnotes
<span class="token keyword">WHERE</span> <span class="token keyword">Match</span><span class="token punctuation">(</span>note_text<span class="token punctuation">)</span> Against<span class="token punctuation">(</span><span class="token string">'+rabbit +bait'</span> <span class="token operator">IN</span> <span class="token keyword">BOOLEAN</span> <span class="token keyword">MODE</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># 匹配包含词rabbit和bait的行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>例2：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> note_text
<span class="token keyword">FROM</span> productnotes
<span class="token keyword">WHERE</span> <span class="token keyword">Match</span><span class="token punctuation">(</span>note_text<span class="token punctuation">)</span> Against<span class="token punctuation">(</span><span class="token string">'rabbit bait'</span> <span class="token operator">IN</span> <span class="token keyword">BOOLEAN</span> <span class="token keyword">MODE</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># 匹配包含词rabbit和bait中至少一个词的行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>例3：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> note_text
<span class="token keyword">FROM</span> productnotes
<span class="token keyword">WHERE</span> <span class="token keyword">Match</span><span class="token punctuation">(</span>note_text<span class="token punctuation">)</span> Against<span class="token punctuation">(</span><span class="token string">'"rabbit bait"'</span> <span class="token operator">IN</span> <span class="token keyword">BOOLEAN</span> <span class="token keyword">MODE</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># 匹配短语rabbit bait</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>例4：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> note_text
<span class="token keyword">FROM</span> productnotes
<span class="token keyword">WHERE</span> <span class="token keyword">Match</span><span class="token punctuation">(</span>note_text<span class="token punctuation">)</span> Against<span class="token punctuation">(</span><span class="token string">'>rabbit &lt;bait"'</span> <span class="token operator">IN</span> <span class="token keyword">BOOLEAN</span> <span class="token keyword">MODE</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># 匹配包含词rabbit和bait的行，增加前者等级，降低后者等级</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>例5：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> note_text
<span class="token keyword">FROM</span> productnotes
<span class="token keyword">WHERE</span> <span class="token keyword">Match</span><span class="token punctuation">(</span>note_text<span class="token punctuation">)</span> Against<span class="token punctuation">(</span><span class="token string">'+safe +(&lt;combination)'</span> <span class="token operator">IN</span> <span class="token keyword">BOOLEAN</span> <span class="token keyword">MODE</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># 匹配词safe和combination的行，且降低后者的等级</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>在布尔方式中，不按等级值降序排序返回的行。</strong></p>
<hr>
<h4 id="全文本搜索的使用说明"><a href="#全文本搜索的使用说明" class="headerlink" title="全文本搜索的使用说明"></a>全文本搜索的使用说明</h4><ol>
<li>索引全文本数据时，<strong>短词会被忽略且从索引中排除</strong>。(短词：只有<strong>3个及以下字符</strong>的词，如果需要，这个数目可以更改)</li>
<li>MySQL带有一个<strong>内建的非用词（stopword）列表</strong>，这些词<strong>在索引全文本数据时总是被忽略</strong>。如果需要，可以覆盖这个列表（请参阅MySQL文档以了解如何完成此工作）</li>
<li>许多词出现的频率很高，搜索它们没有用处（返回太多的结果）。因此，MySQL规定了一条<strong>50%规则</strong>，如果<strong>一个词出现在50%以上的行中，则将它作为一个非用词忽略</strong>。<strong>50%规则不用于IN BOOLEAN MODE</strong>。</li>
<li>如果表中的<strong>行数少于3行</strong>，则全文本搜索<strong>不返回结果</strong>（因为每个词或者不出现，或者至少出现在50%的行中）。</li>
<li><strong>忽略</strong>词中的<strong>单引号</strong>。例如，<strong>don’t索引为dont</strong>。</li>
<li><strong>不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文本搜索结果</strong>。</li>
<li>如前所述，仅在<strong>MyISAM数据库引擎</strong>中<strong>支持全文本搜索</strong></li>
</ol>
<hr>
<h2 id="SQL语句的查询顺序"><a href="#SQL语句的查询顺序" class="headerlink" title="SQL语句的查询顺序"></a>SQL语句的查询顺序</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> <span class="token keyword">column</span><span class="token punctuation">,</span> AGG_FUNC<span class="token punctuation">(</span>column_or_expression<span class="token punctuation">)</span><span class="token punctuation">,</span> …
<span class="token keyword">FROM</span> mytable <span class="token keyword">JOIN</span> another_table
<span class="token keyword">ON</span> mytable<span class="token punctuation">.</span><span class="token keyword">column</span> <span class="token operator">=</span> another_table<span class="token punctuation">.</span><span class="token keyword">column</span>
<span class="token keyword">WHERE</span> constraint_expression
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token keyword">column</span>
<span class="token keyword">HAVING</span> constraint_expression
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token keyword">column</span> <span class="token keyword">ASC</span><span class="token operator">/</span><span class="token keyword">DESC</span>
<span class="token keyword">LIMIT</span> count <span class="token keyword">OFFSET</span> COUNT<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<table>
<thead>
<tr>
<th>执行顺序</th>
<th>语句</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>FROM、JOIN</td>
<td><strong>获取数据集</strong></td>
</tr>
<tr>
<td>2</td>
<td>WHERE</td>
<td>过滤数据</td>
</tr>
<tr>
<td>3</td>
<td>GROUP BY</td>
<td>根据某一字段进行分组，并<strong>对各个组进行求聚合</strong></td>
</tr>
<tr>
<td>4</td>
<td>HAVING</td>
<td>过滤<strong>聚合后的</strong>数据</td>
</tr>
<tr>
<td>5</td>
<td>SELECT</td>
<td>返回最终数据</td>
</tr>
<tr>
<td>6</td>
<td>DISTINCT</td>
<td>为最终数据去重</td>
</tr>
<tr>
<td>7</td>
<td>ORDER BY</td>
<td>为最终数据排序</td>
</tr>
<tr>
<td>8</td>
<td>LIMIT&#x2F;OFFSET</td>
<td>限定最终数据的返回行，也可理解为<strong>分页查询</strong><br />（如：<code>LIMIT 4 OFFSET 3</code>意为<strong>从行3开始取4行</strong>）</td>
</tr>
</tbody></table>
<hr>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 观察这种写法的问题</span>
<span class="token keyword">SELECT</span> country<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>area<span class="token punctuation">)</span> 
<span class="token keyword">FROM</span> country_data
<span class="token keyword">WHERE</span> <span class="token function">SUM</span><span class="token punctuation">(</span>area<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1000</span> <span class="token comment"># GROUP BY还没执行，无法获取聚合值</span>
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> country<span class="token punctuation">;</span>

<span class="token comment"># 正确的写法</span>
<span class="token keyword">SELECT</span> country<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>area<span class="token punctuation">)</span> 
<span class="token keyword">FROM</span> country_data
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> country
<span class="token keyword">HAVING</span> <span class="token function">SUM</span><span class="token punctuation">(</span>area<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h2 id="CASE语句"><a href="#CASE语句" class="headerlink" title="CASE语句"></a>CASE语句</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CASE</span>
    <span class="token keyword">WHEN</span> condition1 <span class="token keyword">THEN</span> result1
    <span class="token keyword">WHEN</span> condition2 <span class="token keyword">THEN</span> result2
    <span class="token keyword">WHEN</span> conditionN <span class="token keyword">THEN</span> resultN
    <span class="token keyword">ELSE</span> result
<span class="token keyword">END</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>例子：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> salary
<span class="token keyword">SET</span> sex <span class="token operator">=</span>  <span class="token keyword">CASE</span> 
				<span class="token keyword">WHEN</span> sex <span class="token operator">=</span> <span class="token string">'m'</span> <span class="token keyword">THEN</span> <span class="token string">'f'</span>
                <span class="token keyword">WHEN</span> sex <span class="token operator">=</span> <span class="token string">'f'</span> <span class="token keyword">THEN</span> <span class="token string">'m'</span>
           <span class="token keyword">END</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>作用和IF表达式相当</strong>。</p>
<hr>
<h2 id="第19章-插入数据"><a href="#第19章-插入数据" class="headerlink" title="第19章 插入数据"></a>第19章 插入数据</h2><h3 id="数据插入"><a href="#数据插入" class="headerlink" title="数据插入"></a>数据插入</h3><ul>
<li><strong>INSERT语句</strong>用来插入行到数据库表。插入可以用几种方式使用：<ul>
<li>插入完整的行</li>
<li>插入行的一部分</li>
<li>插入多行</li>
<li>插入某些查询的结果</li>
</ul>
</li>
</ul>
<hr>
<h3 id="插入完整的行"><a href="#插入完整的行" class="headerlink" title="插入完整的行"></a>插入完整的行</h3><ul>
<li><p>INSERT语句<strong>要求指定表名</strong>和<strong>被插入到新行中的值</strong>。如：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> customers
<span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token boolean">NULL</span><span class="token punctuation">,</span>
      <span class="token string">'Pep E. LaPew'</span><span class="token punctuation">,</span>
       <span class="token string">'100 Main Street'</span><span class="token punctuation">,</span>
       <span class="token string">'Los Angeles'</span><span class="token punctuation">,</span>
       <span class="token string">'CA'</span><span class="token punctuation">,</span>
       <span class="token string">'90046'</span><span class="token punctuation">,</span>
       <span class="token string">'USA'</span><span class="token punctuation">,</span>
       <span class="token boolean">NULL</span><span class="token punctuation">,</span>
       <span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>存储到每个表列中的数据在<strong>VALUES子句</strong>中给出，对<strong>每个列必须提供一个值</strong>，<strong>各个列必须以在表定义中出现的次序填充</strong>。如果某个列没有值，应该使用NULL值（假定表允许对该列指定空值）。<strong>第一列cust_id也为NULL(每次插入一个新行时，该列由MySQL自动增量，NULL值会被MySQL忽略)</strong>。</p>
<p>虽然这种语法很简单，但<strong>并不安全，应该尽量避免使用</strong>。上面的SQL语句高度依赖于表中列的定义次序。即使可得到这种次序信息，也不能保证下一次表结构变动后各个列保持完全相同的次序。</p>
</li>
<li><p>INSERT语句一般<strong>不会产生输出</strong>。</p>
</li>
<li><p>一般<strong>不要使用没有明确给出列的列表的INSERT语句</strong>。使用列的列表能使SQL代码继续发挥作用，即使表结构发生了变化。</p>
</li>
<li><p>不管使用哪种INSERT语法，都必须给出VALUES的正确数目</p>
<ul>
<li>如果<strong>不提供列名</strong>，则必须给每个表列提供一个值</li>
<li>如果<strong>提供列名</strong>，则必须对<strong>每个列出的列</strong>提供一个值</li>
</ul>
</li>
<li><p>省略的列必须满足以下某个条件。</p>
<ol>
<li>该<strong>列</strong>定义为<strong>允许NULL值</strong>。</li>
<li>在<strong>表定义中给出默认值</strong>。这表示如果不给出值，将使用默认值。</li>
</ol>
<p>如果对表中不允许NULL值且没有默认值的列不给出值，则MySQL将产生一条错误消息，并且相应的行插入不成功。</p>
</li>
<li><p><strong>INSERT操作可能很耗时，而且可能降低等待处理的SELECT语句的性能</strong>。如果<strong>数据检索是最重要的</strong>（通常是这样），则你可以通过<strong>在INSERT和INTO之间添加关键字LOW_PRIORITY，指示MySQL降低INSERT语句的优先级</strong>，如下所示：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> LOW PRIORITY <span class="token keyword">INTO</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这<strong>也适用于</strong>下一章介绍的<strong>UPDATE和DELETE语句</strong>。</p>
</li>
</ul>
<hr>
<h3 id="插入多个行"><a href="#插入多个行" class="headerlink" title="插入多个行"></a>插入多个行</h3><ul>
<li><p>如果想<strong>插入多个行</strong>：</p>
<ol>
<li><p>可以使用<strong>多条INSERT语句</strong>，甚至<strong>一次提交</strong>它们，<strong>每条语句用一个分号结束</strong>。</p>
</li>
<li><p>只<strong>要每条INSERT语句中的列名(和次序)相同</strong>，可以用<strong>单条INSERT语句</strong>插入多组值，<strong>每组值用一对圆括号括起来，用逗号分隔</strong>。如下：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> customers<span class="token punctuation">(</span>cust_name<span class="token punctuation">,</span>
                     cust_address<span class="token punctuation">,</span>
                     cust_city<span class="token punctuation">,</span>
                     cust_state<span class="token punctuation">,</span>
                     cust_zip<span class="token punctuation">,</span>
                     cust_country<span class="token punctuation">)</span>
<span class="token keyword">VALUES</span><span class="token punctuation">(</span>
		<span class="token string">'Pep E. LaPew'</span><span class="token punctuation">,</span>
    	<span class="token string">'100 Main Street'</span><span class="token punctuation">,</span>
    	<span class="token string">'Los Angeles'</span><span class="token punctuation">,</span>
    	<span class="token string">'CA'</span><span class="token punctuation">,</span>
    	<span class="token string">'90046'</span><span class="token punctuation">,</span>
    	<span class="token string">'USA'</span>
	<span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">(</span>
    	<span class="token string">'M. Martian'</span><span class="token punctuation">,</span>
        <span class="token string">'42 Galaxy Way'</span><span class="token punctuation">,</span>
        <span class="token string">'New York'</span><span class="token punctuation">,</span>
        <span class="token string">'NY'</span><span class="token punctuation">,</span>
        <span class="token string">'11213'</span><span class="token punctuation">,</span>
        <span class="token string">'USA'</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
</li>
<li><p><strong>单条INSERT语句处理多个插入比使用多条INSERT语句快</strong>。</p>
</li>
</ul>
<hr>
<h3 id="插入检索出的数据"><a href="#插入检索出的数据" class="headerlink" title="插入检索出的数据"></a>插入检索出的数据</h3><ul>
<li><p>INSERT还存在另一种形式，可以利用它<strong>将一条SELECT语句的结果插入表中</strong>。这就是所谓的<strong>INSERT SELECT</strong>。</p>
<p>假如你想<strong>从另一表中合并客户列表到你的customers表</strong>，可以如下进行：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> customers<span class="token punctuation">(</span>cust_id<span class="token punctuation">,</span>
                      cust_contact<span class="token punctuation">,</span>
                      cust_email<span class="token punctuation">,</span>
                      cust_name<span class="token punctuation">)</span>
<span class="token keyword">SELECT</span> cust_id<span class="token punctuation">,</span>
		cust_contact<span class="token punctuation">,</span>
		cust_email<span class="token punctuation">,</span>
		cust_name
<span class="token keyword">FROM</span> custnew<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>MySQL甚至不关心SELECT返回的列名。它使用的是列的位置，因此SELECT中的第一列（不管其列名）将用来填充表列中指定的第一个列，第二列将用来填充表列中指定的第二个列，如此等等</p>
</li>
<li><p><strong>如果目标表不存在，插入数据的方式</strong>：</p>
  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> value1<span class="token punctuation">,</span> value2
<span class="token keyword">INTO</span> table2 <span class="token comment"># 目标表table2不存在，因此插入的时候自动创建目标表</span>
<span class="token keyword">FROM</span> table1<span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ul>
<hr>
<h2 id="第20章-更新和删除数据"><a href="#第20章-更新和删除数据" class="headerlink" title="第20章 更新和删除数据"></a>第20章 更新和删除数据</h2><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><ul>
<li><p>为了更新(修改)表中的数据，可使用UPDATE语句。可采用两种方式使用UPDATE：</p>
<ol>
<li>更新表中<strong>特定行</strong></li>
<li>更新表中<strong>所有行</strong></li>
</ol>
</li>
<li><p>基本的UPDATE语句由3部分组成</p>
<ol>
<li>要更新的表</li>
<li>列名和它们的新值</li>
<li>确定要更新行的<strong>过滤条件</strong></li>
</ol>
<p>例如，客户10005现在有了电子邮件地址，需要更新记录：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> customers
<span class="token keyword">SET</span> cust_email <span class="token operator">=</span> <span class="token string">'elmer@fudd.com'</span>
<span class="token keyword">WHERE</span> cust_id <span class="token operator">=</span> <span class="token number">10005</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>SET命令用来将新值赋给被更新的列</strong>。</p>
</li>
<li><p>UPDATE语句以WHERE子句结束，它告诉MySQL更新哪一行。<strong>没有WHERE子句</strong>，MySQL将会<strong>更新customers表中所有行</strong>。</p>
</li>
<li><p>更新多个列的语法稍有不同：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> customers
<span class="token keyword">SET</span> cust_name <span class="token operator">=</span> <span class="token string">'The Fudds'</span><span class="token punctuation">,</span>
	cust_email <span class="token operator">=</span> <span class="token string">'elmer@fudd.com'</span>
<span class="token keyword">WHERE</span> cust id <span class="token operator">=</span> <span class="token number">10005</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>更新多个列只需使用单个SET命令</strong>，<strong>每个“列&#x3D;值”对之间用逗号分隔</strong>。</p>
</li>
<li><p>UPDATE语句中可以使用<strong>子查询</strong>。</p>
</li>
<li><p><strong>IGNORE关键字</strong></p>
<p>如果用UPDATE语句<strong>更新多行</strong>，并且这些行中的一行或者多行<strong>出现一个错误，整个UPDATE操作会被取消</strong>。如果<strong>希望即使发生错误也继续更新</strong>，可使用<strong>IGNORE关键字</strong>：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> <span class="token keyword">IGNORE</span> customers <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>为了<strong>删除某个列的值，可设置其为NULL</strong>(前提表定义允许NULL值)。如：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> customers
<span class="token keyword">SET</span> cust_email <span class="token operator">=</span> <span class="token boolean">NULL</span>
<span class="token keyword">WHERE</span> cust_id <span class="token operator">=</span> <span class="token number">10005</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><h5 id="用一张表的记录去更新另一张表的记录"><a href="#用一张表的记录去更新另一张表的记录" class="headerlink" title="用一张表的记录去更新另一张表的记录"></a>用一张表的记录去更新另一张表的记录</h5>  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span> A
<span class="token keyword">SET</span> A<span class="token punctuation">.</span>Name <span class="token operator">=</span> B<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> 
	A<span class="token punctuation">.</span>Sex <span class="token operator">=</span> B<span class="token punctuation">.</span>Sex
<span class="token keyword">FROM</span> A<span class="token punctuation">,</span>B
<span class="token keyword">WHERE</span> A<span class="token punctuation">.</span>ID <span class="token operator">=</span> B<span class="token punctuation">.</span>ID<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<hr>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><ul>
<li><p>为了从一个表中<strong>删除数据</strong>，使用<strong>DELETE语句</strong>。可以通过两种方式使用DELETE：</p>
<ol>
<li>从表中删除<strong>特定的行</strong></li>
<li>从表中删除<strong>所有行</strong></li>
</ol>
</li>
<li><p>DELETE语句以WHERE子句结束，它告诉MySQL删除哪一行。<strong>没有WHERE子句</strong>，MySQL将会<strong>删除表中所有行</strong>。</p>
</li>
<li><p>DELETE<strong>不需要列名或通配符</strong>。DELETE<strong>删除整行</strong>而不是删除列。<strong>为了删除指定的列，请使用UPDATE语句</strong>。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> customers
<span class="token keyword">WHERE</span> cust_id <span class="token operator">=</span> <span class="token number">10006</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>DELETE<strong>不删除表本身</strong>。</p>
</li>
<li><p><strong>更快的删除</strong></p>
<p>ruu过<strong>想删除表中所有行，不要使用DELETE</strong>。可使用<strong>TRUNCATE TABLE语句</strong>，<strong>它完成相同的工作，但速度更快</strong>（<strong>TRUNCATE实际是删除原来的表并重新创建一个表，而不是逐行删除表中的数据</strong>）。</p>
</li>
</ul>
<hr>
<h3 id="更新和删除的指导原则"><a href="#更新和删除的指导原则" class="headerlink" title="更新和删除的指导原则"></a>更新和删除的指导原则</h3><ul>
<li>除非确实打算更新和删除每一行，否则<strong>一定要带WHERE子句</strong></li>
<li><strong>保证每个表都有主键</strong>，从而能通过WHERE子句指定唯一的列。</li>
<li>在对UPDATE或DELETE语句<strong>使用WHERE子句前，应该先用SELECT进行测试，保证它过滤的是正确的记录，以防编写的WHERE子句不正确</strong>。、</li>
<li>使用<strong>强制实施引用完整性的数据库</strong>（15章），这样MySQL<strong>将不允许删除具有与其他表相关联的数据的行</strong>。</li>
<li><strong>MySQL没有撤销（undo）按钮</strong>。应该非常小心地使用UPDATE和DELETE，否则你会发现自己更新或删除了错误的数据。</li>
</ul>
<hr>
<h2 id="第21章-创建和操纵表"><a href="#第21章-创建和操纵表" class="headerlink" title="第21章 创建和操纵表"></a>第21章 创建和操纵表</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><ul>
<li>为了用程序创建表，可使用SQL的<strong>CREATE TABLE语句</strong>。</li>
</ul>
<h4 id="表创建基础"><a href="#表创建基础" class="headerlink" title="表创建基础"></a>表创建基础</h4><ul>
<li><p>为利用CREATE TABLE创建表，必须给出下列信息：</p>
<ul>
<li><strong>新表的名字</strong>，在<strong>关键字CREATE TABLE之后</strong>给出；</li>
<li>表<strong>列的名字和定义</strong>在<strong>圆括号之中</strong>，各列之间<strong>用逗号分隔</strong>；</li>
<li><strong>每列的定义</strong>以<strong>列名开始</strong>，后跟<strong>列的数据类型</strong>。</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> customers
<span class="token punctuation">(</span>
	cust_id			<span class="token keyword">int</span>			<span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
    cust_name		<span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span>	<span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    cust_address	<span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span>	<span class="token boolean">NULL</span><span class="token punctuation">,</span>
    cust_city		<span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span>	<span class="token boolean">NULL</span><span class="token punctuation">,</span>
    cust_state		<span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>		<span class="token boolean">NULL</span><span class="token punctuation">,</span>
    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>cust_id<span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>表的<strong>主键</strong>可以<strong>在创建表时用PRIMARY KEY关键字指定</strong>。这里，列cust_id指定作为主键列。<strong>整条语句由右圆括号后的分号结束</strong>。</p>
</li>
<li><p><strong>语句格式化</strong></p>
<p>MySQL语句中忽略空格。语句可以在一个长行上输入，也可以分成许多行。它们的作用都相同。<strong>对列定义进行恰当的缩进，以便阅读和编辑</strong>。</p>
</li>
<li><p><strong>创建新表时，指定的表名必须不存在</strong>，否则将出错。<strong>如果要防止意外覆盖已有的表，SQL要求首先手工删除该表</strong>（请参阅后面的小节），<strong>然后再重建它</strong>，而不是简单地用创建表语句覆盖它。<strong>如果仅想在一个表不存在时创建它，应该在表名后给出IF NOT EXISTS</strong>(<strong>并不检查已有表的模式是否与打算创建的表模式相匹配，只是查看表名是否存在</strong>，并且仅在表名不存在时创建它)。</p>
</li>
</ul>
<hr>
<h4 id="使用NULL值"><a href="#使用NULL值" class="headerlink" title="使用NULL值"></a>使用NULL值</h4><ul>
<li><p>每个表列或者是NULL列，或者是NOT NULL列，<strong>这种状态在创建时由表的定义规定</strong>。</p>
</li>
<li><p><strong>NULL为默认设置</strong>，<strong>如果不指定NOT NULL，则认为指定的是NULL</strong>。</p>
</li>
<li><p>进行查询时可通过<code>WHERE XXX IS NULL</code>或<code>WHERE XXX IS NOT NULL</code>进行筛选。</p>
</li>
</ul>
<hr>
<h4 id="主键再介绍"><a href="#主键再介绍" class="headerlink" title="主键再介绍"></a>主键再介绍</h4><ul>
<li><p><strong>主键值必须唯一</strong>。如果主键<strong>使用单个列</strong>，则<strong>它的值必须唯一</strong>；如果<strong>使用多个列</strong>，则<strong>这些列的组合值必须唯一</strong>。</p>
</li>
<li><p>为创建由<strong>多个列组成的主键</strong>，应该<strong>以逗号分隔的列表给出各列名</strong>。如：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> orderitems
<span class="token punctuation">(</span>
    order_num	<span class="token keyword">int</span>				<span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    order_item	<span class="token keyword">int</span>				<span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    prod_id		<span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>		<span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    quantity	<span class="token keyword">int</span>				<span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    item_price	<span class="token keyword">decimal</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>	<span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>order_num<span class="token punctuation">,</span> order_item<span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">InnoDB</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>订单号（order_num列）和订单物品（order_item列）的组合是唯一的，从而适合作为主键</strong>。</p>
</li>
<li><p>主键可以<strong>在创建表时定义</strong>，或者<strong>在创建表之后定义</strong>。<strong>主键只能使用NOT NULL值的列</strong>，因为允许NULL值的列不能作为唯一标识。</p>
</li>
</ul>
<hr>
<h4 id="使用AUTO-INCREMENT"><a href="#使用AUTO-INCREMENT" class="headerlink" title="使用AUTO_INCREMENT"></a>使用AUTO_INCREMENT</h4><ul>
<li><p><strong>AUTO_INCREMENT</strong>告诉MySQL，<strong>本列每当增加一行时自动增量</strong>。每次执行一个<strong>INSERT操作</strong>时，MySQL<strong>自动对该列增量</strong>，赋予一下一个可用的值。这样能使得每个行被分配一个唯一的值，可以作为主键值。</p>
</li>
<li><p><strong>每个表只允许一个AUTO_INCREMENT列</strong>，<strong>而且它必须被索引</strong>（如，通过使它<strong>成为主键</strong>）。</p>
</li>
<li><p><strong>覆盖AUTO_INCREMENT</strong> </p>
<p>如果一个列被指定为AUTO_INCRE-MENT，则它需要使用特殊的值吗？你<strong>可以在INSERT语句中指定一个值，只要它是唯一的（至今尚未使用过）即可</strong>，该值将被用来<strong>替代自动生成的值</strong>，<strong>后续的增量将开始使用该手工插入的值</strong>。</p>
</li>
<li><p><strong>确定AUTO_INCREMENT值</strong></p>
<p>让MySQL通过自动增量生成主键的一个缺点是<strong>你不知道这些值都是谁</strong>。</p>
<p>考虑这个场景：你正在增加一个新订单，这要求在orders表中创建一行，然后在orderitems表中对订购的每项物品创建一行。order_num在orderitems表中与订单细节一起存储。<strong>这显然要求你在插入orders行之后，插入orderitems行之前知道生成的order_num</strong>。</p>
<p>那么，<strong>如何在使用AUTO_INCREMENT列时获得这个值呢</strong>？可使用<strong>last_insert_id()函数</strong>获得这个值，如<code>SELECT_last_insert_id()</code>，<strong>此语句返回最后一个AUTO_INCREMENT值，然后可以将它用于后续的MySQL语句</strong>。</p>
</li>
<li><p>更改<strong>自动增量的开始数和增幅</strong>(IDENTITY(a,b)&#96;)</p>
<p>   <code>IDENTITY(a, b)</code>：</p>
<ul>
<li>a、b均为<strong>正整数</strong></li>
<li>a表示<strong>开始数</strong>，b表示<strong>增幅</strong></li>
</ul>
<p>  就像<code>IDENTITY(2,3)</code>，意思就是<strong>该列自动增长</strong>，由2开始，每次增加是3</p>
</li>
</ul>
<hr>
<h4 id="指定默认值"><a href="#指定默认值" class="headerlink" title="指定默认值"></a>指定默认值</h4><ul>
<li><p>如果<strong>在插入行时没有给出值</strong>，MySQL<strong>允许指定此时使用的默认值</strong>。默认值用<strong>CREATE TABLE语句的列定义中的DEFAULT关键字指定</strong>。如：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> orderitems
<span class="token punctuation">(</span>
	order_num	<span class="token keyword">INT</span>				<span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    order_item	<span class="token keyword">INT</span>				<span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    prod_id		<span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>		<span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    quantity	<span class="token keyword">INT</span>				<span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token number">1</span><span class="token punctuation">,</span>
    item_price 	<span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>	<span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>order_num<span class="token punctuation">,</span> order_item<span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>此例子中，给该列的描述添加文本<strong>DEFAULT 1</strong>指示MySQL，<strong>在未给出数量的情况下使用数量1</strong>。</p>
</li>
<li><p>与大多数DBMS<strong>不一样</strong>，MySQL<strong>不允许使用函数作为默认值</strong>，它<strong>只支持常量</strong>。</p>
</li>
<li><p>许多数据库开发人员<strong>使用默认值而不是NULL列</strong>，特别是对<strong>用于计算或数据分组的列更是如此</strong>。</p>
</li>
</ul>
<hr>
<h4 id="引擎类型"><a href="#引擎类型" class="headerlink" title="引擎类型"></a>引擎类型</h4><ul>
<li>迄今为止使用的CREATE TABLE语句全都以<strong>ENGINE&#x3D;InnoDB语句</strong>结束。<strong>如果省略ENGINE&#x3D;语句，则使用默认引擎</strong>(MySQL <strong>5.5之前</strong>，<strong>MyISAM</strong>是默认的引擎；<strong>5.5之后</strong>，<strong>InnoDB</strong>是默认的引擎)。</li>
<li>几个需要知道的引擎：<ol>
<li><strong>CREATE DATABASEInnoDB</strong>是一个可靠的<strong>事务处理引擎</strong>（参见第26章），它<strong>不支持全文本搜索</strong>(18章)；</li>
<li><strong>MyISAM</strong>是一个<strong>性能极高</strong>的引擎，它<strong>支持全文本搜索，不支持事务处理</strong>。</li>
<li><strong>MEMORY</strong>功能等同于MyISAM，但由于<strong>数据存储在内存中</strong>，速度很快，故适合于<strong>临时表</strong>。</li>
</ol>
</li>
<li>引擎可以混用</li>
<li><strong>外键（用于强制实施引用完整性，如第1章所述）不能跨引擎</strong>。</li>
</ul>
<hr>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> student<span class="token punctuation">(</span>
    stuId 		<span class="token keyword">INT</span> 			<span class="token keyword">IDENTITY</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
    stuName 	<span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> 	<span class="token keyword">UNIQUE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    stuAge 		<span class="token keyword">INT</span> 			<span class="token keyword">CHECK</span><span class="token punctuation">(</span>stuAge <span class="token operator">BETWEEN</span> <span class="token number">18</span> <span class="token operator">AND</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment"># 加入检查约束</span>
    stuAddress 	<span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> 	<span class="token keyword">DEFAULT</span> <span class="token string">'china'</span><span class="token punctuation">,</span> <span class="token comment"># 指定默认值 </span>
    stuDel <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h3 id="更新表"><a href="#更新表" class="headerlink" title="更新表"></a>更新表</h3><ul>
<li><p>更新表定义，可使用<strong>ALTER TABLE语句</strong></p>
</li>
<li><p>为了使用ALTER TABLE更改表结构，必须给出下面的信息：</p>
<ul>
<li>在<strong>ALTER TABLE之后</strong>给出<strong>要更改的表名</strong>（<strong>该表必须存在，否则将出错</strong>）；</li>
<li><strong>所做更改的列表</strong>。</li>
</ul>
</li>
<li><p><strong>给表添加一个列</strong>：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> vendors
<span class="token keyword">ADD</span> vend_phone <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>增加一个列</strong>，<strong>必须明确其数据类型</strong>。</p>
</li>
<li><p><strong>删除表中的列</strong>：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> vendors
<span class="token keyword">DROP</span> <span class="token keyword">COLUMN</span> vend_phone<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>ALTER TABLE的一种常见用途是<strong>定义外键</strong></p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> orderitems
<span class="token keyword">ADD</span> <span class="token keyword">CONSTRAINT</span> fk_orderitems_orders <span class="token comment">-- CONSTRAINT fk_name 定义外键名，可以不定义</span>
<span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>order_num<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> orders <span class="token punctuation">(</span>order_num<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>如果<strong>对单个表进行多个更改</strong>，可以<strong>使用单条ALTER TABLE语句</strong>，<strong>每个更改用逗号分隔</strong>。</p>
</li>
<li><p><strong>复杂的表结构更改</strong>一般需要<strong>手动删除过程</strong>：</p>
<ol>
<li>用新的列布局创建一个新表</li>
<li>使用<strong>INSERT SELECT语句</strong>(19章)<strong>从旧表复制数据到新表</strong>。如果有必要，<strong>可使用转换函数和计算字段</strong>。</li>
<li>检验包含所需数据的新表</li>
<li>重命名旧表（如果确定，可以删除它）</li>
<li>用旧表原来的名字重命名新表</li>
<li>根据需要，重新创建触发器、存储过程、索引和外键</li>
</ol>
</li>
<li><p>使用ALTER TABLE要极为小心，应该在进行改动前做一个完整的备份（模式和数据的备份）。</p>
</li>
</ul>
<hr>
<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><ul>
<li><p>删除表（删除整个表而不是其内容）非常简单，使用<strong>DROP TABLE语句</strong>即可。如：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> customers2<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<p>DROP TABLE IF EXISTS table_name;</p>
<p><strong>删除表没有确认，也不能撤销</strong>，执行这条语句将永久删除该表。</p>
<hr>
<h3 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h3><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><ul>
<li><p>使用<strong>RENAME TABLE语句</strong>可以重命名一个表。如：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">  <span class="token keyword">RENAME</span> <span class="token keyword">TABLE</span> customers2 <span class="token keyword">TO</span> customers<span class="token punctuation">;</span>

<span class="token operator">-</span> 可以<span class="token operator">*</span><span class="token operator">*</span>使用单条<span class="token keyword">RENAME</span> <span class="token keyword">TABLE</span>语句<span class="token operator">*</span><span class="token operator">*</span>对<span class="token operator">*</span><span class="token operator">*</span>多个表<span class="token operator">*</span><span class="token operator">*</span>进行重命名，<span class="token operator">*</span><span class="token operator">*</span>每个重命名用逗号分隔<span class="token operator">*</span><span class="token operator">*</span>。

<span class="token comment">---</span>

<span class="token comment">#### 方式二</span>

<span class="token identifier"><span class="token punctuation">`</span><span class="token punctuation">`</span></span><span class="token punctuation">`</span><span class="token keyword">sql</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> customers2 <span class="token keyword">RENAME</span> <span class="token keyword">TO</span> customers<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<hr>
<h2 id="第22章-使用视图"><a href="#第22章-使用视图" class="headerlink" title="第22章 使用视图"></a>第22章 使用视图</h2><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>MySQL <strong>5</strong>添加了对视图的支持。视图是<strong>虚拟的表</strong>，<strong>只包含</strong>使用时动态检索数据的<strong>查询</strong>，<strong>不包含数据</strong>。</p>
<p>例：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> cust_name<span class="token punctuation">,</span> cust_contact
<span class="token keyword">FROM</span> customers<span class="token punctuation">,</span> orders<span class="token punctuation">,</span> orderitems
<span class="token keyword">WHERE</span> customers<span class="token punctuation">.</span>cust_id <span class="token operator">=</span> orders<span class="token punctuation">.</span>cust_id
		<span class="token operator">AND</span> orderitems<span class="token punctuation">.</span>order_num <span class="token operator">=</span> orders<span class="token punctuation">.</span>order_num
		<span class="token operator">AND</span> prod_id <span class="token operator">=</span> <span class="token string">'TNT2'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​	此查询用来检索订购了某个特定产品的客户。<strong>任何需要这个数据的人都必须理解相关表的结构，并且知道如何创建查询和对表进行联结。为了检索其他产品的相同数据，必须修改最后的WHERE子句</strong>。假如可以<strong>把整个查询包装成一个名为productcustomers的虚拟表</strong>，则可以如下轻松地检索出相同的数据：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> cust_name<span class="token punctuation">,</span> cust_contact
<span class="token keyword">FROM</span> productcustomers
<span class="token keyword">WHERE</span> prod_id <span class="token operator">=</span> <span class="token string">'TNT2'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>这就是视图的作用</strong>。productcustomers是一个视图，<strong>作为视图，它不包含表中应该有的任何列或数据，它包含的是一个SQL查询</strong>。</p>
<hr>
<h4 id="为什么使用视图"><a href="#为什么使用视图" class="headerlink" title="为什么使用视图"></a>为什么使用视图</h4><p>视图的一些常见应用：</p>
<ol>
<li>重用SQL语句。</li>
<li>简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道它的基本查询细节。</li>
<li>使用表的组成部分而不是整个表。</li>
<li>保护数据。可以<strong>给用户授予表的特定部分的访问权限</strong>而不是整个表的访问权限。</li>
<li><strong>更改数据格式和表示</strong>。视图可返回与底层表的表示和格式不同的数据。</li>
</ol>
<p>视图本身不包含数据，因此它们<strong>返回的数据是从其他表中检索出来的</strong>。<strong>在添加或更改这些表中的数据时，视图将返回改变过的数据</strong>。</p>
<p><strong>性能问题</strong>：因为视图不包含数据，所以<strong>每次使用视图时，都必须处理查询执行时所需的任一个检索</strong>。因此，<strong>如果用多个联结和过滤创建了复杂的视图或者嵌套了视图，可能会发现性能下降得很厉害</strong>。因此，在部署使用了大量视图的应用前，应该进行测试。</p>
<hr>
<h4 id="视图的规则和限制"><a href="#视图的规则和限制" class="headerlink" title="视图的规则和限制"></a>视图的规则和限制</h4><p>视图创建和使用的一些最常见的规则和限制：</p>
<ol>
<li>与表一样，视图必须唯一命名（<strong>不能给视图取</strong>与别的视图或<strong>表</strong>相同的名字）。</li>
<li>对于可以创建的视图数目没有限制。</li>
<li>为了创建视图，必须具有<strong>足够的访问权限</strong>。这些<strong>限制通常由数据库管理人员授予</strong>。</li>
<li>视图<strong>可以嵌套</strong>，即<strong>可以利用从其他视图中检索数据的查询来构造一个视图</strong>。</li>
<li>ORDER BY可以用在视图中，但<strong>如果从该视图检索数据的SELECT语句中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖</strong>。</li>
<li><strong>视图不能索引，也不能有关联的触发器或默认值</strong>。</li>
<li><strong>视图可以和表一起使用</strong>。例如，编写一条联结表和视图的SELECT语句。</li>
</ol>
<hr>
<h3 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h3><p>视图的创建：</p>
<ol>
<li>视图用<strong>CREATE VIEW语句</strong>来创建。</li>
<li>使用<code>SHOW CREATE VIEW viewname;</code>来<strong>查看创建视图的语句</strong>。</li>
<li><strong>用DROP删除视图</strong>，其语法为<code>DROP VIEW viewname;</code>。</li>
<li><strong>更新视图</strong>时，可以<strong>先用DROP再用CREATE</strong>，也可以直接用<strong>CREATE OR REPLACEVIEW</strong>。</li>
</ol>
<hr>
<h4 id="利用视图简化复杂的联结"><a href="#利用视图简化复杂的联结" class="headerlink" title="利用视图简化复杂的联结"></a>利用视图简化复杂的联结</h4><p>视图<strong>最常见的应用</strong>之一是<strong>隐藏复杂的SQL</strong>，这通常都会涉及联结：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> productcustomers <span class="token keyword">AS</span>
<span class="token keyword">SELECT</span> cust_name<span class="token punctuation">,</span> cust_contact<span class="token punctuation">,</span> prod_id
<span class="token keyword">FROM</span> customers<span class="token punctuation">,</span> orders<span class="token punctuation">,</span> orderitems
<span class="token keyword">WHERE</span> customers<span class="token punctuation">.</span>cust_id <span class="token operator">=</span> orders<span class="token punctuation">.</span>cust_id 
		<span class="token operator">AND</span> orderitems<span class="token punctuation">.</span>order_num <span class="token operator">=</span> orders<span class="token punctuation">.</span>order_num<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>这条语句创建了一个名为productcustomers的视图，它联结三个表，以返回已订购了任意产品的所有客户的列表。如果执行<code>SELECT * FROM productcustomers;</code>，将列出订购了任意产品的客户。</p>
</li>
<li><p>为检索订购了产品TNT2的客户，可如下进行：</p>
  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> cust_name<span class="token punctuation">,</span> cust_contact
<span class="token keyword">FROM</span> productcustomers
<span class="token keyword">WHERE</span> prod_id <span class="token operator">=</span> <span class="token string">'TNT2'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ul>
<li>这条语句通过WHERE子句从视图中检索特定数据。在MySQL处理此查询时，它<strong>将指定的WHERE子句添加到视图查询中的已有WHERE子句中</strong>，以便正确过滤数据。</li>
<li>可以看出，视图极大地简化了复杂SQL的使用。<strong>利用视图，可一次性编写基础的SQL，然后根据需要多次使用</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="用视图重新格式化检索出的数据"><a href="#用视图重新格式化检索出的数据" class="headerlink" title="用视图重新格式化检索出的数据"></a>用视图重新格式化检索出的数据</h4><p>如下SELECT语句在单个组合计算列中返回供应商名和位置：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> Concat<span class="token punctuation">(</span>RTrim<span class="token punctuation">(</span>vend_name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'('</span><span class="token punctuation">,</span> RTrim<span class="token punctuation">(</span>vend_country<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">')'</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> vend_title
<span class="token keyword">FROM</span> vendors
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> vend_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>假如经常需要这个格式的结果，不必在每次需要时执行联结，创建一个视图，每次需要时使用它即可：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> vendorlocations <span class="token keyword">AS</span>
<span class="token keyword">SELECT</span> Concat<span class="token punctuation">(</span>RTrim<span class="token punctuation">(</span>vend_name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'('</span><span class="token punctuation">,</span> RTrim<span class="token punctuation">(</span>vend_country<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">')'</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> vend_title
<span class="token keyword">FROM</span> vendors
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> vend_name<span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> vendorlocations<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h4 id="用视图过滤不想要的数据"><a href="#用视图过滤不想要的数据" class="headerlink" title="用视图过滤不想要的数据"></a>用视图过滤不想要的数据</h4><p>例如，可以定义customeremaillist视图，它<strong>过滤没有电子邮件地址的客户</strong>。为此目的，可使用下面的语句：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> customeremaillist <span class="token keyword">AS</span>
<span class="token keyword">SELECT</span> cust_id<span class="token punctuation">,</span> cust_name<span class="token punctuation">,</span> cust_email
<span class="token keyword">FROM</span> customers
<span class="token keyword">WHERE</span> cust_email <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> customeremaillist<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h4 id="使用视图与计算字段"><a href="#使用视图与计算字段" class="headerlink" title="使用视图与计算字段"></a>使用视图与计算字段</h4><p>视图对于<strong>简化计算字段的使用</strong>特别有用。下面是第10章中介绍的一条SELECT语句。它检索某个特定订单中的物品，计算每种物品的总价格：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> prod_id<span class="token punctuation">,</span>
		quantity<span class="token punctuation">,</span>
		item_price<span class="token punctuation">,</span>
		quantity <span class="token operator">*</span> item_price <span class="token keyword">AS</span> expanded_price
<span class="token keyword">FROM</span> orderitems
<span class="token keyword">WHERE</span> order_num <span class="token operator">=</span> <span class="token number">20005</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>为其转换为一个视图：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> orderitemsexpanded <span class="token keyword">AS</span>
<span class="token keyword">SELECT</span> prod_id<span class="token punctuation">,</span>
		quantity<span class="token punctuation">,</span>
		item_price<span class="token punctuation">,</span>
		quantity <span class="token operator">*</span> item_price <span class="token keyword">AS</span> expanded_price
<span class="token keyword">FROM</span> orderitems<span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> orderitemsexpanded
<span class="token keyword">WHERE</span> order_num <span class="token operator">=</span> <span class="token number">20005</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h4 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h4><p><strong>视图的数据能否更新？答案视情况而定</strong>。</p>
<p><strong>通常，视图是可更新的</strong>（即，可以对它们使用INSERT、UPDATE和DELETE）。<strong>更新一个视图将更新其基表（可以回忆一下，视图本身没有数据）。如果你对视图增加或删除行，实际上是对其基表增加或删除行</strong>。</p>
<p>但是，<strong>并非所有视图都是可更新的</strong>。基本上可以说，如果MySQL<strong>不能正确地确定被更新的基数据</strong>，则不允许更新（包括插入和删除）。这实际上意味着，如果视图定义中有以下操作，则不能进行视图的更新：</p>
<ol>
<li>分组（使用GROUP BY和HAVING）；</li>
<li>联结；</li>
<li>子查询；</li>
<li>并；</li>
<li>聚集函数（Min()、Count()、Sum()等）；</li>
<li>DISTINCT；</li>
<li>导出（计算）列。</li>
</ol>
<p><strong>看上去好像是一个严重的限制，但实际上不是，因为视图主要用于数据检索(SELECT)</strong>。</p>
<p>视图提供了一种MySQL的<strong>SELECT语句层次的封装</strong>，可用来<strong>简化数据处理以及重新格式化基础数据或保护基础数据</strong>。</p>
<hr>
<h2 id="用户变量和SET语句"><a href="#用户变量和SET语句" class="headerlink" title="用户变量和SET语句"></a>用户变量和SET语句</h2><p>用户变量即<strong>自定义的变量</strong>，我们<strong>可以给用户变量分配值，并且可用在任何可以正常使用标量表达式的地方</strong>。<br> 必须<strong>使用SET或SELECT语句来定义它</strong>，<strong>然后为它赋一个值，否则变量就只有一个空值</strong>。一个客户端定义的变量不能被其它客户端看到或使用。<strong>当客户端退出时，该客户端连接的所有变量将自动释放</strong>。</p>
<h3 id="用户变量定义"><a href="#用户变量定义" class="headerlink" title="用户变量定义"></a>用户变量定义</h3><ul>
<li><pre><code class="language-sql">  SET @var_name = expr [, @var_name = expr] ...
  <pre class="line-numbers language-none"><code class="language-none">
- &#96;&#96;&#96;sql
	SELECT @var_name :&#x3D; expr [, @var_name &#x3D; expr] ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
</ul>
<p>对于<strong>SET，可以使用<code>=</code>或<code>:=</code>来赋值，对于SELECT只能使用<code>:=</code>来赋值</strong></p>
<hr>
<h3 id="用户变量的使用"><a href="#用户变量的使用" class="headerlink" title="用户变量的使用"></a>用户变量的使用</h3><h4 id="SET-语句"><a href="#SET-语句" class="headerlink" title="SET 语句"></a>SET 语句</h4><ol>
<li><p><strong>把一个值赋给一个变量的标量表达式可以是复合表达式</strong>。计算、函数、系统标量以及其他用户变量都是允许的，子查询也是允许的。然后<strong>通过SELECT语句可以获取用户变量的值，结果是带有一行的一个表</strong>。</p>
<p> 例：</p>
 <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SET</span> <span class="token variable">@var1</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token variable">@var2</span><span class="token operator">=</span><span class="token string">'vartest'</span><span class="token punctuation">,</span> <span class="token variable">@var3</span><span class="token operator">=</span>ABS<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token variable">@var4</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> mysql<span class="token punctuation">.</span><span class="token keyword">user</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token variable">@var1</span><span class="token punctuation">,</span> <span class="token variable">@var2</span><span class="token punctuation">,</span> <span class="token variable">@var3</span><span class="token punctuation">,</span> <span class="token variable">@var4</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p> 结果为：</p>
<table>
<thead>
<tr>
<th>@var1</th>
<th>@var2</th>
<th>@var3</th>
<th>@var4</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>vartest</td>
<td>2</td>
<td>4</td>
</tr>
</tbody></table>
</li>
<li><p>在为一个用户变量赋值的表达式中，也可以指定其它的用户变量。但是MySQL会<strong>先</strong>确定<strong>所有表达式的值</strong>，再<strong>给变量赋值</strong>。</p>
<p> 例：</p>
 <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SET</span> <span class="token variable">@varA</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">SET</span> <span class="token variable">@varA</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token variable">@varB</span> <span class="token operator">=</span> <span class="token variable">@varA</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token variable">@varB</span><span class="token punctuation">;</span> <span class="token comment">-- @varB的值为2</span>

<span class="token comment">----------------------------</span>
<span class="token keyword">SET</span> <span class="token variable">@varA</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">SET</span> <span class="token variable">@varB</span> <span class="token operator">=</span> <span class="token variable">@varA</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token variable">@varB</span><span class="token punctuation">;</span> <span class="token comment">-- @varB的值为3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<hr>
<h4 id="SELECT-语句"><a href="#SELECT-语句" class="headerlink" title="SELECT 语句"></a>SELECT 语句</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token variable">@var1</span>:<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token variable">@var2</span>:<span class="token operator">=</span><span class="token string">'vartest'</span><span class="token punctuation">,</span> <span class="token variable">@var3</span>:<span class="token operator">=</span>ABS<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token variable">@var4</span>:<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> mysql<span class="token punctuation">.</span><span class="token keyword">user</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>返回一个表格形式的结果：</p>
<table>
<thead>
<tr>
<th>@var1:&#x3D;1</th>
<th>@var2:&#x3D;’vartest’</th>
<th>@var3:&#x3D;abs(-2)</th>
<th>@var4:&#x3D;(select count(*) from mysql.user)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>vartest</td>
<td>2</td>
<td>4</td>
</tr>
</tbody></table>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token variable">@var1</span><span class="token punctuation">,</span> <span class="token variable">@var2</span><span class="token punctuation">,</span> <span class="token variable">@var3</span><span class="token punctuation">,</span> <span class="token variable">@var4</span><span class="token punctuation">;</span> <span class="token comment">-- 效果与SET语句后的SELECT相同</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<hr>
<h3 id="用户变量注意事项"><a href="#用户变量注意事项" class="headerlink" title="用户变量注意事项"></a>用户变量注意事项</h3><ul>
<li><p>用户变量<strong>用在WHERE或HAVING子句中时，必须首先用另一条语句来定义</strong>。如下面例子，<strong>初次查询不会返回结果，先定义以后再查询才有输出</strong>：</p>
  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token variable">@H</span>:<span class="token operator">=</span><span class="token string">'localhost'</span><span class="token punctuation">,</span> <span class="token keyword">user</span>
<span class="token keyword">FROM</span> mysql<span class="token punctuation">.</span><span class="token keyword">user</span>
<span class="token keyword">WHERE</span> Host <span class="token operator">=</span> <span class="token variable">@H</span><span class="token punctuation">;</span> <span class="token comment">-- 因为这时@H的值还是NULL(MySQL先确定所有表达式的值，再给变量赋值)</span>
<span class="token comment">----------------------</span>

<span class="token keyword">SELECT</span> <span class="token variable">@H</span>:<span class="token string">'localhost'</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token variable">@H</span>:<span class="token operator">=</span><span class="token string">'localhost'</span><span class="token punctuation">,</span> <span class="token keyword">user</span>
<span class="token keyword">FROM</span> mysql<span class="token punctuation">.</span><span class="token keyword">user</span>
<span class="token keyword">WHERE</span> Host <span class="token operator">=</span> <span class="token variable">@H</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>用户变量为<strong>session级别</strong>，当我们关闭客户端或退出登录时用户变量全部消失</p>
</li>
<li><p>用户变量名对大小写不敏感</p>
</li>
<li><p>未定义的变量初始化是NULL</p>
</li>
</ul>
<hr>
<h2 id="第23章-使用存储过程"><a href="#第23章-使用存储过程" class="headerlink" title="第23章 使用存储过程"></a>第23章 使用存储过程</h2><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>迄今为止，<strong>使用的大多数SQL语句都是</strong>针对一个或多个表的<strong>单条语句</strong>。并非所有操作都那么简单，经常会有一个完整的操作需要多条语句才能完成。例如如下场景：</p>
<ol>
<li>为了处理订单，需要核对以保证库存中有相应的物品。</li>
<li>如果库存有物品，<strong>这些物品需要预定</strong>以便不将它们再卖给别的人，并且要<strong>减少可用的物品数量以反映正确的库存量</strong>。</li>
<li>库存中没有的物品需要订购，这需要与供应商进行某种交互。</li>
<li>关于哪些商品入库(并可以立即发货)和哪些物品退订，需要通知相应的客户。</li>
</ol>
<p>执行这些处理<strong>需要针对许多表的多条MySQL语句</strong>。此外，<strong>需要执行的具体语句及其次序也不是固定的，它们可能会（和将）根据哪些物品在库存中哪些不在而变化</strong>。那么，应该怎样编写代码？</p>
<p><strong>可以单独编写每条语句，并根据结果，有条件地执行另外的语句。在每次需要这个处理时，都必须做这些工作</strong>。可以<strong>创建存储过程</strong>。存储过程简单来说，就是<strong>为以后的使用而保存的一条或多条MySQL语句的集合</strong>。<strong>可将其视为批文件，虽然它们的作用不仅限于批处理</strong>。</p>
<hr>
<h3 id="为什么要使用存储过程"><a href="#为什么要使用存储过程" class="headerlink" title="为什么要使用存储过程"></a>为什么要使用存储过程</h3><ol>
<li>简化复杂操作</li>
<li>需要执行的步骤越多，出错的可能性就越大。使用存储过程能防止错误，保证数据的一致性。</li>
<li>简化对变动的管理(解耦)。</li>
<li>提高性能，<strong>使用存储过程比使用单独的SQL语句要快</strong>。</li>
<li><strong>存在一些只能用在单个请求中的MySQL元素和特性</strong>，存储过程可以使用它们来编写功能更强更灵活的代码。</li>
</ol>
<p>简单来说，使用存储过程有<strong>3个主要好处</strong>：<strong>简单、安全、高性能</strong>。</p>
<p>存储过程同样也存在一些<strong>缺点</strong>：</p>
<ol>
<li>存储过程的<strong>编写比基本SQL语句复杂</strong>，编写存储过程需要更高的技能，更丰富的经验。</li>
<li>可能没有创建存储过程的安全访问权限。</li>
</ol>
<hr>
<h3 id="使用存储过程"><a href="#使用存储过程" class="headerlink" title="使用存储过程"></a>使用存储过程</h3><h4 id="执行存储过程"><a href="#执行存储过程" class="headerlink" title="执行存储过程"></a>执行存储过程</h4><p>MySQL称<strong>存储过程的执行</strong>为<strong>调用</strong>，因此MySQL执行存储过程的语句为<strong>CALL</strong>。CALL接受<strong>存储过程的名字</strong>以及<strong>需要传递给它的任意参数</strong></p>
<p>例：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 执行名为productpricing的存储过程，它计算并返回产品的最低、最高和平均价格。</span>
<span class="token keyword">CALL</span> productpricing<span class="token punctuation">(</span><span class="token variable">@pricelow</span><span class="token punctuation">,</span>
                   <span class="token variable">@pricehigh</span><span class="token punctuation">,</span>
                   <span class="token variable">@priceaverage</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>存储过程<strong>可以显示结果，也可以不显示结果</strong>。</li>
</ul>
<hr>
<h4 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h4><p>例：一个<strong>返回产品平均价格</strong>的存储过程</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> productpricing<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">BEGIN</span> 
	<span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>prod_price<span class="token punctuation">)</span> <span class="token keyword">AS</span> priceaverage
	<span class="token keyword">FROM</span> products<span class="token punctuation">;</span>
<span class="token keyword">END</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>定义</strong>存储过程：<code>CREATE PROCEDURE 存储过程名()</code></li>
<li>如果存储过程接受<strong>参数</strong>，它们将<strong>在<code>()</code>中列出</strong></li>
<li><strong>BEGIN和END语句用来限定存储体</strong>，存储体本身是一个简单的SELECT语句</li>
</ul>
<p><strong>MySQL命令行的分隔符</strong>：</p>
<p>默认的MySQL语句分隔符为<code>;</code>，如果<strong>命令行实用程序</strong>要解释存储过程自身内的<code>;</code>字符，会<strong>使存储过程中的SQL语句出现语法错误</strong>。通过<strong>临时更改命令行实用程序的语句分隔符</strong>来解决：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DELIMITER</span> <span class="token comment">//</span>
<span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> productpricing<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">BEGIN</span> 
	<span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>prod_price<span class="token punctuation">)</span> <span class="token keyword">AS</span> priceaverage
	<span class="token keyword">FROM</span> products<span class="token punctuation">;</span>
<span class="token keyword">END</span> <span class="token comment">//</span>

<span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p><code>DELIMITER //</code>指明<strong>使用<code>//</code>作为新的语句结束分隔符</strong>；<code>DELIMITER ;</code>指明<strong>使用<code>;</code>作为新的语句结束分隔符</strong></p>
<p>  <strong>除<code>\</code>符号外，任何字符都可以用作语句分隔符</strong>。</p>
</li>
<li><p>使用这个存储过程：<code>CALL productpricing();</code></p>
<p>  因为存储过程实际上是一种函数，所以存储过程名后需要有<code>()</code>符号</p>
</li>
</ul>
<hr>
<h4 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h4><p>存储过程<strong>在创建之后，被保存在服务器上以供使用，直至被删除</strong>。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">PROCEDURE</span> productpricing<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><p>请注意<strong>没有使用后面的<code>()</code>，只给出存储过程名</strong></p>
</li>
<li><p>如果<strong>指定的过程不存在，则DROP PROCEDURE将产生一个错误</strong>。当过程存在想删除它时（如果过程不存在也不产生错误）可使用<code>DROP PROCEDURE IF EXISTS</code>。</p>
</li>
</ul>
<hr>
<h4 id="使用参数"><a href="#使用参数" class="headerlink" title="使用参数"></a>使用参数</h4><p><strong>一般，存储过程并不显示结果，而是把结果返回给你指定的变量</strong>。</p>
<ul>
<li><strong>变量</strong>：内存中一个特定的位置，用来<strong>临时存储数据</strong>。</li>
</ul>
<h5 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h5><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> productpricing<span class="token punctuation">(</span> 
    <span class="token keyword">OUT</span> pl <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">OUT</span> ph <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">OUT</span> pa <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>
<span class="token keyword">BEGIN</span> 
	<span class="token keyword">SELECT</span> <span class="token function">MIN</span><span class="token punctuation">(</span>prod_price<span class="token punctuation">)</span>
	<span class="token keyword">INTO</span> pl
	<span class="token keyword">FROM</span> products<span class="token punctuation">;</span>
	<span class="token keyword">SELECT</span> <span class="token function">MAX</span><span class="token punctuation">(</span>prod_price<span class="token punctuation">)</span>
	<span class="token keyword">INTO</span> ph
	<span class="token keyword">FROM</span> products<span class="token punctuation">;</span>
	<span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>prod_price<span class="token punctuation">)</span>
	<span class="token keyword">INTO</span> pa
	<span class="token keyword">FROM</span> products<span class="token punctuation">;</span>
<span class="token keyword">END</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>如果不先<strong>删除已存在的同名存储过程</strong>，则不能再次创建它。</p>
</li>
<li><p>关键字<strong>OUT</strong>指出<strong>相应的参数用来从存储过程传出一个值（返回给调用者）</strong></p>
<p>  MySQL支持<strong>IN(传递给存储过程)</strong>、**OUT(从存储过程传出)<strong>和</strong>INOUT(对存储过程传入和传出)**类型的参数。</p>
</li>
<li><p>存储过程用来检索值，然后通过指定<strong>INTO关键字</strong>保存到相应的变量</p>
</li>
<li><p><strong>不能通过一个参数返回多个行和列</strong>，因为<strong>记录集是不允许的类型</strong>。</p>
</li>
</ul>
<p>为调用此存储过程，必须指定3个变量名：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CALL</span> productpricing<span class="token punctuation">(</span><span class="token variable">@pricelow</span><span class="token punctuation">,</span> 
                   <span class="token variable">@pricehigh</span><span class="token punctuation">,</span>
                   <span class="token variable">@priceaverage</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p><strong>所有MySQL变量</strong>都必须<strong>以@开始</strong></p>
</li>
<li><p>在调用时，<strong>这条语句并不显示任何数据</strong>。它<strong>返回变量</strong>。</p>
</li>
<li><p>为了<strong>显示</strong>检索出的产品平均价格，可如下进行：<code>SELECT @priceaverage;</code></p>
</li>
<li><p>为了获得3个变量的值，可：<code>SELECT @pricehigh, @pricelow, @priceaverage;</code></p>
</li>
</ul>
<hr>
<h5 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h5><p>这次使用IN和OUT参数。ordertotal接受订单号并返回该订单的合计：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> ordertotal<span class="token punctuation">(</span> 
    <span class="token operator">IN</span> onumber <span class="token keyword">INT</span><span class="token punctuation">,</span>
    <span class="token keyword">OUT</span> ototal <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>
<span class="token keyword">BEGIN</span> 
	<span class="token keyword">SELECT</span> <span class="token function">Sum</span><span class="token punctuation">(</span>item_price<span class="token operator">*</span>quantity<span class="token punctuation">)</span>
	<span class="token keyword">FROM</span> orderitems
	<span class="token keyword">WHERE</span> order_num <span class="token operator">=</span> onumber
	<span class="token keyword">INTO</span> ototal<span class="token punctuation">;</span>
<span class="token keyword">END</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>可使用调用语句：<code>CALL ordertotal(20005, @total);</code></p>
</li>
<li><p>为了显示合计：<code>SELECT @total;</code></p>
</li>
</ul>
<hr>
<h4 id="建立智能存储过程"><a href="#建立智能存储过程" class="headerlink" title="建立智能存储过程"></a>建立智能存储过程</h4><p>迄今为止使用的所有存储过程基本上都是封装MySQL简单的SELECT语句。虽然它们全都是有效的存储过程例子，但它们所能完成的工作你直接用这些被封装的语句就能完成。<strong>只有在存储过程内包含业务规则和智能处理时，它们的威力才真正显现出来</strong>。</p>
<p>考虑这个场景。你需要获得与以前一样的订单合计，但需要对<strong>合计增加营业税</strong>，不过<strong>只针对某些顾客</strong>（或许是你所在州中那些顾客）。那么，你需要做下面几件事情：</p>
<ol>
<li>获得合计</li>
<li>把营业税有条件地添加到合计</li>
<li>返回合计（带或不带税）</li>
</ol>
<p>存储过程的完整工作如下：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- Name: ordertotal</span>
<span class="token comment">-- Parameters:	onumber = order number</span>
<span class="token comment">--				taxable = 0 if not taxable, 1 if taxable</span>
<span class="token comment">--				ototal = order total variable</span>

<span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> ordertotal<span class="token punctuation">(</span> 
    <span class="token operator">IN</span> onumber <span class="token keyword">INT</span><span class="token punctuation">,</span>
    <span class="token operator">IN</span> taxable <span class="token keyword">BOOLEAN</span><span class="token punctuation">,</span>
    <span class="token keyword">OUT</span> ototal <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">COMMENT</span> <span class="token string">'Obtain order total, optionally adding tax'</span>
<span class="token keyword">BEGIN</span>
	<span class="token comment">-- Declare variable for total</span>
	<span class="token keyword">DECLARE</span> total <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">-- Declare tax percentage</span>
	<span class="token keyword">DECLARE</span> taxrate <span class="token keyword">INT</span> <span class="token keyword">DEFAULT</span> <span class="token number">6</span><span class="token punctuation">;</span>
	
	<span class="token comment">-- Get the order total</span>
	<span class="token keyword">SELECT</span> <span class="token function">Sum</span><span class="token punctuation">(</span>item_price<span class="token operator">*</span>quantity<span class="token punctuation">)</span>
	<span class="token keyword">FROM</span> orderitems
	<span class="token keyword">WHERE</span> order_num <span class="token operator">=</span> onumber
	<span class="token keyword">INTO</span> total<span class="token punctuation">;</span>
	
	<span class="token comment">-- Is this taxable?</span>
	<span class="token keyword">IF</span> taxable <span class="token keyword">THEN</span> 
		<span class="token comment">-- Yes, so add taxrate to the total</span>
		<span class="token keyword">SELECT</span> total<span class="token operator">+</span><span class="token punctuation">(</span>total<span class="token operator">*</span>taxrate<span class="token operator">/</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token keyword">INTO</span> total
	<span class="token keyword">END</span> <span class="token keyword">IF</span><span class="token punctuation">;</span>
	
	<span class="token comment">-- And finally, save to out variable</span>
	<span class="token keyword">SELECT</span> total <span class="token keyword">INTO</span> ototal<span class="token punctuation">;</span>
<span class="token keyword">END</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>注释（前面放置<code>--</code>，<code>#</code>也有同样效果）</p>
</li>
<li><p>用<strong>DECLARE</strong>语句<strong>定义了两个局部变量</strong></p>
<p>  DECLARE要求指定<strong>变量名</strong>和<strong>数据类型</strong>，支持<strong>可选的默认值</strong>(DEFAULT xxx)</p>
</li>
<li><p><strong>COMMENT关键字</strong></p>
<p>  它<strong>不是必需的</strong>，但如果给出，将<strong>在SHOW PROCEDURE STATUS的结果中显示</strong>。</p>
</li>
<li><p><strong>IF语句</strong></p>
  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">IF</span> search_condition <span class="token keyword">THEN</span>
    statement_list
<span class="token punctuation">[</span><span class="token keyword">ELSEIF</span> search_condition <span class="token keyword">THEN</span><span class="token punctuation">]</span>
    statement_list <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">[</span><span class="token keyword">ELSE</span>
    statement_list<span class="token punctuation">]</span>
<span class="token keyword">END</span> <span class="token keyword">IF</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<hr>
<h4 id="检查存储过程"><a href="#检查存储过程" class="headerlink" title="检查存储过程"></a>检查存储过程</h4><ul>
<li><p><strong>显示</strong> 创建一个存储过程的CREATE语句，使用<code>SHOW CREATE PROCEDURE</code>语句：<code>SHOW CREATE PROCEDURE ordertotal;</code></p>
</li>
<li><p>为了获得<strong>包括何时、由谁创建等详细信息的存储过程列表</strong>，使用<code>SHOW PROCEDURESTATUS</code>。</p>
<p>  为<strong>限制其输出，可使用LIKE指定一个过滤模式</strong>，例如：</p>
<p>  <code>SHOW PROCEDURE STATUS LIKE ’ordertotal&#39;;</code></p>
</li>
</ul>
<hr>
<h2 id="information-schema-数据库"><a href="#information-schema-数据库" class="headerlink" title="information_schema 数据库"></a>information_schema 数据库</h2><p>information_schema这个数据库中<strong>保存了MySQL服务器所有数据库的信息</strong>，如数据库名，数据库的表，表栏的数据类型与访问权限等。<br>再简单点，这台MySQL服务器上，到底有哪些数据库、各个数据库有哪些表，每张表的字段类型是什么，各个数据库要什么权限才能访问等等信息都保存在information_schema里面。</p>
<ul>
<li><p>SCHEMATA表</p>
<ul>
<li>列SCHEMA_NAME：<strong>所有数据库的名字</strong></li>
</ul>
</li>
<li><p>TABLES表</p>
<ul>
<li>列TABLE_SCHEMA：<strong>所有数据库的名字</strong></li>
<li>列TABLE_NAME：<strong>所有数据库表的名字</strong></li>
<li>列TABLE_ROWS：表的行数</li>
</ul>
</li>
<li><p>COLUMNS表</p>
<ul>
<li>列COLUMN_NAME：<strong>所有数据库表的列的名字</strong></li>
</ul>
</li>
</ul>
<hr>
<h2 id="第24章-使用游标"><a href="#第24章-使用游标" class="headerlink" title="第24章 使用游标"></a>第24章 使用游标</h2><h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><p>有时，<strong>需要在检索出来的行中前进或后退一行或多行</strong>，这就是使用游标的原因。</p>
<p>游标（<strong>cursor</strong>）是一个存储在MySQL服务器上的<strong>数据库查询</strong>，它不是一条SELECT语句，而是被该语句检索出来的<strong>结果集</strong>。在存储了游标之后，应用程序<strong>可以根据需要滚动或浏览其中的数据</strong>。</p>
<p>游标<strong>主要用于交互式应用</strong>，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。不像多数DBMS, <strong>MySQL游标只能用于存储过程（和函数）</strong>。</p>
<hr>
<h3 id="使用游标"><a href="#使用游标" class="headerlink" title="使用游标"></a>使用游标</h3><p>使用游标涉及几个明确的<strong>步骤</strong>：</p>
<ol>
<li>在能够使用游标前，必须声明（定义）它。这个过程实际上没有检索数据，它只是定义要使用的SELECT语句。</li>
<li>一旦声明后，必须<strong>打开游标</strong>以供使用。这个过程用前面定义的SELECT语句把数据实际检索出来。</li>
<li>对于填有数据的游标，根据需要取出（检索）各行。</li>
<li>在<strong>结束游标使用时，必须关闭游标</strong>。</li>
</ol>
<p>在声明游标后，<strong>可根据需要频繁地打开和关闭游标</strong>。在游标打开后，可根据需要频繁地执行取操作。</p>
<hr>
<h4 id="创建游标"><a href="#创建游标" class="headerlink" title="创建游标"></a>创建游标</h4><p>DECLARE<strong>命名游标</strong>，<strong>并定义相应的SELECT语句</strong>，根据需要带WHERE和其他子句。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> processorders<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">BEGIN</span>
	<span class="token keyword">DECLARE</span> ordernumbers <span class="token keyword">CURSOR</span>
	<span class="token keyword">FOR</span>
	<span class="token keyword">SELECT</span> order_num <span class="token keyword">FROM</span> orders<span class="token punctuation">;</span>
<span class="token keyword">END</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>存储过程处理完成后，游标就消失</strong>（因为它局限于存储过程）。</p>
<hr>
<h4 id="打开和关闭游标"><a href="#打开和关闭游标" class="headerlink" title="打开和关闭游标"></a>打开和关闭游标</h4><p>打开：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">OPEN</span> cursor_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>在处理OPEN语句时执行查询，存储检索出的数据以供浏览和滚动</strong>。游标处理完成后，应当使用如下语句关闭游标：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CLOSE</span> cursor_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>CLOSE<strong>释放游标使用的所有内部内存和资源</strong>，<strong>因此在每个游标不再需要时都应该关闭</strong>。</p>
<p><strong>隐含关闭</strong>：如果你<strong>不明确关闭游标</strong>，MySQL<strong>将会在到达END语句时自动关闭它</strong>。</p>
<hr>
<h4 id="使用游标数据"><a href="#使用游标数据" class="headerlink" title="使用游标数据"></a>使用游标数据</h4><p>在一个游标<strong>被打开后</strong>，可以使用<strong>FETCH语句</strong>分别访问它的每一行。FETCH<strong>指定检索什么数据</strong>（所需的列），检索出来的数据存储在什么地方。它还<strong>向前移动游标中的内部行指针</strong>，<strong>使下一条FETCH语句检索下一行</strong>（不重复读取同一行）</p>
<p>例1：从游标中<strong>检索单个行</strong>。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> processorders<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">BEGIN</span>
	<span class="token keyword">DECLARE</span> o <span class="token keyword">INT</span><span class="token punctuation">;</span>
	
	<span class="token keyword">DECLARE</span> ordernumbers <span class="token keyword">CURSOR</span>
	<span class="token keyword">FOR</span>
	<span class="token keyword">SELECT</span> order_num <span class="token keyword">FROM</span> orders<span class="token punctuation">;</span>
	
	<span class="token keyword">OPEN</span> ordernumbers<span class="token punctuation">;</span>
	
	<span class="token keyword">FETCH</span> ordernumbers <span class="token keyword">INTO</span> o<span class="token punctuation">;</span>
	
	<span class="token keyword">CLOSE</span> ordernumbers<span class="token punctuation">;</span>
<span class="token keyword">END</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>其中FETCH用来检索当前行的order_num列（将<strong>自动从第一行开始</strong>）到一个名为o的局部声明的变量中。对检索出的数据不做任何处理。</p>
<p>例2：<strong>循环检索</strong>数据，从第一行到最后一行。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> processorders<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">BEGIN</span>
	DELCARE done <span class="token keyword">BOOLEAN</span> <span class="token keyword">DEFAULT</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">DECLARE</span> o <span class="token keyword">INT</span><span class="token punctuation">;</span>
	
	<span class="token keyword">DECLARE</span> ordernumbers <span class="token keyword">CURSOR</span>
	<span class="token keyword">FOR</span>
	<span class="token keyword">SELECT</span> order_num <span class="token keyword">FROM</span> orders<span class="token punctuation">;</span>
	
	<span class="token keyword">DECLARE</span> <span class="token keyword">CONTINUE</span> <span class="token keyword">HANDLER</span> <span class="token keyword">FOR</span> SQLSTATE <span class="token string">'02000'</span> <span class="token keyword">SET</span> done<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
	
	<span class="token keyword">OPEN</span> ordernumbers<span class="token punctuation">;</span>
	
	<span class="token keyword">REPEAT</span>
		<span class="token keyword">FETCH</span> ordernumbers <span class="token keyword">INTO</span> o<span class="token punctuation">;</span>
	UNTIL done <span class="token keyword">END</span> <span class="token keyword">REPEAT</span><span class="token punctuation">;</span>
	
	<span class="token keyword">CLOSE</span> ordernumbers<span class="token punctuation">;</span>
<span class="token keyword">END</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个例子中的<strong>FETCH是在REPEAT内</strong>，因此它<strong>反复执行直到<code>done</code>为真</strong>（由<code>UNTIL done END REPEAT;</code>规定）。</p>
<p>为使它起作用，用一个<code>DEFAULT 0</code>（假，不结束）定义变量done。那么，done怎样才能<strong>在结束时被设置为真</strong>呢？</p>
<p>答案是用以下语句：</p>
<p><code>DECLARE CONTINUE HANDLER FOR SQLSTATE &#39;02000&#39; SET done=1;</code></p>
<p>这条语句定义了一个<strong>CONTINUE HANDLER</strong>，它是<strong>在条件出现时被执行的代码</strong>。这里，它指出当<strong>SQLSTATE ‘02000’出现时</strong>，SET done&#x3D;1。SQLSTATE’02000’是一个<strong>未找到条件</strong>，<strong>当REPEAT由于没有更多的行供循环而不能继续时，出现这个条件</strong>。</p>
<ul>
<li>如果一切正常，你<strong>可以在循环内放入任意需要的处理</strong>（在<strong>FETCH语句之后，循环结束之前</strong>）。 </li>
<li>除这里使用的<strong>REPEAT语句外</strong>，<strong>MySQL还支持循环语句</strong>，它可<strong>用来重复执行代码</strong>，直到<strong>使用LEAVE语句手动退出</strong>为止。通常<strong>REPEAT语句的语法使它更适合于对游标进行循环</strong>。</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> processorders<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">BEGIN</span>
	DELCARE done <span class="token keyword">BOOLEAN</span> <span class="token keyword">DEFAULT</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">DECLARE</span> o <span class="token keyword">INT</span><span class="token punctuation">;</span>
	<span class="token keyword">DECLARE</span> t <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">DECLARE</span> ordernumbers <span class="token keyword">CURSOR</span>
	<span class="token keyword">FOR</span>
	<span class="token keyword">SELECT</span> order_num <span class="token keyword">FROM</span> orders<span class="token punctuation">;</span>
	
	<span class="token keyword">DECLARE</span> <span class="token keyword">CONTINUE</span> <span class="token keyword">HANDLER</span> <span class="token keyword">FOR</span> SQLSTATE <span class="token string">'02000'</span> <span class="token keyword">SET</span> done<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
	
	<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> ordertotals
		<span class="token punctuation">(</span>order_num <span class="token keyword">INT</span><span class="token punctuation">,</span> total <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">OPEN</span> ordernumbers<span class="token punctuation">;</span>
	
	<span class="token keyword">REPEAT</span>
		<span class="token keyword">FETCH</span> ordernumbers <span class="token keyword">INTO</span> o<span class="token punctuation">;</span>
		
		<span class="token keyword">CALL</span> ordertotal<span class="token punctuation">(</span>o<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">-- 执行另一个存储过程</span>
		
		<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> ordertotals<span class="token punctuation">(</span>order_num<span class="token punctuation">,</span> total<span class="token punctuation">)</span>
		<span class="token keyword">VALUES</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>
	UNTIL done <span class="token keyword">END</span> <span class="token keyword">REPEAT</span><span class="token punctuation">;</span>
	
	<span class="token keyword">CLOSE</span> ordernumbers<span class="token punctuation">;</span>
<span class="token keyword">END</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>此存储过程不返回数据，但它<strong>能够创建和填充另一个表</strong>。</p>
<blockquote>
<p>结果集</p>
</blockquote>
<blockquote>
<p>主要用于交互式应用</p>
</blockquote>
<blockquote>
<p>MySQL游标只能用于存储过程（和函数）</p>
</blockquote>
<blockquote>
<p>定义要使用的SELECT语句</p>
</blockquote>
<blockquote>
<p>把数据实际检索出来</p>
</blockquote>
<blockquote>
<p>在结束游标使用时，必须关闭游标</p>
</blockquote>
<blockquote>
<p>游标用DECLARE语句创建</p>
</blockquote>
<blockquote>
<p>OPEN CURSOR语句</p>
</blockquote>
<blockquote>
<p>存储检索出的数据以供浏览和滚动</p>
</blockquote>
<blockquote>
<p>CLOSE释放游标使用的所有内部内存和资源，因此在每个游标不再需要时都应该关闭。</p>
</blockquote>
<blockquote>
<p>果你不明确关闭游标，MySQL将会在到达END语句时自动关闭它。</p>
</blockquote>
<blockquote>
<p>FETCH指定检索什么数据（所需的列）</p>
</blockquote>
<blockquote>
<p>向前移动游标中的内部行指针，使下一条FETCH语句检索下一行（不重复读取同一行）</p>
</blockquote>
<blockquote>
<p>自动从第一行开始</p>
</blockquote>
<blockquote>
<p>REPEAT</p>
</blockquote>
<blockquote>
<p>UNTIL done END REPEAT</p>
</blockquote>
<blockquote>
<p>[插图]</p>
</blockquote>
<blockquote>
<p>CONTINUE HANDLER</p>
</blockquote>
<blockquote>
<p>MySQL还支持循环语句，它可用来重复执行代码，直到使用LEAVE语句手动退出为止</p>
</blockquote>
<blockquote>
<p>REPEAT语句的语法使它更适合于对游标进行循环。</p>
</blockquote>
<h2 id="第25章-使用触发器"><a href="#第25章-使用触发器" class="headerlink" title="第25章 使用触发器"></a>第25章 使用触发器</h2><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p><strong>MySQL语句在需要时被执行，存储过程也是如此</strong>。但是，如果你<strong>想要某条语句（或某些语句）在事件发生时自动执行</strong>，怎么办呢？例如：</p>
<ol>
<li><strong>每当增加一个</strong>顾客到某个数据库表时，都检查其电话号码格式是否正确，州的缩写是否为大写；</li>
<li><strong>每当订购一个</strong>产品时，都从库存数量中减去订购的数量；</li>
<li>无论何时<strong>删除一行</strong>，都在某个存档表中保留一个副本。</li>
</ol>
<p>这些例子的共同之处在于<strong>它们都需要在某个表发生更改时自动处理</strong>，<strong>触发器就是提供这样功能</strong>的工具。触发器是MySQL<strong>响应DELETE&#x2F;INSERT&#x2F;UPDATE语句</strong>而自动执行的<strong>一条</strong>（或<strong>位于BEGIN和END语句之间的一组语句</strong>）MySQL语句。<strong>其他MySQL语句不支持触发器</strong>。</p>
<hr>
<h3 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h3><p>在创建触发器时，需要给出4条信息：</p>
<ol>
<li>唯一的<strong>触发器名</strong>；</li>
<li>触发器<strong>关联的表</strong>；</li>
<li>触发器应该<strong>响应的活动</strong>（<strong>DELETE、INSERT或UPDATE</strong>）；</li>
<li>触发器<strong>何时执行</strong>（<strong>处理之前或之后</strong>）</li>
</ol>
<p><strong>保持每个数据库的触发器名唯一</strong></p>
<p>​	在MySQL 5中，触发器名必须在<strong>每个表中唯一</strong>，<strong>但不是在每个数据库中唯一</strong>。**这在其他每个数据库触发器名必须唯一的DBMS中是不允许的，**而且以后的MySQL版本很可能会使命名规则更为严格。因此，现在最好是在数据库范围内使用唯一的触发器名。</p>
<p>触发器用<strong>CREATE TRIGGER语句</strong>创建：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> newproduct 
<span class="token keyword">AFTER</span> <span class="token keyword">INSERT</span> <span class="token keyword">ON</span> products
<span class="token keyword">FOR EACH ROW</span> 
<span class="token keyword">SELECT</span> <span class="token string">'Product added'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>只有表才支持触发器</strong>，<strong>视图</strong>和<strong>临时表都不支持触发器</strong>。</li>
<li>触发器<strong>按每个表每个事件每次地定义，每个表每个事件每次只允许一个触发器</strong>。因此，每个表最多支持6个触发器（每条INSERT、UPDATE和DELETE的之前和之后）。</li>
<li>如果<strong>BEFORE触发器失败</strong>，则MySQL<strong>将不执行请求的操作</strong>。此外，如果<strong>BEFORE触发器或语句本身失败</strong>，MySQL<strong>将不执行AFTER触发器</strong>（如果有的话）。</li>
</ul>
<hr>
<h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TRIGGER</span> newproduct<span class="token punctuation">;</span>	<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>触发器<strong>不能更新或覆盖</strong>，<strong>为了修改一个触发器，必须先删除它，然后再重新创建</strong>。</p>
<hr>
<h3 id="使用触发器"><a href="#使用触发器" class="headerlink" title="使用触发器"></a>使用触发器</h3><h4 id="INSERT触发器"><a href="#INSERT触发器" class="headerlink" title="INSERT触发器"></a>INSERT触发器</h4><p>INSERT触发器在INSERT语句执行之前或之后执行。需要知道以下几点：</p>
<ol>
<li>在INSERT<strong>触发器代码内</strong>，可<strong>引用一个名为NEW的虚拟表</strong>，<strong>访问被插入的行</strong>；</li>
<li>在<strong>BEFORE</strong> INSERT触发器中，<strong>NEW中的值也可以被更新</strong>（允许更改被插入的值）；</li>
<li>对于<strong>AUTO_INCREMENT列</strong>，<strong>NEW在INSERT执行之前包含0</strong>，在INSERT执行之后包含新的自动生成值。</li>
</ol>
<p><strong>AUTO_INCREMENT列</strong>具有MySQL自动赋予的值。第21章建议了几种<strong>确定新生成值</strong>的方法，但下面是一种更好的方法：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> neworder
<span class="token keyword">AFTER</span> <span class="token keyword">INSERT</span> <span class="token keyword">ON</span> orders
<span class="token keyword">FOR EACH ROW</span> 
<span class="token keyword">SELECT</span> NEW<span class="token punctuation">.</span>order_num<span class="token punctuation">;</span> <span class="token comment">-- 引用一个名为NEW的虚拟表，访问被插入的行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>在插入一个新订单到orders表时，<strong>MySQL生成一个新订单号并保存到order_num中</strong>。触发器<strong>从NEW. order_num取得这个值并返回它</strong>。<strong>此触发器必须按照AFTER INSERT执行，因为在BEFORE INSERT语句执行之前，新order_num还没有生成</strong>。对于orders的每次插入使用这个触发器将总是返回新的订单号。</li>
</ul>
<p>通常，<strong>将BEFORE用于数据验证和净化</strong>（目的是保证插入表中的数据确实是需要的数据，对于UPDATE触发器也适用）。</p>
<hr>
<h4 id="DELETE触发器"><a href="#DELETE触发器" class="headerlink" title="DELETE触发器"></a>DELETE触发器</h4><ul>
<li>在DELETE触发器代码内，<strong>可以引用一个名为OLD的虚拟表</strong>，<strong>访问被删除的行</strong></li>
<li>OLD中的值全都是<strong>只读</strong>的，<strong>不能更新</strong></li>
</ul>
<p>下面的例子演示<strong>使用OLD保存将要被删除的行到一个存档表中</strong>：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> deleteorder 
BEFORE <span class="token keyword">DELETE</span> <span class="token keyword">ON</span> orders
<span class="token keyword">FOR EACH ROW</span>
<span class="token keyword">BEGIN</span>
	<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> archive_orders<span class="token punctuation">(</span>order_num<span class="token punctuation">,</span> order_date<span class="token punctuation">,</span> cust_id<span class="token punctuation">)</span>
	<span class="token keyword">VALUES</span><span class="token punctuation">(</span>OLD<span class="token punctuation">.</span>order_num<span class="token punctuation">,</span> OLD<span class="token punctuation">.</span>order_date<span class="token punctuation">,</span> OLD<span class="token punctuation">.</span>cust_id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">END</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>在<strong>任意订单被删除前</strong>将执行此触发器。</p>
</li>
<li><p>使用<strong>BEFORE DELETE触发器的优点</strong>（相对于AFTER DELETE触发器来说）为，<strong>如果由于某种原因，订单不能存档，DELETE本身将被放弃</strong>。</p>
</li>
<li><p>使用<strong>BEGIN END语句</strong>标记触发器体的好处是<strong>触发器能容纳多条SQL语句</strong>（在BEGIN END块中一条挨着一条）。</p>
</li>
</ul>
<hr>
<h4 id="UPDATE触发器"><a href="#UPDATE触发器" class="headerlink" title="UPDATE触发器"></a>UPDATE触发器</h4><ul>
<li>在UPDATE触发器代码中，你<strong>可以引用一个名为OLD的虚拟表访问以前（UPDATE语句前）的值</strong>，<strong>引用一个名为NEW的虚拟表访问新更新的值</strong>；</li>
<li>在<strong>BEFORE UPDATE触发器中</strong>，<strong>NEW中的值可能也被更新（允许更改将要用于UPDATE语句中的值）</strong>；</li>
<li><strong>OLD中的值全都是只读的，不能更新</strong>。</li>
</ul>
<p>下面的例子<strong>保证州名缩写总是大写</strong>:</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> updatevendor 
BEFORE <span class="token keyword">UPDATE</span> <span class="token keyword">ON</span> vendors
<span class="token keyword">FOR EACH ROW</span>
<span class="token keyword">SET</span> NEW<span class="token punctuation">.</span>vend_state <span class="token operator">=</span> Upper<span class="token punctuation">(</span>NEW<span class="token punctuation">.</span>vend_state<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>显然，任<strong>何数据净化都需要在UPDATE语句之前进行</strong>。</p>
<hr>
<h4 id="关于触发器的进一步介绍"><a href="#关于触发器的进一步介绍" class="headerlink" title="关于触发器的进一步介绍"></a>关于触发器的进一步介绍</h4><ol>
<li>与其他DBMS相比，MySQL 5中支持的触发器相当初级。未来的MySQL版本中有一些改进和增强触发器支持的计划。</li>
<li><strong>创建</strong>触发器<strong>可能需要特殊的安全访问权限</strong>，但是，<strong>触发器的执行是自动的</strong>。如果INSERT、UPDATE或DELETE语句能够执行，则相关的触发器也能执行。</li>
<li>应该<strong>用触发器来保证数据的一致性（大小写、格式等）</strong>。在触发器中<strong>执行这种类型的处理的优点是它总是进行这种处理，而且是透明地进行，与客户机应用无关</strong>。</li>
<li>触发器的一种非常有意义的使用是<strong>创建审计跟踪</strong>。使用触发器，<strong>把更改（如果需要，甚至还有之前和之后的状态）记录到另一个表非常容易</strong>。</li>
<li>遗憾的是，MySQL<strong>触发器中不支持CALL语句</strong>。这表示<strong>不能从触发器内调用存储过程。所需的存储过程代码需要复制到触发器内</strong>。</li>
</ol>
<hr>
<h2 id="第26章-管理事务处理"><a href="#第26章-管理事务处理" class="headerlink" title="第26章 管理事务处理"></a>第26章 管理事务处理</h2><blockquote>
<p>事务处理（transaction processing）可以用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行。</p>
</blockquote>
<blockquote>
<p>事务处理是一种机制，用来管理必须成批执行的MySQL操作，以保证数据库不包含不完整的操作结果</p>
</blockquote>
<blockquote>
<p>发生错误，则进行回退（撤销）以恢复数据库到某个已知且安全的状态。</p>
</blockquote>
<blockquote>
<p>❑ 事务（transaction）指一组SQL语句；❑ 回退（rollback）指撤销指定SQL语句的过程；❑ 提交（commit）指将未存储的SQL语句结果写入数据库表；❑ 保留点（savepoint）指事务处理中设置的临时占位符（place-holder），你可以对它发布回退（与回退整个事务处理不同）。</p>
</blockquote>
<blockquote>
<p>关键在于将SQL语句组分解为逻辑块</p>
</blockquote>
<blockquote>
<p>标识事务的开始</p>
</blockquote>
<blockquote>
<p>ROLLBACK命令用来回退（撤销）MySQL语句</p>
</blockquote>
<blockquote>
<p>用一条ROLLBACK语句回退STARTTRANSACTION之后的所有语句</p>
</blockquote>
<blockquote>
<p>ROLLBACK只能在一个事务处理内使用（在执行一条START TRANSACTION命令之后）。</p>
</blockquote>
<blockquote>
<p>哪些语句可以回退？ 事务处理用来管理INSERT、UPDATE和DELETE语句</p>
</blockquote>
<blockquote>
<p>不能回退CREATE或DROP操作</p>
</blockquote>
<blockquote>
<p>在事务处理块中，提交不会隐含地进行。为进行明确的提交，使用COMMIT语句</p>
</blockquote>
<blockquote>
<p>因为涉及更新两个数据库表orders和orderitems，所以使用事务处理块来保证订单不被部分删除。最后的COMMIT语句仅在不出错时写出更改。</p>
</blockquote>
<blockquote>
<p>更复杂的事务处理可能需要部分提交或回退。</p>
</blockquote>
<blockquote>
<p>必须能在事务处理块中合适的位置放置占位符</p>
</blockquote>
<blockquote>
<p>占位符称为保留点</p>
</blockquote>
<blockquote>
<p>SAVEPOINT</p>
</blockquote>
<blockquote>
<p> 保留点在事务处理完成（执行一条ROLLBACK或COMMIT）后自动释放。自MySQL 5以来，也可以用RELEASE SAVEPOINT明确地释放保留点。</p>
</blockquote>
<blockquote>
<p>任何时候你执行一条MySQL语句，该语句实际上都是针对表执行的，而且所做的更改立即生效。为指示MySQL不自动提交更改，需要使用以下语句：</p>
</blockquote>
<blockquote>
<p>设置autocommit为0（假）指示MySQL不自动提交更改（直到autocommit被设置为真为止）</p>
</blockquote>
<blockquote>
<p>针对每个连接而不是服务器</p>
</blockquote>
<h2 id="第27章-全球化和本地化"><a href="#第27章-全球化和本地化" class="headerlink" title="第27章 全球化和本地化"></a>第27章 全球化和本地化</h2><blockquote>
<p>❑ 字符集为字母和符号的集合；❑ 编码为某个字符集成员的内部表示；❑ 校对为规定字符如何比较的指令。</p>
</blockquote>
<blockquote>
<p>字符集</p>
</blockquote>
<blockquote>
<p>校对</p>
</blockquote>
<h2 id="第28章-安全管理"><a href="#第28章-安全管理" class="headerlink" title="第28章 安全管理"></a>第28章 安全管理</h2><blockquote>
<p>MySQL创建一个名为root的用户账号，它对整个MySQL服务器具有完全的控制</p>
</blockquote>
<blockquote>
<p>不过在现实世界的日常工作中，决不能使用root</p>
</blockquote>
<blockquote>
<p>mysql数据库有一个名为user的表，它包含所有用户账号。user表有一个名为user的列，它存储用户登录名</p>
</blockquote>
<blockquote>
<p>IDENTIFIED BY指定的口令为纯文本，MySQL将在保存到user表之前对其进行加密。为了作为散列值指定口令，使用IDENTIFIED BY PASSWORD</p>
</blockquote>
<blockquote>
<p>CREATE USER是最清楚和最简单的句子。此外，也可以通过直接插入行到user表来增加用户，不过为安全起见，一般不建议这样做</p>
</blockquote>
<blockquote>
<p>删除用户账号和所有相关的账号权限</p>
</blockquote>
<blockquote>
<p>MySQL 5以前，DROP USER只能用来删除用户账号，不能删除相关的权限</p>
</blockquote>
<blockquote>
<p>新创建的用户账号没有访问权限</p>
</blockquote>
<blockquote>
<p>MySQL的权限用用户名和主机名结合定义</p>
</blockquote>
<blockquote>
<p>此GRANT允许用户</p>
</blockquote>
<blockquote>
<p>使用SELECT</p>
</blockquote>
<blockquote>
<p>GRANT的反操作为REVOKE，用它来撤销特定的权限</p>
</blockquote>
<blockquote>
<p>被撤销的访问权限必须存在，否则会出错。</p>
</blockquote>
<blockquote>
<p>在使用GRANT和REVOKE时，用户账号必须存在，但对所涉及的对象没有这个要求</p>
</blockquote>
<blockquote>
<p>副作用是，当某个数据库或表被删除时（用DROP语句），相关的访问权限仍然存在。而且，如果将来重新创建该数据库或表，这些权限仍然起作用</p>
</blockquote>
<blockquote>
<p>列出各权限并用逗号分隔，将多条GRANT语句串在一起</p>
</blockquote>
<blockquote>
<p>更改用户口令，可使用SET PASSWORD语句</p>
</blockquote>
<blockquote>
<p>新口令必须传递到Password()函数进行加密</p>
</blockquote>
<blockquote>
<p>在不指定用户名时，SET PASSWORD更新当前登录用户的口令。</p>
</blockquote>
<h2 id="第29章-数据库维护"><a href="#第29章-数据库维护" class="headerlink" title="第29章 数据库维护"></a>第29章 数据库维护</h2><blockquote>
<p>MySQL数据库是基于磁盘的文件</p>
</blockquote>
<blockquote>
<p>由于这些文件总是处于打开和使用状态，普通的文件副本备份不一定总是有效。</p>
</blockquote>
<blockquote>
<p>转储所有数据库内容到某个外部文件</p>
</blockquote>
<blockquote>
<p>从一个数据库复制所有数据</p>
</blockquote>
<blockquote>
<p>BACKUP TABLE</p>
</blockquote>
<blockquote>
<p>SELECT INTO OUTFILE</p>
</blockquote>
<blockquote>
<p>数据可以用RESTORE TABLE来复原。</p>
</blockquote>
<blockquote>
<p>首先刷新未写数据 为了保证所有数据被写到磁盘（包括索引数据），可能需要在进行备份前使用FLUSH TABLES语句。</p>
</blockquote>
<blockquote>
<p> ANALYZE TABLE，用来检查表键是否正确</p>
</blockquote>
<blockquote>
<p> CHECK TABLE用来针对许多问题对表进行检查</p>
</blockquote>
<blockquote>
<p>CHANGED检查自最后一次检查以来改动过的表。EXTENDED执行最彻底的检查，FAST只检查未正常关闭的表，MEDIUM检查所有被删除的链接并进行键检验，QUICK只进行快速扫描</p>
</blockquote>
<blockquote>
<p>下面是几个重要的mysqld命令行选项：❑ –help显示帮助——一个选项列表；❑ –safe-mode装载减去某些最佳配置的服务器；❑ –verbose显示全文本消息（为获得更详细的帮助消息与–help联合使用）；❑ –version显示版本信息然后退出。</p>
</blockquote>
<blockquote>
<p>错误日志。它包含启动和关闭问题以及任意关键错误的细节</p>
</blockquote>
<blockquote>
<p>位于data目录中</p>
</blockquote>
<blockquote>
<p>查询日志。它记录所有MySQL活动，在诊断问题时非常有用</p>
</blockquote>
<blockquote>
<p>位于data目录中</p>
</blockquote>
<blockquote>
<p>二进制日志。它记录更新过数据（或者可能更新过数据）的所有语句</p>
</blockquote>
<blockquote>
<p>位于data目录内</p>
</blockquote>
<blockquote>
<p>缓慢查询日志。顾名思义，此日志记录执行缓慢的任何查询</p>
</blockquote>
<blockquote>
<p>在确定数据库何处需要优化很有用</p>
</blockquote>
<blockquote>
<p>位于data目录中</p>
</blockquote>
<blockquote>
<p>使用日志时，可用FLUSH LOGS语句来刷新和重新开始所有日志文件。</p>
</blockquote>
<h2 id="第30章-改善性能"><a href="#第30章-改善性能" class="headerlink" title="第30章 改善性能"></a>第30章 改善性能</h2><ul>
<li><p>MySQL<strong>和所有的DBMS一样，具有特定的硬件建议</strong>。在学习和研究MySQL时，使用任何旧的计算机作为服务器都可以。但对<strong>用于生产的服务器来说，应该坚持遵循这些硬件建议</strong>。 </p>
</li>
<li><p>MySQL是<strong>用一系列的默认设置预先配置的，这些设置开始通常是很好的</strong>。但过一段时间后你可能需<strong>要调整内存分配、缓冲区大小</strong>等(为查看当前设置，可使用<code>SHOW VARIABLES;</code>和<code>SHOW STATUS;</code>)。 </p>
</li>
<li><p>MySQL是一个<strong>多用户多线程</strong>的DBMS。如果遇到<strong>显著的性能不良</strong>，可使用<code>SHOW PROCESSLIST;</code><strong>显示所有活动进程</strong>（以及它们的线程ID和执行时间）。你还可以<strong>用KILL命令终结某个特定的进程</strong>（使用这个命令<strong>需要作为管理员登录</strong>）</p>
</li>
<li><p>一般来说，<strong>存储过程执行得</strong>比一条一条地执行其中的各条语句要<strong>快</strong>。</p>
</li>
<li><p><strong>除非需要每一个列</strong>，否则不要用<code>SELECT *</code></p>
</li>
<li><p>有的操作（包括INSERT）支持一个可选的<strong>DELAYED关键字</strong>，如果使用它，将<strong>把控制立即返回给调用程序</strong>，并且<strong>一旦有可能就实际执行该操作</strong></p>
</li>
<li><p>导入数据时，应该<strong>关闭自动提交</strong>。你可能还想<strong>删除索引(包括FULLTEXT索引)</strong>，然后<strong>在导入完成后重建它们</strong>。</p>
</li>
<li><p>必须<strong>索引数据库表以改善数据检索的性能</strong>。</p>
</li>
<li><p>如果<strong>有一系列复杂的OR条件</strong>，通过<strong>使用多条SELECT语句和连接它们的UNION语句</strong>，<strong>能看到极大的性能改进</strong>。</p>
</li>
<li><p><strong>索引</strong>改善数据检索的性能，但<strong>损害数据插入、删除和更新的性能</strong>。如果有一些表，它们<strong>收集数据</strong>且不经常被搜索，则<strong>在有必要之前不要索引它们</strong>。</p>
</li>
<li><p>LIKE很慢，一般来说，<strong>最好是使用FULLTEXT而不是LIKE</strong>。</p>
</li>
<li><p>数据库是不断变化的实体，<strong>理想的优化和配置也会改变</strong>。</p>
</li>
</ul>
<h3 id="SQL如何提高查询效率"><a href="#SQL如何提高查询效率" class="headerlink" title="SQL如何提高查询效率"></a>SQL如何提高查询效率</h3><h4 id="1-参数是子查询-14章-时，使用-EXISTS-还是-IN"><a href="#1-参数是子查询-14章-时，使用-EXISTS-还是-IN" class="headerlink" title="1. 参数是子查询(14章)时，使用 EXISTS 还是 IN"></a>1. 参数是子查询(14章)时，使用 EXISTS 还是 IN</h4><p>在大多数时候，<code>[NOT] IN</code>和<code>[NOT] EXISTS</code>返回的结果是相同的。</p>
<p>当<strong>主表比从表大</strong>时，<strong>IN查询的效率较高</strong>；当<strong>从表比主表大</strong>时，<strong>EXISTS查询的效率较高</strong>。</p>
<ul>
<li>IN是<strong>先执行子查询，得到一个结果集</strong>，将结果集代入外层谓词条件执行主查询，子查询只需要执行一次</li>
<li>EXISTS是<strong>先从主查询中取得一条数据，再代入到子查询中</strong>，执行一次子查询，判断子查询是否能返回结果，<strong>主查询有多少条数据，子查询就要执行多少次</strong>。</li>
</ul>
<p>例：从Class_A表中查出同时存在于Class_B表中的员工。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 慢</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Class_A
<span class="token keyword">WHERE</span> id <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> id 
             <span class="token keyword">FROM</span> Class_B<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment"># 快</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Class_A
<span class="token keyword">WHERE</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> 
              <span class="token keyword">FROM</span> Class_B 
              <span class="token keyword">WHERE</span> A<span class="token punctuation">.</span>id <span class="token operator">=</span> B<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>使用EXISTS时更快</strong>的原因：</p>
<ol>
<li><p>如果<strong>连接列</strong>(上例中为<code>id</code>)<strong>建立了索引</strong>，那么查询Class_B时不用查实际的表，只需要查索引就可以了。</p>
</li>
<li><p><strong>使用EXISTS，只要查到一行数据满足条件就会终止查询</strong>，而<strong>使用IN时会将表全扫描一遍</strong>。</p>
<p> IN的参数是子查询时，数据库<strong>首先执行子查询</strong>，然后<strong>将结果存储在一张临时的工作表里</strong>（<strong>内联视图</strong>），然后<strong>扫描整个视图</strong>。使用 EXISTS 的话，数据库不会生成临时的工作表。</p>
</li>
</ol>
<p>要想<strong>改善 IN 的性能</strong>，除了使用 EXISTS ，<strong>还可以使用连接(JOIN)</strong>：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 使用连接代替IN</span>
<span class="token keyword">SELECT</span> A<span class="token punctuation">.</span>id<span class="token punctuation">,</span> A<span class="token punctuation">.</span>name
<span class="token keyword">FROM</span> Class_A <span class="token keyword">AS</span> A <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> Class_B <span class="token keyword">AS</span> B
<span class="token keyword">ON</span> A<span class="token punctuation">.</span>id <span class="token operator">=</span> B<span class="token punctuation">.</span>id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>因为没有了子查询，数据库也不会产生中间表。<strong>很难JOIN和EXISTS相比谁更好，但如果没有索引，可能EXISTS会更胜一筹</strong>。</p>
<hr>
<h4 id="2-避免排序"><a href="#2-避免排序" class="headerlink" title="2. 避免排序"></a>2. 避免排序</h4><p>我们<strong>在查询的时候</strong>，即使没想进行排序，但是<strong>在数据库内部仍然频繁地进行着暗中的排序</strong>。<strong>会进行排序的代表性运算</strong>：</p>
<ul>
<li><code>GROUP BY</code>子句</li>
<li><code>ORDER BY</code>子句</li>
<li>聚合函数(<code>SUM()</code>、<code>COUNT()</code>、<code>AVG()</code>、<code>MAX()</code>、<code>MIN()</code>)</li>
<li><code>DISTINCT</code></li>
<li>集合运算符(<code>UNION</code>、<code>INTERSECT</code>、<code>EXCEPT</code>)</li>
<li>窗口函数(<code>RANK</code>、<code>ROW_NUMBER</code>等)</li>
</ul>
<hr>
<h5 id="使用UNION-ALL代替UNION"><a href="#使用UNION-ALL代替UNION" class="headerlink" title="使用UNION ALL代替UNION"></a>使用<code>UNION ALL</code>代替<code>UNION</code></h5><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Class_A
<span class="token keyword">UNION</span> 
<span class="token keyword">SELECT</span> <span class="token operator">*</span> 
<span class="token keyword">FROM</span> Class_B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个操作会进行排序，如果<strong>不在乎结果中是否有重复数据</strong>，可以使用<code>UNION ALL</code>代替<code>UNION</code>。</p>
<hr>
<h5 id="使用EXISTS代替DISTINCT"><a href="#使用EXISTS代替DISTINCT" class="headerlink" title="使用EXISTS代替DISTINCT"></a>使用<code>EXISTS</code>代替<code>DISTINCT</code></h5><p>为了排除重复数据，<code>DISTINCT</code>也会进行排序。<strong>如果需要对两张表的连接结果进行去重</strong>，可以考虑用<code>EXISTS</code>代替<code>DISTINCT</code>，以避免排序。</p>
<p>例：从商品表Items中找出同时存在于销售记录表SalesHistory中的商品。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> I<span class="token punctuation">.</span>item
<span class="token keyword">FROM</span> Item <span class="token keyword">AS</span> I <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> SalesHistory <span class="token keyword">AS</span> SH
<span class="token keyword">ON</span> I<span class="token punctuation">.</span>item_no <span class="token operator">=</span> SH<span class="token punctuation">.</span>item_no<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>因为是一对多连接，所以<code>item_no</code>列中会出现重复数据，<strong>为了排除重复数据，需要使用DISTINCT</strong>。但是<strong>使用DISTINCT会排序，更好的做法是使用<code>EXISTS</code></strong>：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> I<span class="token punctuation">.</span>item_no
<span class="token keyword">FROM</span> Item <span class="token keyword">AS</span> I <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> SalesHistory <span class="token keyword">AS</span> SH
<span class="token keyword">ON</span> I<span class="token punctuation">.</span> item_no <span class="token operator">=</span> SH<span class="token punctuation">.</span> item_no<span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> item_no
<span class="token keyword">FROM</span> Items <span class="token keyword">AS</span> I
<span class="token keyword">WHERE</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> 
              <span class="token keyword">FROM</span> SalesHistory SH 
              <span class="token keyword">WHERE</span> I<span class="token punctuation">.</span>item_no <span class="token operator">=</span> SH<span class="token punctuation">.</span>item_no<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h5 id="在极值函数-MAX-MIN-中使用索引"><a href="#在极值函数-MAX-MIN-中使用索引" class="headerlink" title="在极值函数(MAX&#x2F;MIN)中使用索引"></a>在极值函数(MAX&#x2F;MIN)中使用索引</h5><p>使用<code>MAX()</code>和<code>MIN()</code>这两个函数都会进行排序。但<strong>如果参数字段上建有索引，则只需要扫描索引，不需要扫描整张表</strong>。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 以Item表为例</span>
<span class="token keyword">SELECT</span> <span class="token function">MAX</span><span class="token punctuation">(</span>item_no<span class="token punctuation">)</span>
<span class="token keyword">FROM</span> Items<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>这种方法并不是去掉了排序的过程，而是<strong>优化了排序前的查找速度(只需要扫描索引，不需要扫描整张表)</strong>，从而减弱了排序对整体性能的影响。</p>
<hr>
<h5 id="能写在WHERE子句里的条件不要写在HAVING子句里"><a href="#能写在WHERE子句里的条件不要写在HAVING子句里" class="headerlink" title="能写在WHERE子句里的条件不要写在HAVING子句里"></a>能写在WHERE子句里的条件不要写在HAVING子句里</h5><ul>
<li><p>聚合<strong>后</strong>使用HAVING子句过滤</p>
  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> sale_date<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>quantity<span class="token punctuation">)</span>
<span class="token keyword">FROM</span> SalesHistory
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> sale_date
<span class="token keyword">HAVING</span> sale_date <span class="token operator">=</span> <span class="token string">'2007-10-01'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>聚合<strong>前</strong>使用WHERE子句过滤</p>
  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> sale_date<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>quantity<span class="token punctuation">)</span>
<span class="token keyword">FROM</span> SalesHistory
<span class="token keyword">WHERE</span> sale_date <span class="token operator">=</span> <span class="token string">'2007-10-01'</span>
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> sale_date<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<p>虽然结果是一样的，但是<strong>从性能上来看，使用WHERE语句效率更高</strong>。原因通常有两个：</p>
<ol>
<li>在使用<strong>GROUP BY</strong>子句聚合时会进行<strong>排序</strong>，如果事先通过<strong>WHERE</strong> 子句<strong>筛选出一部分行，就能够减轻排序的负担</strong>。</li>
<li>在<strong>WHERE</strong> 子句的条件里<strong>可以使用索引</strong>。而<strong>HAVING</strong>子句是<strong>针对聚合后生成的视图进行筛选的</strong>，但是<strong>很多时候聚合后的视图都没有继承原表的索引结构</strong>。</li>
</ol>
<hr>
<h4 id="3-真正把索引利用起来"><a href="#3-真正把索引利用起来" class="headerlink" title="3. 真正把索引利用起来"></a>3. 真正把索引利用起来</h4><p>列举一些<strong>导致索引失效的作法</strong>：</p>
<ol>
<li><p><strong>索引字段上进行计算</strong>，会进行全表扫描。</p>
 <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> someTable
<span class="token keyword">WHERE</span> col_1 <span class="token operator">*</span> <span class="token number">1.1</span> <span class="token operator">></span> <span class="token number">100</span><span class="token punctuation">;</span>

<span class="token comment"># 优化方法：把运算的表达式放到查询条件的右侧</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> someTable
<span class="token keyword">WHERE</span> col_1 <span class="token operator">></span> <span class="token number">100</span><span class="token operator">/</span><span class="token number">1.1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p> 实际上，<strong>只要索引列上使用函数的时候，索引就会失效</strong>。</p>
</li>
<li><p><strong>使用<code>IS NULL</code>谓词</strong></p>
<p> <strong>通常索引字段不存在NULL</strong>，所以指定IS NULL和IS NOT NULL的话会使得索引无法使用，进而导致查询性能低下。</p>
 <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> someTable
<span class="token keyword">WHERE</span> col_1 <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>使用否定形式</strong></p>
<ul>
<li><p><code>&lt;&gt;</code>&#x2F;<code>!=</code></p>
</li>
<li><p><code>NOT IN</code></p>
</li>
</ul>
</li>
<li><p><strong>使用OR</strong></p>
<p> 在<code>col_1</code>和<code>col_2</code>上<strong>分别建立了不同的索引，或者建立了(col_1,col_2)这样的联合索引时</strong>，如果<strong>使用OR连接条件</strong>，<strong>要么用不到索引，要么用到了但是效率比AND要差很多</strong>。</p>
 <pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT *
FROM someTable
WHERE col_1 &gt; 100
OR col_2 &#x3D; &#39;abc&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>使用<strong>联合索引</strong>时，<strong>列的顺序错误</strong></p>
<p> 假设存在这样顺序的一个<strong>联合索引</strong>(col_1, col_2, col_3)。<strong>联合索引中的第一列col_1必须写在查询条件的开头</strong>，而且<strong>索引中列的顺序不能颠倒</strong>。<strong>如果无法保证查询条件里列的顺序与索引一致，可以考虑将联合索引拆分为多个索引</strong>。</p>
 <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 能够利用索引的操作</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> 
<span class="token keyword">FROM</span> SomeTable 
<span class="token keyword">WHERE</span> col_1 <span class="token operator">=</span> <span class="token number">10</span> 
	<span class="token operator">AND</span> col_2 <span class="token operator">=</span> <span class="token number">100</span> 
	<span class="token operator">AND</span> col_3 <span class="token operator">=</span> <span class="token number">500</span><span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span> 
<span class="token keyword">FROM</span> SomeTable 
<span class="token keyword">WHERE</span> col_1 <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">AND</span> col_2 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>

<span class="token comment">-------</span>
<span class="token comment"># 不能利用索引的操作</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> 
<span class="token keyword">FROM</span> SomeTable 
<span class="token keyword">WHERE</span> col_1 <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">AND</span> col_3 <span class="token operator">=</span> <span class="token number">500</span><span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span> 
<span class="token keyword">FROM</span> SomeTable 
<span class="token keyword">WHERE</span> col_2 <span class="token operator">=</span> <span class="token number">100</span> <span class="token operator">AND</span> col_3 <span class="token operator">=</span> <span class="token number">500</span><span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span> 
<span class="token keyword">FROM</span> SomeTable 
<span class="token keyword">WHERE</span> col_2 <span class="token operator">=</span> <span class="token number">100</span> <span class="token operator">AND</span> col_1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>使用<strong>LIKE</strong>进行<strong>后方一致</strong>或<strong>中间一致</strong>的匹配</p>
 <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 索引失效 %为通配符，表示任何字符出现任意次数</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> 
<span class="token keyword">FROM</span> SomeTable 
<span class="token keyword">WHERE</span> col_1 <span class="token operator">LIKE</span> <span class="token string">'%a'</span><span class="token punctuation">;</span> <span class="token comment"># 后方一致</span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span> 
<span class="token keyword">FROM</span> SomeTable 
<span class="token keyword">WHERE</span> col_1 <span class="token operator">LIKE</span> <span class="token string">'%a%'</span><span class="token punctuation">;</span> <span class="token comment"># 中间一致</span>

<span class="token comment">-----------</span>
<span class="token comment"># 索引有效</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> 
<span class="token keyword">FROM</span> SomeTable 
<span class="token keyword">WHERE</span> col_1 <span class="token operator">LIKE</span> <span class="token string">'a%'</span><span class="token punctuation">;</span> <span class="token comment"># 开头一致</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>进行隐式的类型转换</strong></p>
 <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 例如 col_1列的类型为 字符</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> 
<span class="token keyword">FROM</span> SomeTable 
<span class="token keyword">WHERE</span> col_1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment"># 隐式的类型转换，不仅会增加额外的性能开销，还会导致索引不可用</span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span> 
<span class="token keyword">FROM</span> SomeTable 
<span class="token keyword">WHERE</span> col_1 <span class="token operator">=</span> CAST<span class="token punctuation">(</span><span class="token number">10</span> <span class="token keyword">AS</span> <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment"># 把数字10转换为长度为2的字符</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<hr>
<h4 id="减少中间表"><a href="#减少中间表" class="headerlink" title="减少中间表"></a>减少中间表</h4><p>在 SQL 中，<strong>子查询的结果会被看成一张新表</strong>，这张新表与原始表一样，可以通过代码进行操作。这种高度的相似性使得 SQL 编程具有非常强的灵活性，但是<strong>如果不加限制地大量使用中间表，会导致查询性能下降</strong>。</p>
<p>频繁使用中间表会带来两个问题：</p>
<ol>
<li><strong>展开数据需要耗费内存资源</strong></li>
<li><strong>原始表中的索引不容易使用到</strong>（特别是聚合时）</li>
</ol>
<p>因此，<strong>尽量减少中间表的使用</strong>也是提升性能的一个重要方法。</p>
<p><strong>灵活使用HAVING子句 可以减少中间表的使用</strong>：</p>
<p>​	<strong>对聚合结果指定筛选条件时，使用 HAVING 子句是基本原则</strong>。不习惯使用 HAVING 子句的数据库工程师可能会倾向于像下面这样先生成一张中间表，然后在 WHERE 子句中指定筛选条件：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> sale_date<span class="token punctuation">,</span> <span class="token function">MAX</span><span class="token punctuation">(</span>quantity<span class="token punctuation">)</span> <span class="token keyword">AS</span> max_qty 
      <span class="token keyword">FROM</span> SalesHistory
      <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> sale_date<span class="token punctuation">)</span> TMP <span class="token comment"># 没用的中间表</span>
<span class="token keyword">WHERE</span> max_qty <span class="token operator">>=</span> <span class="token number">10</span><span class="token punctuation">;</span>

<span class="token comment"># 使用HAVING子句的写法</span>
<span class="token keyword">SELECT</span> sale_date<span class="token punctuation">,</span> <span class="token function">MAX</span><span class="token punctuation">(</span>quantity<span class="token punctuation">)</span> <span class="token keyword">AS</span> max_qty 
<span class="token keyword">FROM</span> SalesHistory
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> sale_date 
<span class="token keyword">HAVING</span> max_qty <span class="token operator">>=</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>HAVING子句和聚合操作(GROUP BY)是同时执行的，所以比起生成中间表后再执行的WHERE子句，效率更高，代码更简洁</strong>。</p>
<hr>
<h2 id="附录C-MySQL语句的语法"><a href="#附录C-MySQL语句的语法" class="headerlink" title="附录C MySQL语句的语法"></a>附录C MySQL语句的语法</h2><blockquote>
<p>方括号中</p>
</blockquote>
<blockquote>
<p>是可选的</p>
</blockquote>
<blockquote>
<p>更新已存在表的模式</p>
</blockquote>
<blockquote>
<p>将事务处理写到数据库</p>
</blockquote>
<blockquote>
<p>在一个或多个列上创建索引</p>
</blockquote>
<h2 id="附录D-MySQL数据类型"><a href="#附录D-MySQL数据类型" class="headerlink" title="附录D MySQL数据类型"></a>附录D MySQL数据类型</h2><h3 id="字符串数据类型"><a href="#字符串数据类型" class="headerlink" title="字符串数据类型"></a>字符串数据类型</h3><ul>
<li><strong>定长串</strong>：接受长度固定的字符串，其<strong>长度是在创建表时指定的</strong>。<ul>
<li>定长列不允许多于指定的字符数目，它们<strong>分配的存储空间和指定的一样多</strong>。</li>
<li><strong>CHAR</strong>属于定长串类型</li>
</ul>
</li>
<li><strong>变长串</strong>：存储可变长度的文本。<ul>
<li>有些变长数据类型<strong>具有最大的定长</strong>；有些则是<strong>完全变长</strong>的。</li>
<li><strong>TEXT</strong>属于变长串类型</li>
</ul>
</li>
</ul>
<p><strong>为什么要使用定长数据类型</strong>？</p>
<p>​	因为<strong>性能</strong>，MySQL<strong>处理定长列要快得多</strong>。此外，<strong>不允许对变长列（或一个列的可变部分）进行索引</strong>。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CHAR(size)</td>
<td>最多设置255个字符的<strong>定长</strong>串。<br />长度必须在创建时指定，否则MySQL默认为<code>CHAR(1)</code></td>
</tr>
<tr>
<td>VARCHAR(size)</td>
<td>最多设置255个字符的<strong>变长</strong>串。<br />如果<strong>值的长度 &gt; 255，会转为TEXT类型</strong>。</td>
</tr>
<tr>
<td>TEXT</td>
<td>最大长度为65535($2^{16}$)的<strong>变长</strong>串。</td>
</tr>
<tr>
<td>TINYTEXT</td>
<td>最大长度为255个字符的<strong>变长</strong>串，类型与TEXT相同</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>最大长度为$2^{14}$的变长串</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>最大长度为$2^{22}$的变长串</td>
</tr>
<tr>
<td>ENUM(x, y, z, etc.)</td>
<td>枚举，最多$2^{16}$<strong>个</strong>变长串</td>
</tr>
</tbody></table>
<ul>
<li><p>不管使用何种形式的串数据类型，串值都<strong>必须括在引号内</strong>（通常<strong>单引号更好</strong>）。</p>
</li>
<li><p>如果数值是计算（求和、平均等）中使用的数值，则应该存储在数值数据类型列中。如果作为字符串（可能只包含数字）使用，则应该保存在串数据类型列中。</p>
</li>
</ul>
<hr>
<h3 id="数值数据类型"><a href="#数值数据类型" class="headerlink" title="数值数据类型"></a>数值数据类型</h3><p>所有数值类型(除BIT和BOOLEAN外)都可以有符号或无符号。<strong>有符号数值列</strong>可以存储正&#x2F;负数值，<strong>无符号数值列</strong>只能存储<strong>正数</strong>。<strong>默认情况为有符号</strong>，但如果你知道自己<strong>不需要存储负值，可以使用 UNSIGNED关键字</strong>。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>BIT</td>
<td><strong>位</strong>，1~64位</td>
</tr>
<tr>
<td>BOOLEAN&#x2F;BOOL</td>
<td>取值为0&#x2F;1</td>
</tr>
<tr>
<td>INT(size)</td>
<td>整数值<br />（$-2^{31}\sim2^{31}-1$，UNSIGNED时，为$0\sim2^{32}-1$)</td>
</tr>
<tr>
<td>TINYINT(size)</td>
<td>整数值<br />($-2^7\sim2^7-1$，UNSIGNED时，为$0\sim2^8-1$)</td>
</tr>
<tr>
<td>SMALLINT(size)</td>
<td>整数值<br />($-2^{15}\sim2^{15}-1$，UNSIGNED时，为$0\sim 2^{16}-1$)</td>
</tr>
<tr>
<td>MEDIUMINT(size)</td>
<td>整数值<br />($-2^{23}\sim 2^{23}-1$，UNSIGNED时，为$0\sim 2^{24}-1$)</td>
</tr>
<tr>
<td>BIGINT(size)</td>
<td>整数值<br />($-2^{63}\sim 2^{63}-1$，UNSIGNED时，为$0\sim 2^{64}-1$)</td>
</tr>
<tr>
<td>FLOAT(size, d)</td>
<td>单精度浮点数，存在精度损失<br />size规定<strong>最大位数(小数点左侧和右侧)</strong>，d规定<strong>小数点右侧的最大位数</strong>。</td>
</tr>
<tr>
<td>DOUBLE(size, d)</td>
<td>双精度浮点数，存在精度损失<br />size规定<strong>最大位数(小数点左侧和右侧)</strong>，d规定<strong>小数点右侧的最大位数</strong>。</td>
</tr>
<tr>
<td>DECIMAL(size, d)</td>
<td><strong>以字符串的形式保存</strong>数值，<strong>不存在精度损失</strong>。<br />适用于<strong>存储货币</strong>等金融数据。</td>
</tr>
</tbody></table>
<ul>
<li>MySQL中没有专门<strong>存储货币</strong>的数据类型，一般情况下使用<strong>DECIMAL(8, 2)</strong>。</li>
</ul>
<hr>
<h3 id="日期和时间数据类型"><a href="#日期和时间数据类型" class="headerlink" title="日期和时间数据类型"></a>日期和时间数据类型</h3><table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>DATE</td>
<td>日期，格式为<code>YYYY-MM-DD</code><br />支持的范围：1000-01-01~9999-12-31</td>
</tr>
<tr>
<td>TIME</td>
<td>时间，格式为<code>HH:MM:SS</code></td>
</tr>
<tr>
<td>DATETIME</td>
<td>DATE和TIME的组合<br />支持的范围：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>功能同DATETIME，<strong>格式更包容，但范围较小</strong><br />支持的范围：1970-01-01 00:00:01 UTC ~ 2038-01-09 03:14:07 UTC</td>
</tr>
<tr>
<td>YEAR</td>
<td>用2位数字表示，范围是70(1970)<del>69(2069)；<br />用4位数字表示，范围是1901</del>2155</td>
</tr>
</tbody></table>
<p> 即便<strong>DATETIME</strong>和<strong>TIMESTAMP</strong>返回相同的格式，它们的工作方式很不同。在<strong>INSERT</strong>或<strong>UPDATE</strong>查询中，<strong>TIMESTAMP自动把自身设置为当前的日期和时间</strong>。TIMESTAMP也接受不同的格式，比如<strong>YYYYMMDDHHMMSS、YYMMDDHHMMSS、YYYYMMDD 或 YYMMDD</strong></p>
<hr>
<h3 id="二进制数据类型"><a href="#二进制数据类型" class="headerlink" title="二进制数据类型"></a>二进制数据类型</h3><p>二进制数据类型<strong>可存储任何数据</strong>（甚至包括<strong>二进制信息</strong>），如图像、多媒体、字处理文档等。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>BLOB</td>
<td>用于 BLOBs (Binary Large OBjects，<strong>二进制大型对象</strong>)。存放最多$2^{16}$B的数据</td>
</tr>
<tr>
<td>TINYBLOB</td>
<td>最大长度为$2^8-1$B</td>
</tr>
<tr>
<td>MEDIUMBLOB</td>
<td>最大长度为$2^{24}$B</td>
</tr>
<tr>
<td>LONGBLOB</td>
<td>最大长度为$2^{32}$B</td>
</tr>
</tbody></table>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/MySQL/" rel="tag"><i class="fa fa-tag"></i> MySQL</a>
              <a href="/tags/SQL/" rel="tag"><i class="fa fa-tag"></i> SQL</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/06/13/Python%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/" rel="prev" title="Python入门到实践">
                  <i class="fa fa-angle-left"></i> Python入门到实践
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/06/16/MySQL%E6%8A%A5%E9%94%99%E7%9A%84%E5%88%86%E7%B1%BB%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/" rel="next" title="MySQL报错的分类与解决方法">
                  MySQL报错的分类与解决方法 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Hunter</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"Hunter1023/Hunter1023.github.io","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
